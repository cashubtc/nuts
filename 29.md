# NUT-29: Conditional Token Framework

`optional`

`depends on: NUT-28`

---

This NUT describes a Conditional Token Framework (CTF) that enables prediction markets using ecash. Inspired by the [Gnosis Conditional Token Framework](https://docs.gnosis.io/conditionaltokens/), this specification allows users to deposit collateral and receive complete sets of conditional tokens for a condition. Conditional tokens are represented by conditional keysets ([NUT-28][28]) and can be traded freely via standard [NUT-03][03] swaps. After oracle attestation, winners redeem their conditional tokens by swapping to a regular keyset with an oracle witness.

Caution: This specification relies on [NUT-28][28] for oracle attestation. Applications must verify that the mint supports both NUT-28 and NUT-29 by checking the mint's [info][06] endpoint.

## Terminology

This NUT uses the terminology defined in [NUT-28][28], including **condition**, **outcome collection**, **partition**, **condition ID**, **outcome collection ID**, **conditional keyset**, and **conditional token**.

Additional terms:

- **Collection ID** (`collection_id`): An EC point on secp256k1 representing a composite outcome selection. Enables order-independent (commutative) nesting in combinatorial markets. Encoded as a 32-byte x-only public key.

## Motivation

Conditional tokens enable powerful prediction market use cases:

1. **Complete outcome collection sets** - Users receive tokens for ALL outcome collections, ensuring the condition is fully collateralized
2. **Trading** - Conditional tokens can be freely traded before resolution via standard [NUT-03][03] swaps
3. **Atomic splits** - A single operation creates all conditional tokens, preventing partial positions
4. **Conditional keysets** - Each outcome collection has a unique keyset, enabling trustless token identification
5. **Outcome collections** - Tokens can represent multiple outcomes (e.g., "not Trump" covering all other candidates)
6. **Combinatorial markets** - Hierarchical nesting of conditions via collection IDs enables complex multi-condition markets

By following the Gnosis CTF model, this specification provides a proven approach to conditional tokens adapted for the Cashu ecosystem.

## Overview

The CTF lifecycle consists of:

1. **Register**: Condition is registered via [NUT-28][28], mint creates conditional keysets
2. **Split**: User deposits collateral -> receives complete set of conditional tokens (conditional keysets)
3. **Trade**: Users trade conditional tokens (standard NUT-03 swaps within same conditional keyset)
4. **Oracle Attests**: Oracle signs the winning outcome
5. **Redeem**: Winners redeem conditional keyset tokens for regular keyset tokens (`POST /v1/redeem_outcome` + oracle witness, [NUT-28][28])

```
           Register            Split                    Trade                 Attest              Redeem
Wallet ────────────► Mint   User ──────────────► Conditional ◄────────────►  Oracle ────────►    Winner ──────────►
       cond. info    creates     100 sats        Tokens         NUT-03       Signs              redeem_outcome
                     keysets                      (YES+NO        Swap         Outcome            → Regular
                                                  keysets)                                       Keyset
```

## Split Operation

The split operation allows users to deposit collateral and receive a complete set of conditional tokens. For every unit of collateral deposited, the user receives one token for each possible outcome collection.

Conditions must be registered via `POST /v1/conditions` ([NUT-28][28]) before splitting.

### Endpoint

```
POST /v1/ctf/split
```

### Request Body

```json
{
  "condition_id": <hex_str>,
  "inputs": <Array[Proof]>,
  "outputs": {
    "<outcome_collection_1>": <Array[BlindedMessage]>,
    "<outcome_collection_2>": <Array[BlindedMessage]>,
    ...
  }
}
```

- `condition_id`: The 32-byte condition identifier (64 hex characters). Must reference a condition registered via `POST /v1/conditions` ([NUT-28][28]). Returns error 13021 (Condition not found) if unknown.
- `inputs`: Array of `Proof` objects used as collateral (see [NUT-00][00]). For root conditions, these use a **regular keyset**. For nested conditions, these use the **conditional keyset** identified by the parent collection's outcome collection (see [Combinatorial Markets](#combinatorial-markets)).
- `outputs`: Object mapping each outcome collection to an array of `BlindedMessage` objects. Each `BlindedMessage` MUST use the **outcome-collection-specific keyset ID** returned during condition registration. Keys use pipe-separated notation for outcome collections (e.g., `"ALICE|BOB"`).

If the mint returns error 13021 (Condition not found), the wallet SHOULD register the condition using `POST /v1/conditions` ([NUT-28][28]) and retry the split.

### Output Requirements

1. The output keys MUST form a valid partition of all outcomes (see [Partition Rules][28])
2. Each output key's total amount MUST be identical
3. Each `BlindedMessage` MUST use the keyset ID corresponding to its outcome collection
4. Fees are deducted from collateral inputs before splitting: `sum(each_outcome_collection_outputs) = sum(inputs) - fees(inputs)`, where `fees(inputs)` is calculated per [NUT-02][02] from each input proof's keyset `input_fee_ppk`

For example, with 100 sats collateral in a binary market:

- `inputs`: 100 sats total (regular keyset `009a1f293253e41e`)
- `outputs["YES"]`: 100 sats total in blinded messages (conditional keyset `00abc123def456`)
- `outputs["NO"]`: 100 sats total in blinded messages (conditional keyset `00def789abc012`)

With outcome collections in a 3-outcome condition:

- `inputs`: 100 sats total (regular keyset)
- `outputs["ALICE|BOB"]`: 100 sats total in blinded messages (conditional keyset for ALICE|BOB)
- `outputs["CAROL"]`: 100 sats total in blinded messages (conditional keyset for CAROL)

### Mint Behavior

When processing a split request, the mint:

1. Looks up the condition by `condition_id`
2. Returns error 13021 (Condition not found) if the condition is not registered
3. Validates that output keys form a valid partition (error 13037 if overlapping, error 13038 if incomplete)
4. Validates each `BlindedMessage` uses the correct conditional keyset ID
5. Validates input/output amounts are equal for each partition element
6. Signs the blinded messages using the outcome-collection-specific keyset keys

### Response Body

```json
{
  "signatures": {
    "<outcome_collection_1>": <Array[BlindSignature]>,
    "<outcome_collection_2>": <Array[BlindSignature]>,
    ...
  }
}
```

- `signatures`: Object mapping each outcome collection to an array of `BlindSignature` objects

Each `BlindSignature` corresponds to a `BlindedMessage` in the request, creating conditional tokens signed under the conditional keyset.

## Merge Operation

The merge operation allows users to combine a complete set of conditional tokens back into collateral. This is the inverse of split: for every unit of each conditional token surrendered, the user receives one unit of collateral.

The condition must have been registered via a prior condition registration ([NUT-28][28]). Use the `condition_id` from registration.

### Endpoint

```
POST /v1/ctf/merge
```

### Request Body

```json
{
  "condition_id": <hex_str>,
  "inputs": {
    "<outcome_collection_1>": <Array[Proof]>,
    "<outcome_collection_2>": <Array[Proof]>,
    ...
  },
  "outputs": <Array[BlindedMessage]>
}
```

- `condition_id`: The 32-byte condition identifier (64 hex characters). Must reference a registered condition. Returns error 13021 (Condition not found) if unknown.
- `inputs`: Object mapping each outcome collection to an array of `Proof` objects. Each `Proof` uses the **outcome-collection-specific keyset ID** for its outcome collection. Keys use pipe-separated notation for outcome collections.
- `outputs`: Array of `BlindedMessage` objects for the collateral to receive. For root conditions, these use a **regular keyset ID**. For nested conditions, these use the **parent outcome collection's keyset ID**.

### Input Requirements

1. The input keys MUST form a valid partition of all outcomes (see [Partition Rules][28])
2. Each input key's amount MUST be identical
3. Each `Proof` MUST use the keyset ID corresponding to its outcome collection
4. Fees are deducted from conditional inputs before producing collateral: `sum(outputs) = per_outcome_collection_amount - fees(all_inputs)`, where `fees(all_inputs)` is calculated per [NUT-02][02] from all input proofs across all outcome collections

For example, in a binary market with 100 sats of each conditional token:

- `inputs["YES"]`: 100 sats total (conditional keyset `00abc123def456`)
- `inputs["NO"]`: 100 sats total (conditional keyset `00def789abc012`)
- `outputs`: 100 sats total in blinded messages (regular keyset `009a1f293253e41e`)

With outcome collections in a 3-outcome condition:

- `inputs["ALICE|BOB"]`: 100 sats total (conditional keyset for ALICE|BOB)
- `inputs["CAROL"]`: 100 sats total (conditional keyset for CAROL)
- `outputs`: 100 sats total in blinded messages (regular keyset)

### Response Body

```json
{
  "signatures": <Array[BlindSignature]>
}
```

Each `BlindSignature` corresponds to a `BlindedMessage` in the request, creating regular (non-conditional) proofs.

### Merge Verification

The mint MUST verify:

1. All input proofs use valid conditional keysets for the specified condition
2. All outcome collections for the condition are present (complete partition)
3. All outcome collection amounts are equal
4. Output amount equals the per-outcome-collection input amount
5. No oracle witness is required -- the complete set cancels out all risk

## Trading

Conditional tokens can be transferred and traded using standard Cashu mechanisms. No special endpoint is needed.

## Redemption

Winners redeem their conditional tokens using the dedicated `POST /v1/redeem_outcome` endpoint ([NUT-28][28]) with oracle signatures in the witness. For root conditions, outputs use a regular keyset. For nested conditions, outputs use the parent outcome collection's keyset.

Wallets SHOULD remove conditional tokens for non-winning outcome collections from the user's balance after oracle attestation. These tokens cannot be redeemed and holding them may confuse the user.

## Combinatorial Markets

Combinatorial markets allow conditions to be nested hierarchically. For example, a user could bet on "Party A wins the election AND BTC price is above $100k" by splitting a "Party A" conditional token into sub-outcome-collections for BTC price.

Following the [Gnosis CTF](https://docs.gnosis.io/conditionaltokens/) design, combinatorial markets use **collection IDs** — points on the secp256k1 elliptic curve — to ensure order-independent nesting (commutativity). The key insight: `(A|B) & (LO)` must produce the same token regardless of whether you split Choice→Score or Score→Choice.

### Collection ID

A `collection_id` is an EC point on secp256k1 derived from a `condition_id` and an outcome collection. It represents a composite outcome selection. Encoded as a 32-byte x-only public key (64 hex chars).

#### Collection ID Computation

```
collection_id(parent_collection_id, condition_id, outcome_collection_string):
  1. h = tagged_hash("Cashu_collection_id", condition_id || outcome_collection_string_bytes)
  2. P = hash_to_curve(h)
  3. If parent_collection_id is the identity (32 zero bytes):
       Return x_only(P)
     Else:
       parent_point = lift_x(parent_collection_id)
       Return x_only(EC_add(parent_point, P))
```

Where:

- `outcome_collection_string_bytes`: The UTF-8 encoded outcome collection string (e.g., `"YES"` or `"ALICE|BOB"`)
- `tagged_hash(tag, msg) = SHA256(SHA256(tag) || SHA256(tag) || msg)` — BIP-340 tagged hash
- `hash_to_curve`: A deterministic method to map a 32-byte hash to a secp256k1 point, using the same approach as [NUT-00][00]'s `hash_to_curve` but with domain separation via the tagged hash input
- `EC_add`: Standard elliptic curve point addition on secp256k1
- `lift_x`: Recover a full EC point from an x-only public key per [BIP-340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)
- `x_only`: Extract the 32-byte x-coordinate from an EC point

#### Commutativity

Because EC point addition is commutative and associative:

```
collection_id(collection_id(0, condition_A, oc_A), condition_B, oc_B)
  = collection_id(collection_id(0, condition_B, oc_B), condition_A, oc_A)
```

This means `(Party_A) & (BTC_UP)` produces the same collection ID as `(BTC_UP) & (Party_A)`, regardless of nesting order.

### Split/Merge for Nested Markets

When `parent_collection_id` is non-zero:

- **Split inputs**: Instead of regular keyset tokens, inputs MUST use the conditional keyset identified by the parent collection's outcome collection
- **Merge outputs**: Instead of regular keyset tokens, outputs use the parent collection's conditional keyset
- **Redemption**: `POST /v1/redeem_outcome` outputs go to the parent collection's keyset instead of a regular keyset

### Combinatorial Market Example

Consider two markets:

1. **Election**: outcomes `["PARTY_A", "PARTY_B"]`
2. **BTC Price**: outcomes `["UP", "DOWN"]`

A user wants to bet on "Party A wins AND BTC goes up":

```
Step 1: Split 100 sat → PARTY_A (100 sat) + PARTY_B (100 sat)
        [root market, parent_collection_id = 0]

Step 2: Split PARTY_A (100 sat) → PARTY_A&UP (100 sat) + PARTY_A&DOWN (100 sat)
        [nested market, parent_collection_id = collection_id(0, election_condition_id, "PARTY_A")]
        [collateral = outcome_collection_id of PARTY_A in the election market]

Step 3: Sell PARTY_A&DOWN tokens, keep PARTY_A&UP tokens

Step 4a: Election oracle attests "PARTY_A" → redeem PARTY_A&UP to PARTY_A tokens
Step 4b: BTC oracle attests "UP" → redeem PARTY_A tokens to regular sat
```

The order of Steps 4a and 4b can be reversed because of collection ID commutativity.

## Error Codes

| Code  | Description                      |
| ----- | -------------------------------- |
| 13021 | Condition not found              |
| 13022 | Split amount mismatch            |
| 13024 | Condition not active             |
| 13025 | Merge amount mismatch            |
| 13037 | Overlapping outcome collections  |
| 13038 | Incomplete partition             |
| 13040 | Maximum condition depth exceeded |

## Complete Example

### Step 1: Register Condition

First, the condition must be registered via `POST /v1/conditions` ([NUT-28][28]):

**Request:**

```json
{
  "collateral": "sat",
  "threshold": 1,
  "description": "Will BTC reach $100k by June 2025?",
  "announcements": ["fdd824fd<...hex-encoded oracle_announcement TLV...>"]
}
```

**Response:**

```json
{
  "condition_id": "a1b2c3d4e5f67890...",
  "keysets": {
    "YES": "00abc123def456",
    "NO": "00def789abc012"
  }
}
```

The mint parses the announcement TLV, verifies the announcement signature, creates conditional keysets, and stores the condition configuration.

### Step 2: Split Collateral

Alice wants to participate with 100 sats. She uses the `condition_id` and conditional keyset IDs from registration:

**Request:**

```json
{
  "condition_id": "a1b2c3d4e5f67890...",
  "inputs": [
    {
      "amount": 64,
      "id": "009a1f293253e41e",
      "secret": "random_secret_1",
      "C": "02..."
    },
    {
      "amount": 32,
      "id": "009a1f293253e41e",
      "secret": "random_secret_2",
      "C": "02..."
    },
    {
      "amount": 4,
      "id": "009a1f293253e41e",
      "secret": "random_secret_3",
      "C": "02..."
    }
  ],
  "outputs": {
    "YES": [
      { "amount": 64, "id": "00abc123def456", "B_": "03..." },
      { "amount": 32, "id": "00abc123def456", "B_": "03..." },
      { "amount": 4, "id": "00abc123def456", "B_": "03..." }
    ],
    "NO": [
      { "amount": 64, "id": "00def789abc012", "B_": "03..." },
      { "amount": 32, "id": "00def789abc012", "B_": "03..." },
      { "amount": 4, "id": "00def789abc012", "B_": "03..." }
    ]
  }
}
```

**Response:**

```json
{
  "signatures": {
    "YES": [
      { "amount": 64, "id": "00abc123def456", "C_": "02..." },
      { "amount": 32, "id": "00abc123def456", "C_": "02..." },
      { "amount": 4, "id": "00abc123def456", "C_": "02..." }
    ],
    "NO": [
      { "amount": 64, "id": "00def789abc012", "C_": "02..." },
      { "amount": 32, "id": "00def789abc012", "C_": "02..." },
      { "amount": 4, "id": "00def789abc012", "C_": "02..." }
    ]
  }
}
```

Alice now holds:

- 100 sats worth of YES tokens (keyset `00abc123def456`)
- 100 sats worth of NO tokens (keyset `00def789abc012`)

### Step 3: Trading

Alice believes YES will win, so she sells her NO tokens to Bob for 40 sats. This is a normal Cashu token transfer -- Alice serializes the NO keyset proofs and sends them to Bob. Bob swaps at the mint:

```json
{
  "inputs": [
    {
      "amount": 64,
      "id": "00def789abc012",
      "secret": "bobs_received_secret_1",
      "C": "02..."
    },
    {
      "amount": 32,
      "id": "00def789abc012",
      "secret": "bobs_received_secret_2",
      "C": "02..."
    },
    {
      "amount": 4,
      "id": "00def789abc012",
      "secret": "bobs_received_secret_3",
      "C": "02..."
    }
  ],
  "outputs": [
    { "amount": 64, "id": "00def789abc012", "B_": "03..." },
    { "amount": 32, "id": "00def789abc012", "B_": "03..." },
    { "amount": 4, "id": "00def789abc012", "B_": "03..." }
  ]
}
```

All inputs and outputs use the NO conditional keyset (`00def789abc012`). No oracle witness is needed.

### Step 4: Oracle Attestation

On July 1, 2025, the oracle attests that YES won by publishing a signature:

```
outcome = "YES"
signature = Sign(sk, "YES", "attestation/v0")
```

### Step 5: Winner Redemption

Alice redeems her YES tokens via `POST /v1/redeem_outcome`:

```json
{
  "inputs": [
    {
      "amount": 64,
      "id": "00abc123def456",
      "secret": "alices_yes_secret_1",
      "C": "02...",
      "witness": "{\"oracle_sigs\":[{\"oracle_pubkey\":\"9be6fa256a022aafc98f24a71f0e37ab2ac6fe5b208a77a3d429b4b5c59f7ce0\",\"oracle_sig\":\"9a0b85c6e2d8f1234567890abcdef1234567890abcdef1234567890abcdef12349a0b85c6e2d8f1234567890abcdef1234567890abcdef1234567890abcdef1234\"}]}"
    },
    {
      "amount": 32,
      "id": "00abc123def456",
      "secret": "alices_yes_secret_2",
      "C": "02...",
      "witness": "{\"oracle_sigs\":[{\"oracle_pubkey\":\"9be6fa256a022aafc98f24a71f0e37ab2ac6fe5b208a77a3d429b4b5c59f7ce0\",\"oracle_sig\":\"9a0b85c6e2d8f1234567890abcdef1234567890abcdef1234567890abcdef12349a0b85c6e2d8f1234567890abcdef1234567890abcdef1234567890abcdef1234\"}]}"
    },
    {
      "amount": 4,
      "id": "00abc123def456",
      "secret": "alices_yes_secret_3",
      "C": "02...",
      "witness": "{\"oracle_sigs\":[{\"oracle_pubkey\":\"9be6fa256a022aafc98f24a71f0e37ab2ac6fe5b208a77a3d429b4b5c59f7ce0\",\"oracle_sig\":\"9a0b85c6e2d8f1234567890abcdef1234567890abcdef1234567890abcdef12349a0b85c6e2d8f1234567890abcdef1234567890abcdef1234567890abcdef1234\"}]}"
    }
  ],
  "outputs": [
    { "amount": 64, "id": "009a1f293253e41e", "B_": "03..." },
    { "amount": 32, "id": "009a1f293253e41e", "B_": "03..." },
    { "amount": 4, "id": "009a1f293253e41e", "B_": "03..." }
  ]
}
```

This request is sent to `POST /v1/redeem_outcome`. Inputs use the YES conditional keyset (`00abc123def456`) with `oracle_sigs` witness. Outputs use the regular keyset (`009a1f293253e41e`). The mint verifies the oracle signatures per [NUT-28][28] and returns regular proofs.

## Security Considerations

### Collateral Safety

The mint holds all collateral. The total value of all conditional tokens for a condition equals the collateral deposited. When the oracle attests:

- Winning conditional tokens can be redeemed for collateral
- Losing conditional tokens become worthless (cannot be redeemed)

### Market Integrity

1. **Complete Sets**: Split always creates ALL outcome collections, preventing partial collateralization
2. **Equal Amounts**: Each outcome collection receives equal token amounts
3. **Oracle Independence**: The mint does not determine outcomes; the oracle does
4. **Keyset Isolation**: Each outcome collection has a unique keyset, preventing token type confusion

### Trust Model

This specification inherits Cashu's trust model:

- Users trust the mint to honor redemptions
- Users trust the oracle to attest honestly
- The mint does not need to trust users (cryptographic verification)
- **The mint does not need to trust the oracle** - Whether using AMM-style or CTF-style prediction markets, the mint has no counterparty risk from oracle outcomes. The mint's collateral is always matched by outstanding conditional tokens. Risk of deceptive oracles lies entirely with the users who must verify oracle reputation before participating.

### Combinatorial Market Depth

Mints MAY impose a maximum nesting depth to prevent complexity explosion. The maximum depth SHOULD be communicated via the [Mint Info Setting](#mint-info-setting). Wallets SHOULD check the mint's maximum depth before attempting to register nested conditions.

## Q&A: Design Decisions

### When should users merge vs. wait for resolution?

Merge is useful when:

- A user holds a complete set and wants to exit their position before oracle attestation
- Market conditions change and the user wants to recover collateral immediately
- Arbitrage opportunities exist between the market price and collateral value

Waiting for resolution is simpler when:

- The user expects one outcome to win and wants to maximize profit
- Transaction fees make merge uneconomical

## Mint Info Setting

The [NUT-06][06] `MintMethodSetting` indicates support for this feature:

```json
{
  "29": {
    "supported": true,
    "max_depth": <int>
  }
}
```

- `supported`: Boolean indicating NUT-29 support
- `max_depth` (optional): Maximum nesting depth for combinatorial markets. If not specified, only root conditions (depth 1) are supported.

[00]: 00.md
[01]: 01.md
[02]: 02.md
[03]: 03.md
[04]: 04.md
[05]: 05.md
[06]: 06.md
[07]: 07.md
[08]: 08.md
[09]: 09.md
[10]: 10.md
[11]: 11.md
[12]: 12.md
[14]: 14.md
[21]: 21.md
[22]: 22.md
[28]: 28.md
[30]: 30.md
