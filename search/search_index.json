{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cashu NUTs (Notation, Usage, and Terminology)","text":"<p>These documents each specify parts of the Cashu protocol. Read the specifications for the legacy API here.</p>"},{"location":"#specifications","title":"Specifications","text":"<p>Wallets and mints <code>MUST</code> implement all mandatory specs and <code>CAN</code> implement optional specs.</p>"},{"location":"#mandatory","title":"Mandatory","text":"NUT # Description 00 Cryptography and Models 01 Mint public keys 02 Keysets and fees 03 Swapping tokens 04 Minting tokens 05 Melting tokens 06 Mint info"},{"location":"#optional","title":"Optional","text":"# Description Wallets Mints 07 Token state check Nutshell, Moksha, Nutstash, cashu-ts, cdk-cli Nutshell, Moksha, cdk-mintd, nutmix 08 Overpaid Lightning fees Nutshell, Moksha, Nutstash, cashu-ts, cdk-cli Nutshell, Moksha, cdk-mintd, nutmix 09 Signature restore Nutshell, cdk-cli, cashu-ts, gonuts Nutshell, cdk-mintd, nutmix 10 Spending conditions Nutshell, cdk-cli, cashu-ts Nutshell, cdk-mintd, nutmix 11 Pay-To-Pubkey (P2PK) Nutshell, cdk-cli, cashu-ts Nutshell, cdk-mintd, nutmix 12 DLEQ proofs Nutshell, cdk-cli Nutshell, cdk-mintd, nutmix 13 Deterministic secrets Nutshell, Moksha, cashu-ts, cdk-cli, gonuts - 14 Hashed Timelock Contracts (HTLCs) Nutshell, cdk-cli Nutshell, cdk-mintd, nutmix 15 Partial multi-path payments (MPP) Nutshell Nutshell 16 Animated QR codes Cashu.me - 17 WebSocket subscriptions Nutshell, cdk-cli Nutshell, cdk-mintd 18 Payment requests Cashu.me, Boardwalk, cdk-cli - 19 Cached Responses - Nutshell, cdk-mintd 20 Signature on Mint Quote cdk-cli, Nutshell cdk-mintd,Nutshell 21 Clear authentication cdk-cli, Nutshell cdk-mintd,Nutshell 22 Blind authentication cdk-cli, Nutshell cdk-mintd,Nutshell"},{"location":"#wallets","title":"Wallets:","text":"<ul> <li>Nutshell</li> <li>cdk-cli</li> <li>cashu-ts</li> <li>eNuts</li> <li>Minibits</li> <li>Moksha</li> <li>Nutstash</li> <li>Cashu.me</li> <li>Gonuts</li> <li>Boardwalk</li> </ul>"},{"location":"#mints","title":"Mints:","text":"<ul> <li>Nutshell</li> <li>Gonuts</li> <li>Moksha</li> <li>cdk-mintd</li> <li>Nutmix</li> </ul>"},{"location":"00/","title":"NUT-00: Notation, Utilization, and Terminology","text":"<p><code>mandatory</code></p> <p>This document details the notation and models used throughout the specification and lays the groundwork for understanding the basic cryptography used in the Cashu protocol.</p> <ul> <li>Sending user: <code>Alice</code></li> <li>Receiving user: <code>Carol</code></li> <li>Mint: <code>Bob</code></li> </ul>"},{"location":"00/#blind-diffie-hellmann-key-exchange-bdhke","title":"Blind Diffie-Hellmann key exchange (BDHKE)","text":""},{"location":"00/#variables","title":"Variables","text":"<ul> <li><code>G</code> elliptic curve generator point</li> </ul>"},{"location":"00/#bob-mint","title":"Bob (mint)","text":"<ul> <li><code>k</code> private key of mint (one for each amount)</li> <li><code>K</code> public key corresponding to <code>k</code></li> <li><code>C_</code> blind signature (on <code>B_</code>)</li> </ul>"},{"location":"00/#alice-user","title":"Alice (user)","text":"<ul> <li><code>x</code> UTF-8-encoded random string (secret message), corresponds to point <code>Y = hash_to_curve(x)</code> on curve</li> <li><code>r</code> blinding factor</li> <li><code>B_</code> blinded message</li> <li><code>C</code> unblinded signature</li> </ul>"},{"location":"00/#hash_to_curvex-bytes-curve-point-y","title":"<code>hash_to_curve(x: bytes) -&gt; curve point Y</code>","text":"<p>Deterministically maps a message to a public key point on the secp256k1 curve, utilizing a domain separator to ensure uniqueness.</p> <p><code>Y = PublicKey('02' || SHA256(msg_hash || counter))</code> where <code>msg_hash</code> is <code>SHA256(DOMAIN_SEPARATOR || x)</code></p> <ul> <li><code>Y</code> derived public key</li> <li><code>DOMAIN_SEPARATOR</code> constant byte string <code>b\"Secp256k1_HashToCurve_Cashu_\"</code></li> <li><code>x</code> message to hash</li> <li><code>counter</code> uint32 counter(byte order little endian) incremented from 0 until a point is found that lies on the curve</li> </ul>"},{"location":"00/#protocol","title":"Protocol","text":"<ul> <li>Mint <code>Bob</code> publishes public key <code>K = kG</code></li> <li><code>Alice</code> picks secret <code>x</code> and computes <code>Y = hash_to_curve(x)</code></li> <li><code>Alice</code> sends to <code>Bob</code>: <code>B_ = Y + rG</code> with <code>r</code> being a random blinding factor (blinding)</li> <li><code>Bob</code> sends back to <code>Alice</code> blinded key: <code>C_ = kB_</code> (these two steps are the DH key exchange) (signing)</li> <li><code>Alice</code> can calculate the unblinded key as <code>C_ - rK = kY + krG - krG = kY = C</code> (unblinding)</li> <li>Alice can take the pair <code>(x, C)</code> as a token and can send it to <code>Carol</code>.</li> <li><code>Carol</code> can send <code>(x, C)</code> to <code>Bob</code> who then checks that <code>k*hash_to_curve(x) == C</code> (verification), and if so treats it as a valid spend of a token, adding <code>x</code> to the list of spent secrets.</li> </ul>"},{"location":"00/#01-models","title":"0.1 - Models","text":""},{"location":"00/#blindedmessage","title":"<code>BlindedMessage</code>","text":"<p>An encrypted (\"blinded\") secret and an amount is sent from <code>Alice</code> to <code>Bob</code> for minting tokens or for swapping tokens. A <code>BlindedMessage</code> is also called an output.</p> <pre><code>{\n  \"amount\": int,\n  \"id\": hex_str,\n  \"B_\": hex_str\n}\n</code></pre> <p><code>amount</code> is the value for the requested <code>BlindSignature</code>, <code>id</code> is the requested keyset ID from which we expect a signature, and <code>B_</code> is the blinded secret message generated by <code>Alice</code>. An array <code>[BlindedMessage]</code> is also referred to as <code>BlindedMessages</code>.</p>"},{"location":"00/#blindsignature","title":"<code>BlindSignature</code>","text":"<p>A <code>BlindSignature</code> is sent from <code>Bob</code> to <code>Alice</code> after minting tokens or after swapping tokens. A <code>BlindSignature</code> is also called a promise.</p> <pre><code>{\n  \"amount\": int,\n  \"id\": hex_str,\n  \"C_\": hex_str\n}\n</code></pre> <p><code>amount</code> is the value of the blinded token, <code>id</code> is the keyset id of the mint keys that signed the token, and <code>C_</code> is the blinded signature on the secret message <code>B_</code> sent in the previous step.</p>"},{"location":"00/#proof","title":"<code>Proof</code>","text":"<p>A <code>Proof</code> is also called an input and is generated by <code>Alice</code> from a <code>BlindSignature</code> it received. An array <code>[Proof]</code> is called <code>Proofs</code>. <code>Alice</code> sends <code>Proofs</code> to <code>Bob</code> for melting tokens. Serialized <code>Proofs</code> can also be sent from <code>Alice</code> to <code>Carol</code>. Upon receiving the token, <code>Carol</code> deserializes it and requests a swap from <code>Bob</code> to receive new <code>Proofs</code>.</p> <pre><code>{\n  \"amount\": int,\n  \"id\": hex_str,\n  \"secret\": str,\n  \"C\": hex_str,\n}\n</code></pre> <p><code>amount</code> is the amount of the <code>Proof</code>, <code>secret</code> is the secret message and is a utf-8 encoded string (the use of a 64 character hex string generated from 32 random bytes is recommended to prevent fingerprinting), <code>C</code> is the unblinded signature on <code>secret</code> (hex string), <code>id</code> is the keyset id of the mint public keys that signed the token (hex string).</p>"},{"location":"00/#02-protocol","title":"0.2 - Protocol","text":""},{"location":"00/#errors","title":"Errors","text":"<p>In case of an error, mints respond with the HTTP status code <code>400</code> and include the following data in their response:</p> <pre><code>{\n  \"detail\": \"oops\",\n  \"code\": 1337\n}\n</code></pre> <p>Here, <code>detail</code> is the error message, and <code>code</code> is the error code. Error codes are to be defined in the documents concerning the use of a certain API endpoint.</p>"},{"location":"00/#03-methods","title":"0.3 - Methods","text":""},{"location":"00/#serialization-of-tokens","title":"Serialization of tokens","text":"<p>Tokens can be serialized to send them between users <code>Alice</code> and <code>Carol</code>. Serialized tokens have a Cashu token prefix, a versioning flag, and the token. Optionally, a URI prefix for making tokens clickable on the web.</p> <p>We use the following format for token serialization:</p> <pre><code>cashu[version][token]\n</code></pre> <p><code>cashu</code> is the Cashu token prefix. <code>[version]</code> is a single <code>base64_urlsafe</code> character to denote the token format version.</p>"},{"location":"00/#uri-tags","title":"URI tags","text":"<p>To make Cashu tokens clickable on the web, we use the URI scheme <code>cashu:</code>. An example of a serialized token with URI tag is</p> <pre><code>cashu:cashuAeyJwcm9vZn...\n</code></pre>"},{"location":"00/#v3-tokens","title":"V3 tokens","text":"<p>V3 tokens are deprecated and the use of the more space-efficient V4 tokens is encouraged.</p>"},{"location":"00/#version","title":"Version","text":"<p>This token format has the <code>[version]</code> value <code>A</code>.</p>"},{"location":"00/#format","title":"Format","text":"<p>V3 tokens are base64-encoded JSON objects. The token format supports tokens from multiple mints. The JSON is serialized with a <code>base64_urlsafe</code> (base64 encoding with <code>/</code> replaced by <code>_</code> and <code>+</code> by <code>-</code>). <code>base64_urlsafe</code> strings may have padding characters (usually <code>=</code>) at the end which can be omitted. Clients need to be able to decode both cases.</p> <pre><code>cashuA[base64_token_json]\n</code></pre> <p><code>[base64_token_json]</code> is the token JSON serialized in <code>base64_urlsafe</code>. <code>[base64_token_json]</code> should be cleared of any whitespace before serializing.</p>"},{"location":"00/#token-format","title":"Token format","text":"<p>The deserialized <code>base64_token_json</code> is</p> <pre><code>{\n  \"token\": [\n    {\n      \"mint\": str,\n      \"proofs\": Proofs\n    },\n    ...\n  ],\n  \"unit\": str &lt;optional&gt;,\n  \"memo\": str &lt;optional&gt;\n}\n</code></pre> <p><code>mint</code> is the mint URL. The mint URL must be stripped of any trailing slashes (<code>/</code>). <code>Proofs</code> is an array of <code>Proof</code> objects. The next two elements are only for displaying the receiving user appropriate information: <code>unit</code> is the currency unit of the token keysets (see Keysets for supported units), and <code>memo</code> is an optional text memo from the sender.</p>"},{"location":"00/#example","title":"Example","text":"<p>Below is a TokenV3 JSON before <code>base64_urlsafe</code> serialization.</p> <pre><code>{\n  \"token\": [\n    {\n      \"mint\": \"https://8333.space:3338\",\n      \"proofs\": [\n        {\n          \"amount\": 2,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n          \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n        },\n        {\n          \"amount\": 8,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be\",\n          \"C\": \"029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059\"\n        }\n      ]\n    }\n  ],\n  \"unit\": \"sat\",\n  \"memo\": \"Thank you.\"\n}\n</code></pre> <p>When serialized, this becomes:</p> <pre><code>cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre>"},{"location":"00/#v4-tokens","title":"V4 tokens","text":"<p>V4 tokens are a space-efficient way of serializing tokens using the CBOR binary format. All field are single characters and hex strings are encoded in binary. V4 tokens can only hold proofs from a single mint.</p>"},{"location":"00/#version_1","title":"Version","text":"<p>This token format has the <code>[version]</code> value <code>B</code>.</p>"},{"location":"00/#format_1","title":"Format","text":"<p>Wallets serialize tokens in a <code>base64_urlsafe</code> format (base64 encoding with <code>/</code> replaced by <code>_</code> and <code>+</code> by <code>-</code>). <code>base64_urlsafe</code> strings may have padding characters (usually <code>=</code>) at the end which can be omitted. Clients need to be able to decode both cases.</p> <pre><code>cashuB[base64_token_cbor]\n</code></pre>"},{"location":"00/#token-format_1","title":"Token format","text":"<p>The deserialized <code>base64_token_cbor</code> is a JSON of the same form as a TokenV4 but with shorter keys and data represented as binary data (<code>bytes</code>) instead of hex strings (<code>hex_str</code>). Note that we have expanded what is called <code>Proofs</code> in TokenV3 (called <code>p</code> here with TokenV4) showing that its values are also different from the TokenV3 serialization.</p> <pre><code>{\n  \"m\": str, // mint URL\n  \"u\": str, // unit\n  \"d\": str &lt;optional&gt;, // memo\n  \"t\": [\n    {\n      \"i\": bytes, // keyset ID\n      \"p\": [ // proofs with this keyset ID\n        {\n          \"a\": int, // amount\n          \"s\": str, // secret\n          \"c\": bytes, // signature\n          \"d\": { &lt;optional&gt; // DLEQ proof\n            \"e\": bytes,\n            \"s\": bytes,\n            \"r\": bytes\n          },\n          \"w\": str &lt;optional&gt; // witness\n        },\n        ...\n      ]\n    },\n    ...\n  ],\n}\n</code></pre> <p><code>m</code> is the mint URL. The mint URL must be stripped of any trailing slashes (<code>/</code>). <code>u</code> is the currency unit of the token keysets (see Keysets for supported units), and <code>d</code> is an optional text memo from the sender.</p> <p><code>i</code> is the keyset ID of the proofs in <code>p</code>, which is an array of <code>Proof</code> objects without the <code>id</code> field. We extracted the keyset ID <code>id</code> from each proof and grouped all proofs by their keyset ID <code>i</code> one level above (in <code>p</code>).</p> <p>Note that all fields of the <code>bytes</code> type encode hex strings in the original representation of <code>Proof</code>'s.</p>"},{"location":"00/#example_1","title":"Example","text":"<p>Below is a TokenV4 JSON before CBOR and <code>base64_urlsafe</code> serialization.</p> <pre><code>{\n    \"t\": [\n        {\n            \"i\": h'00ffd48b8f5ecf80',\n            \"p\": [\n                {\n                    \"a\": 1,\n                    \"s\": \"acc12435e7b8484c3cf1850149218af90f716a52bf4a5ed347e48ecc13f77388\",\n                    \"c\": h'0244538319de485d55bed3b29a642bee5879375ab9e7a620e11e48ba482421f3cf',\n                },\n            ],\n        },\n        {\n            \"i\": h'00ad268c4d1f5826',\n            \"p\": [\n                {\n                    \"a\": 2,\n                    \"s\": \"1323d3d4707a58ad2e23ada4e9f1f49f5a5b4ac7b708eb0d61f738f48307e8ee\",\n                    \"c\": h'023456aa110d84b4ac747aebd82c3b005aca50bf457ebd5737a4414fac3ae7d94d',\n                },\n                {\n                    \"a\": 1,\n                    \"s\": \"56bcbcbb7cc6406b3fa5d57d2174f4eff8b4402b176926d3a57d3c3dcbb59d57\",\n                    \"c\": h'0273129c5719e599379a974a626363c333c56cafc0e6d01abe46d5808280789c63',\n                },\n            ],\n        },\n    ],\n    \"m\": \"http://localhost:3338\",\n    \"u\": \"sat\",\n}\n</code></pre> <p>The <code>h''</code> values are <code>bytes</code> but displayed as hex strings here.</p> <p>We serialize this JSON using CBOR which can be seen here. The resulting bytes are then serialized to a string using <code>base64_urlsafe</code> and the prefix <code>cashuB</code> is added. This leaves us with the following serialized TokenV4:</p> <pre><code>cashuBo2F0gqJhaUgA_9SLj17PgGFwgaNhYQFhc3hAYWNjMTI0MzVlN2I4NDg0YzNjZjE4NTAxNDkyMThhZjkwZjcxNmE1MmJmNGE1ZWQzNDdlNDhlY2MxM2Y3NzM4OGFjWCECRFODGd5IXVW-07KaZCvuWHk3WrnnpiDhHki6SCQh88-iYWlIAK0mjE0fWCZhcIKjYWECYXN4QDEzMjNkM2Q0NzA3YTU4YWQyZTIzYWRhNGU5ZjFmNDlmNWE1YjRhYzdiNzA4ZWIwZDYxZjczOGY0ODMwN2U4ZWVhY1ghAjRWqhENhLSsdHrr2Cw7AFrKUL9Ffr1XN6RBT6w659lNo2FhAWFzeEA1NmJjYmNiYjdjYzY0MDZiM2ZhNWQ1N2QyMTc0ZjRlZmY4YjQ0MDJiMTc2OTI2ZDNhNTdkM2MzZGNiYjU5ZDU3YWNYIQJzEpxXGeWZN5qXSmJjY8MzxWyvwObQGr5G1YCCgHicY2FtdWh0dHA6Ly9sb2NhbGhvc3Q6MzMzOGF1Y3NhdA\n</code></pre>"},{"location":"00/#binary-token","title":"Binary Token","text":"<p>Token can be transmitted in a binary format when applicable (for example when transmitting via NFC). For this the serialised token is prepended with a prefix and a version byte.</p> <pre><code>utf8(\"craw\") || utf8(&lt;token_version&gt;) || &lt;serialised_token&gt;\n</code></pre> <ul> <li>Binary Encoding V4: <code>utf8(\"craw\") || utf8(\"B\") || cbor(token_v4_object)</code></li> </ul>"},{"location":"01/","title":"NUT-01: Mint public key exchange","text":"<p><code>mandatory</code></p> <p>This document outlines the exchange of the public keys of the mint <code>Bob</code> with the wallet user <code>Alice</code>. <code>Alice</code> uses the keys to unblind <code>Bob</code>'s blind signatures (see NUT-00).</p>"},{"location":"01/#description","title":"Description","text":"<p>Wallet user <code>Alice</code> receives public keys from mint <code>Bob</code> via <code>GET /v1/keys</code>. The set of all public keys for a set of amounts is called a keyset.</p> <p>The mint responds only with its <code>active</code> keysets. Keyset are <code>active</code> if the mint will sign outputs with it. The mint will accept tokens from inactive keysets as inputs but will not sign with them for new outputs. The <code>active</code> keysets can change over time, for example due to key rotation. A list of all keysets, active and inactive, can be requested separately (see NUT-02).</p> <p>Note that a mint can support multiple keysets at the same time but will only respond with the active keysets on the endpoint <code>GET /v1/keys</code>. A wallet can ask for the keys of a specific (active or inactive) keyset via the endpoint <code>GET /v1/keys/{keyset_id}</code> (see NUT-02).</p>"},{"location":"01/#keyset-generation","title":"Keyset generation","text":"<p>Keysets are generated by the mint. The mint is free to use any key generation method they like. Each keyset is identified by its keyset <code>id</code> which can be computed by anyone from its public keys (see NUT-02).</p> <p>Keys in Keysets are maps of the form <code>{&lt;amount_1&gt; : &lt;mint_pubkey_1&gt;, &lt;amount_2&gt; : &lt;mint_pubkey_2&gt;, ...}</code> for each <code>&lt;amount_i&gt;</code> of the amounts the mint <code>Bob</code> supports and the corresponding public key <code>&lt;mint_pubkey_1&gt;</code>, that is <code>K_i</code> (see NUT-00). The mint MUST use the compressed Secp256k1 public key format to represent its public keys.</p>"},{"location":"01/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>GET https://mint.host:3338/v1/keys\n</code></pre> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/keys\n</code></pre> <p>Response <code>GetKeysResponse</code> of <code>Bob</code>:</p> <pre><code>{\n  \"keysets\": [\n    {\n      \"id\": &lt;keyset_id_hex_str&gt;,\n      \"unit\": &lt;currency_unit_str&gt;,\n      \"keys\": {\n        &lt;amount_int&gt;: &lt;public_key_str&gt;,\n        ...\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"01/#example-response","title":"Example response","text":"<pre><code>{\n  \"keysets\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"unit\": \"sat\",\n      \"keys\": {\n          \"1\": \"02194603ffa36356f4a56b7df9371fc3192472351453ec7398b8da8117e7c3e104\",\n          \"2\": \"03b0f36d6d47ce14df8a7be9137712c42bcdd960b19dd02f1d4a9703b1f31d7513\",\n          \"4\": \"0366be6e026e42852498efb82014ca91e89da2e7a5bd3761bdad699fa2aec9fe09\",\n          \"8\": \"0253de5237f189606f29d8a690ea719f74d65f617bb1cb6fbea34f2bc4f930016d\",\n          ...\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"02/","title":"NUT-02: Keysets and fees","text":"<p><code>mandatory</code></p> <p>A keyset is a set of public keys that the mint <code>Bob</code> generates and shares with its users. It refers to the set of public keys that each correspond to the amount values that the mint supports (e.g. <code>1, 2, 4, 8, ...</code>) respectively.</p> <p>Each keyset indicates its keyset <code>id</code>, the currency <code>unit</code>, whether the keyset is <code>active</code>, and an <code>input_fee_ppk</code> that determines the fees for spending ecash from this keyset.</p> <p>A mint can have multiple keysets at the same time. For example, it could have one keyset for each currency <code>unit</code> that it supports. Wallets should support multiple keysets. They must respect the <code>active</code> and the <code>input_fee_ppk</code> properties of the keysets they use.</p>"},{"location":"02/#keyset-properties","title":"Keyset properties","text":""},{"location":"02/#keyset-id","title":"Keyset ID","text":"<p>A keyset <code>id</code> is an identifier for a specific keyset. It can be derived by anyone who knows the set of public keys of a mint. Wallets CAN compute the keyset <code>id</code> for a given keyset by themselves to confirm that the mint is supplying the correct keyset ID (see below).</p> <p>The keyset <code>id</code> is in each <code>Proof</code> so it can be used by wallets to identify which mint and keyset it was generated from. The keyset field <code>id</code> is also present in the <code>BlindedMessages</code> sent to the mint and <code>BlindSignatures</code> returned from the mint (see NUT-00).</p>"},{"location":"02/#active-keysets","title":"Active keysets","text":"<p>Mints can have multiple keysets at the same time but MUST have at least one <code>active</code> keyset (see NUT-01). The <code>active</code> property determines whether the mint allows generating new ecash from this keyset. <code>Proofs</code> from inactive keysets with <code>active=false</code> are still accepted as inputs but new outputs (<code>BlindedMessages</code> and <code>BlindSignatures</code>) MUST be from <code>active</code> keysets only.</p> <p>To rotate keysets, a mint can generate a new active keyset and inactive an old one. If the <code>active</code> flag of an old keyset is set to <code>false</code>, no new ecash from this keyset can be generated and the outstanding ecash supply of that keyset can be taken out of circulation as wallets rotate their ecash to active keysets.</p> <p>Wallets SHOULD prioritize swaps with <code>Proofs</code> from inactive keysets (see NUT-03) so they can quickly get rid of them. Wallets CAN swap their entire balance from an inactive keyset to an active one as soon as they detect that the keyset was inactivated. When constructing outputs for a transaction, wallets MUST choose only <code>active</code> keysets (see NUT-00).</p>"},{"location":"02/#fees","title":"Fees","text":"<p>Keysets indicate the fee <code>input_fee_ppk</code> that is charged when a <code>Proof</code> of that keyset is spent as an input to a transaction. The fee is given in parts per thousand (ppk) per input measured in the <code>unit</code> of the keyset. The total fee for a transaction is the sum of all fees per input rounded up to the next larger integer (that that can be represented with the keyest).</p> <p>As an example, we construct a transaction spending 3 inputs (<code>Proofs</code>) from a keyset with unit <code>sat</code> and <code>input_fee_ppk</code> of <code>100</code>. A fee of <code>100 ppk</code> means <code>0.1 sat</code> per input. The sum of the individual fees are 300 ppk for this transaction. Rounded up to the next smallest denomination, the mint charges <code>1 sat</code> in total fees, i.e. <code>fees = ceil(0.3) == 1</code>. In this case, the fees for spending 1-10 inputs is 1 sat, 11-20 inputs is 2 sat and so on.</p>"},{"location":"02/#wallet-transaction-construction","title":"Wallet transaction construction","text":"<p>When constructing a transaction with ecash <code>inputs</code> (example: <code>/v1/swap</code> or <code>/v1/melt</code>), wallets MUST add fees to the inputs or, vice versa, subtract from the outputs. The mint checks the following equation:</p> <pre><code>sum(inputs) - fees == sum(outputs)\n</code></pre> <p>Here, <code>sum(inputs)</code> and <code>sum(outputs)</code> mean the sum of the amounts of the inputs and outputs respectively. <code>fees</code> is calculated from the sum of each input's fee and rounded up to the next larger integer:</p> <pre><code>def fees(inputs: List[Proof]) -&gt; int:\n  sum_fees = 0\n  for proof in inputs:\n    sum_fees += keysets[proof.id].input_fee_ppk\n  return (sum_fees + 999) // 1000\n</code></pre> <p>Here, the <code>//</code> operator in <code>(sum_fees + 999) // 1000</code> denotes an integer division operator (aka floor division operator) that rounds down <code>sum_fees + 999</code> to the next lower integer. Alternatively, we could round up the sum using a floating point division with <code>ceil(sum_fees / 1000)</code> although it is not recommended to do so due to the non-deterministic behavior of floating point division.</p> <p>Notice that since transactions can spend inputs from different keysets, the sum considers the fee for each <code>Proof</code> indexed by the keyset ID individually.</p>"},{"location":"02/#deriving-the-keyset-id","title":"Deriving the keyset ID","text":""},{"location":"02/#keyset-id-version","title":"Keyset ID version","text":"<p>Keyset IDs have a version byte (two hexadecimal characters). The currently used version byte is <code>00</code>.</p> <p>The mint and the wallets of its users can derive a keyset ID from the keyset of the mint. The keyset ID is a lower-case hex string. To derive the keyset ID of a keyset, execute the following steps:</p> <pre><code>1 - sort public keys by their amount in ascending order\n2 - concatenate all public keys to one byte array\n3 - HASH_SHA256 the concatenated public keys\n4 - take the first 14 characters of the hex-encoded hash\n5 - prefix it with a keyset ID version byte\n</code></pre> <p>An example implementation in Python:</p> <pre><code>def derive_keyset_id(keys: Dict[int, PublicKey]) -&gt; str:\n    sorted_keys = dict(sorted(keys.items()))\n    pubkeys_concat = b\"\".join([p.serialize() for p in sorted_keys.values()])\n    return \"00\" + hashlib.sha256(pubkeys_concat).hexdigest()[:14]\n</code></pre>"},{"location":"02/#example-get-mint-keysets","title":"Example: Get mint keysets","text":"<p>A wallet can ask the mint for a list of all keysets via the <code>GET /v1/keysets</code> endpoint.</p> <p>Request of <code>Alice</code>:</p> <pre><code>GET https://mint.host:3338/v1/keysets\n</code></pre> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/keysets\n</code></pre> <p>Response <code>GetKeysetsResponse</code> of <code>Bob</code>:</p> <pre><code>{\n  \"keysets\": [\n    {\n      \"id\": &lt;hex_str&gt;,\n      \"unit\": &lt;str&gt;,\n      \"active\": &lt;bool&gt;,\n      \"input_fee_ppk\": &lt;int|null&gt;,\n    },\n    ...\n  ]\n}\n</code></pre> <p>Here, <code>id</code> is the keyset ID, <code>unit</code> is the unit string (e.g. \"sat\") of the keyset, <code>active</code> indicates whether new ecash can be minted with this keyset, and <code>input_fee_ppk</code> is the fee (per thousand units) to spend one input spent from this keyset. If <code>input_fee_ppk</code> is not given, we assume it to be <code>0</code>.</p>"},{"location":"02/#example-response","title":"Example response","text":"<pre><code>{\n  \"keysets\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"unit\": \"sat\",\n      \"active\": True,\n      \"input_fee_ppk\": 100\n    },\n    {\n      \"id\": \"0042ade98b2a370a\",\n      \"unit\": \"sat\",\n      \"active\": False,\n      \"input_fee_ppk\": 100\n    },\n    {\n      \"id\": \"00c074b96c7e2b0e\",\n      \"unit\": \"usd\",\n      \"active\": True,\n      \"input_fee_ppk\": 100\n    }\n  ]\n}\n</code></pre>"},{"location":"02/#requesting-public-keys-for-a-specific-keyset","title":"Requesting public keys for a specific keyset","text":"<p>To receive the public keys of a specific keyset, a wallet can call the <code>GET /v1/keys/{keyset_id}</code> endpoint where <code>keyset_id</code> is the keyset ID.</p>"},{"location":"02/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <p>We request the keys for the keyset <code>009a1f293253e41e</code>.</p> <pre><code>GET https://mint.host:3338/v1/keys/009a1f293253e41e\n</code></pre> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/keys/009a1f293253e41e\n</code></pre> <p>Response of <code>Bob</code> (same as NUT-01):</p> <pre><code>{\n  \"keysets\": [{\n    \"id\": \"009a1f293253e41e\",\n    \"unit\": \"sat\",\n    \"keys\": {\n        \"1\": \"02194603ffa36356f4a56b7df9371fc3192472351453ec7398b8da8117e7c3e104\",\n        \"2\": \"03b0f36d6d47ce14df8a7be9137712c42bcdd960b19dd02f1d4a9703b1f31d7513\",\n        \"4\": \"0366be6e026e42852498efb82014ca91e89da2e7a5bd3761bdad699fa2aec9fe09\",\n        \"8\": \"0253de5237f189606f29d8a690ea719f74d65f617bb1cb6fbea34f2bc4f930016d\",\n        ...\n    },\n  }, ...\n  ]\n}\n</code></pre>"},{"location":"02/#wallet-implementation-notes","title":"Wallet implementation notes","text":"<p>Wallets can request the list of keyset IDs from the mint upon startup and load only tokens from its database that have a keyset ID supported by the mint it interacts with. This also helps wallets to determine whether the mint has added a new current keyset or whether it has changed the <code>active</code> flag of an existing one.</p> <p>A useful flow is:</p> <ul> <li>If we don't have any keys from this mint yet, get all keys: <code>GET /v1/keys</code> and store them</li> <li>Get all keysets with <code>GET /v1/keysets</code></li> <li>For all new keyset returned here which we don't have yet, get it using <code>GET /v1/keys/{keyset_id}</code> and store it</li> <li>If any of the keysets has changed its <code>active</code> flag, update it in the db and use the keyset accordingly</li> </ul>"},{"location":"03/","title":"NUT-03: Swap tokens","text":"<p><code>mandatory</code></p> <p>The swap operation is the most important component of the Cashu system. A swap operation consists of multiple inputs (<code>Proofs</code>) and outputs (<code>BlindedMessages</code>). Mints verify and invalidate the inputs and issue new promises (<code>BlindSignatures</code>). These are then used by the wallet to generate new <code>Proofs</code> (see NUT-00).</p> <p>The swap operation can serve multiple use cases. The first use case is that <code>Alice</code> can use it to split her tokens to a target amount she needs to send to <code>Carol</code>, if she does not have the necessary amounts to compose the target amount in her wallet already. The second one is that <code>Carols</code>'s wallet can use it to receive tokens from <code>Alice</code> by sending them as inputs to the mint and receive new outputs in return.</p>"},{"location":"03/#swap-to-send","title":"Swap to send","text":"<p>To make this more clear, we present an example of a typical case of sending tokens from <code>Alice</code> to <code>Carol</code>.</p> <p><code>Alice</code> has 64 sat in her wallet, composed of three <code>Proofs</code>, one worth 32 sat and another two worth 16 sat. She wants to send <code>Carol</code> 40 sat but does not have the necessary <code>Proofs</code> to compose the target amount of 40 sat. For that, <code>Alice</code> requests a swap from the mint and uses <code>Proofs</code> worth <code>[16, 16, 32]</code> as inputs and asks for new outputs worth <code>[8, 32, 8, 16]</code> totalling 64 sat. Notice that the first two tokens can now be combined to 40 sat. The <code>Proofs</code> that <code>Alice</code> sent <code>Bob</code> as inputs of the swap operation are now invalidated.</p> <p>Note: In order to preserve privacy around the amount that a client might want to send to another user and keep the rest as change, the client SHOULD ensure that the list requested outputs is ordered by amount in ascending order. As an example of what to avoid, a request for outputs expressed like so: <code>[16, 8, 2, 64, 8]</code> might imply the client is preparing a payment for 26 sat; the client should instead order the list like so: <code>[2, 8, 8, 16, 64]</code> to mitigate this privacy leak to the mint.</p>"},{"location":"03/#swap-to-receive","title":"Swap to receive","text":"<p>Another useful case for the swap operation follows up the example above where <code>Alice</code> has swapped her <code>Proofs</code> ready to be sent to <code>Carol</code>. <code>Carol</code> can receive these <code>Proofs</code> using the same operation by using them as inputs to invalidate them and request new outputs from <code>Bob</code>. Only if <code>Carol</code> has redeemed new outputs, <code>Alice</code> can't double-spend the <code>Proofs</code> anymore and the transaction is settled. To continue our example, <code>Carol</code> requests a swap with input <code>Proofs</code> worth <code>[32, 8]</code> to receive new outputs (of an arbitrary distribution) with the same total amount.</p>"},{"location":"03/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/swap\n</code></pre> <p>With the data being of the form <code>PostSwapRequest</code>:</p> <pre><code>{\n  \"inputs\": &lt;Array[Proof]&gt;,\n  \"outputs\": &lt;Array[BlindedMessage]&gt;,\n}\n</code></pre> <p>With curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/swap -d \\\n{\n  \"inputs\":\n    [\n      {\n        \"amount\": 2,\n        \"id\": \"009a1f293253e41e\",\n        \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n        \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n      },\n      {\n      ...\n      }\n    ],\n  \"outputs\":\n    [\n      {\n        \"amount\": 2,\n        \"id\": \"009a1f293253e41e\",\n        \"B_\": \"02634a2c2b34bec9e8a4aba4361f6bf202d7fa2365379b0840afe249a7a9d71239\"\n      },\n      {\n      ...\n      }\n    ],\n}\n</code></pre> <p>If successful, <code>Bob</code> will respond with a <code>PostSwapResponse</code></p> <pre><code>{\n  \"signatures\": &lt;Array[BlindSignature]&gt;\n}\n</code></pre>"},{"location":"04/","title":"NUT-04: Mint tokens","text":"<p><code>mandatory</code></p> <p><code>used in: NUT-20</code></p> <p>Minting tokens is a two-step process: requesting a mint quote and minting new tokens. Here, we describe both steps.</p> <p>In the first request the wallet asks the mint for a quote for a specific <code>amount</code> and <code>unit</code> to mint, and the payment <code>method</code> to pay. The mint responds with a quote that includes a <code>quote</code> id and a payment <code>request</code>. The user pays the <code>request</code> and, if successful, requests minting of new tokens with the mint in a second request. The wallet includes the <code>quote</code> id and new <code>outputs</code> in the second request.</p> <p>We limit this document to mint quotes of <code>unit=\"sat\"</code> and <code>method=\"bolt11\"</code> which requests a bolt11 Lightning invoice (typically generated by the mint to add Bitcoin to its reserves) to mint ecash denominated in Satoshis.</p>"},{"location":"04/#mint-quote","title":"Mint quote","text":"<p>To request a mint quote, the wallet of <code>Alice</code> makes a <code>POST /v1/mint/quote/{method}</code> request where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/mint/quote/bolt11\n</code></pre> <p>The wallet of <code>Alice</code> includes the following <code>PostMintQuoteBolt11Request</code> data in its request:</p> <pre><code>{\n  \"amount\": &lt;int&gt;,\n  \"unit\": &lt;str_enum[\"sat\"]&gt;,\n  \"description\": &lt;str&gt; // Optional\n}\n</code></pre> <p>with the requested <code>amount</code> and the <code>unit</code>. An optional <code>description</code> can be passed if the mint signals support for it in <code>MintMethodSetting</code>.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMintQuoteBolt11Response</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"request\": &lt;str&gt;,\n  \"state\": &lt;str_enum[STATE]&gt;,\n  \"expiry\": &lt;int&gt;\n}\n</code></pre> <p>Where <code>quote</code> is the quote ID and <code>request</code> is the payment request to fulfill. <code>expiry</code> is the Unix timestamp until which the mint quote is valid.</p> <p><code>state</code> is an enum string field with possible values <code>\"UNPAID\"</code>, <code>\"PAID\"</code>, <code>\"ISSUED\"</code>:</p> <ul> <li><code>\"UNPAID\"</code> means that the quote's request has not been paid yet.</li> <li><code>\"PAID\"</code> means that the request has been paid.</li> <li><code>\"ISSUED\"</code> means that the quote has already been issued.</li> </ul> <p>[!CAUTION]</p> <p><code>quote</code> is a unique and random id generated by the mint to internally look up the payment state. <code>quote</code> MUST remain a secret between user and mint and MUST NOT be derivable from the payment request. A third party who knows the <code>quote</code> ID can front-run and steal the tokens that this operation mints.</p>"},{"location":"04/#example","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST http://localhost:3338/v1/mint/quote/bolt11 -d '{\"amount\": 10, \"unit\": \"sat\"}' -H \"Content-Type: application/json\"\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"quote\": \"DSGLX9kevM...\",\n  \"request\": \"lnbc100n1pj4apw9...\",\n  \"state\": \"UNPAID\",\n  \"expiry\": 1701704757\n}\n</code></pre> <p>The wallet MUST store the <code>amount</code> in the request and the <code>quote</code> id in the response in its database so it can later request the tokens after paying the request. After payment, the wallet continues with the next section.</p>"},{"location":"04/#check-mint-quote-state","title":"Check mint quote state","text":"<p>To check whether a mint quote has been paid, <code>Alice</code> makes a <code>GET /v1/mint/quote/bolt11/{quote_id}</code>.</p> <pre><code>GET https://mint.host:3338/v1/mint/quote/bolt11/{quote_id}\n</code></pre> <p>Like before, the mint <code>Bob</code> responds with a <code>PostMintQuoteBolt11Response</code>.</p> <p>Example request of <code>Alice</code> with curl:</p> <pre><code>curl -X GET http://localhost:3338/v1/mint/quote/bolt11/DSGLX9kevM...\n</code></pre>"},{"location":"04/#minting-tokens","title":"Minting tokens","text":"<p>After requesting a mint quote and paying the request, the wallet proceeds with minting new tokens by calling the <code>POST /v1/mint/{method}</code> endpoint where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/mint/bolt11\n</code></pre> <p>The wallet <code>Alice</code> includes the following <code>PostMintBolt11Request</code> data in its request</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"outputs\": &lt;Array[BlindedMessage]&gt;\n}\n</code></pre> <p>with the <code>quote</code> being the quote ID from the previous step and <code>outputs</code> being <code>BlindedMessages</code> (see NUT-00) that the wallet requests signatures on whose sum is <code>amount</code> as requested in the quote.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMintBolt11Response</code>:</p> <pre><code>{\n  \"signatures\": &lt;Array[BlindSignature]&gt;\n}\n</code></pre> <p>where <code>signatures</code> is an array of blind signatures on the outputs.</p>"},{"location":"04/#example_1","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/mint/bolt11 -H \"Content-Type: application/json\" -d \\\n'{\n  \"quote\": \"DSGLX9kevM...\",\n  \"outputs\": [\n    {\n      \"amount\": 8,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"035015e6d7ade60ba8426cefaf1832bbd27257636e44a76b922d78e79b47cb689d\"\n    },\n    {\n      \"amount\": 2,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"0288d7649652d0a83fc9c966c969fb217f15904431e61a44b14999fabc1b5d9ac6\"\n    }\n  ]\n}'\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"signatures\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 2,\n      \"C_\": \"0224f1c4c564230ad3d96c5033efdc425582397a5a7691d600202732edc6d4b1ec\"\n    },\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 8,\n      \"C_\": \"0277d1de806ed177007e5b94a8139343b6382e472c752a74e99949d511f7194f6c\"\n    }\n  ]\n}\n</code></pre> <p>If the invoice was not paid yet, <code>Bob</code> responds with an error. In that case, <code>Alice</code> CAN repeat the same request until the Lightning invoice is settled.</p>"},{"location":"04/#unblinding-signatures","title":"Unblinding signatures","text":"<p>Upon receiving the <code>BlindSignatures</code> from the mint <code>Bob</code>, the wallet of <code>Alice</code> unblinds them to generate <code>Proofs</code> (using the blinding factor <code>r</code> and the mint's public key <code>K</code>, see BDHKE NUT-00). The wallet then stores these <code>Proofs</code> in its database:</p> <pre><code>[\n  {\n    \"id\": \"009a1f293253e41e\",\n    \"amount\": 2,\n    \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n    \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n  },\n  {\n    \"id\": \"009a1f293253e41e\",\n    \"amount\": 8,\n    \"secret\": \"fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be\",\n    \"C\": \"029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059\"\n  }\n]\n</code></pre>"},{"location":"04/#settings","title":"Settings","text":"<p>The settings for this nut indicate the supported method-unit pairs for minting and whether minting is disabled or not. They are part of the info response of the mint (NUT-06) which in this case reads</p> <pre><code>{\n  \"4\": {\n    \"methods\": [\n      &lt;MintMethodSetting&gt;,\n      ...\n    ],\n    \"disabled\": &lt;bool&gt;\n  }\n}\n</code></pre> <p><code>MintMethodSetting</code> indicates supported <code>method</code> and <code>unit</code> pairs and additional settings of the mint. <code>disabled</code> indicates whether this minting is disabled.</p> <p><code>MintMethodSetting</code> is of the form:</p> <pre><code>{\n  \"method\": &lt;str&gt;,\n  \"unit\": &lt;str&gt;,\n  \"min_amount\": &lt;int|null&gt;,\n  \"max_amount\": &lt;int|null&gt;,\n  \"description\": &lt;bool|null&gt;\n}\n</code></pre> <p><code>min_amount</code> and <code>max_amount</code> indicate the minimum and maximum amount for an operation of this method-unit pair.</p> <p>Example <code>MintMethodSetting</code>:</p> <pre><code>{\n  \"method\": \"bolt11\",\n  \"unit\": \"sat\",\n  \"min_amount\": 0,\n  \"max_amount\": 10000,\n  \"description\": true\n}\n</code></pre>"},{"location":"05/","title":"NUT-05: Melting tokens","text":"<p><code>mandatory</code></p> <p><code>used in: NUT-08, NUT-15</code></p> <p>Melting tokens is the opposite of minting tokens (see NUT-04). Like minting tokens, melting is a two-step process: requesting a melt quote and melting tokens. Here, we describe both steps.</p> <p>In the first request the wallet asks the mint for a quote for a <code>request</code> it wants paid by the mint and the <code>unit</code> the wallet would like to spend as inputs. The mint responds with a quote that includes a <code>quote</code> id and an <code>amount</code> the mint demands in the requested unit. For the method <code>bolt11</code>, the mint includes a <code>fee_reserve</code> field indicating the reserve fee for a Lightning payment.</p> <p>In the second request, the wallet includes the <code>quote</code> id and provides <code>inputs</code> that sum up to <code>amount+fee_reserve</code> in the first response. For the method <code>bolt11</code>, the wallet can also include <code>outputs</code> in order for the mint to return overpaid Lightning fees (see NUT-08). The mint responds with a payment <code>state</code>. If the <code>state</code> is <code>\"PAID\"</code> the response includes a <code>payment_preimage</code> as a proof of payment. If the request included <code>outputs</code>, the mint may respond with <code>change</code> for the overpaid fees (see NUT-08).</p> <p>We limit this document to mint quotes of <code>unit=\"sat\"</code> and <code>method=\"bolt11\"</code> which requests a bolt11 Lightning payment (typically paid by the mint from its Bitcoin reserves) using ecash denominated in Satoshis.</p>"},{"location":"05/#melt-quote","title":"Melt quote","text":"<p>To request a melt quote, the wallet of <code>Alice</code> makes a <code>POST /v1/melt/quote/{method}</code> request where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/melt/quote/bolt11\n</code></pre> <p>The wallet <code>Alice</code> includes the following <code>PostMeltQuoteBolt11Request</code> data in its request:</p> <pre><code>{\n  \"request\": &lt;str&gt;,\n  \"unit\": &lt;str_enum[\"sat\"]&gt;\n}\n</code></pre> <p>Here, <code>request</code> is the bolt11 Lightning invoice to be paid and <code>unit</code> is the unit the wallet would like to pay with.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMeltQuoteBolt11Response</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"fee_reserve\": &lt;int&gt;,\n  \"state\": &lt;str_enum[STATE]&gt;,\n  \"expiry\": &lt;int&gt;,\n  \"payment_preimage\": &lt;str|null&gt;\n}\n</code></pre> <p>Where <code>quote</code> is the quote ID, <code>amount</code> the amount that needs to be provided, and <code>fee_reserve</code> the additional fee reserve that is required. The mint expects <code>Alice</code> to include <code>Proofs</code> of at least <code>total_amount = amount + fee_reserve</code>. <code>expiry</code> is the Unix timestamp until which the melt quote is valid. <code>payment_preimage</code> is the bolt11 payment preimage in case of a successful payment.</p> <p><code>state</code> is an enum string field with possible values <code>\"UNPAID\"</code>, <code>\"PENDING\"</code>, <code>\"PAID\"</code>:</p> <ul> <li><code>\"UNPAID\"</code> means that the request has not been paid yet.</li> <li><code>\"PENDING\"</code> means that the request is currently being paid.</li> <li><code>\"PAID\"</code> means that the request has been paid successfully.</li> </ul>"},{"location":"05/#example","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/melt/quote/bolt11 -d \\\n{\n  \"request\": \"lnbc100n1p3kdrv5sp5lpdxzghe5j67q...\",\n  \"unit\": \"sat\"\n}\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"quote\": \"TRmjduhIsPxd...\",\n  \"amount\": 10,\n  \"fee_reserve\": 2,\n  \"state\": \"UNPAID\",\n  \"expiry\": 1701704757\n}\n</code></pre>"},{"location":"05/#check-melt-quote-state","title":"Check melt quote state","text":"<p>To check whether a melt quote has been paid, <code>Alice</code> makes a <code>GET /v1/melt/quote/bolt11/{quote_id}</code>.</p> <pre><code>GET https://mint.host:3338/v1/melt/quote/bolt11/{quote_id}\n</code></pre> <p>Like before, the mint <code>Bob</code> responds with a <code>PostMeltQuoteBolt11Response</code>.</p> <p>Example request of <code>Alice</code> with curl:</p> <pre><code>curl -X GET http://localhost:3338/v1/melt/quote/bolt11/TRmjduhIsPxd...\n</code></pre>"},{"location":"05/#melting-tokens","title":"Melting tokens","text":"<p>Now that <code>Alice</code> knows what the total amount is (<code>amount + fee_reserve</code>) in her requested <code>unit</code>, she can proceed to melting tokens for which a payment will be executed by the mint. She calls the <code>POST /v1/melt/{method}</code> endpoint where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/melt/bolt11\n</code></pre> <p>\u26a0\ufe0f Attention: This call will block until the Lightning payment either succeeds or fails. This can take quite a long time in case the Lightning payment is slow. Make sure to use no (or a very long) timeout when making this call!</p> <p>The wallet of <code>Alice</code> includes the following <code>PostMeltBolt11Request</code> data in its request</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"inputs\": &lt;Array[Proof]&gt;\n}\n</code></pre> <p>Here, <code>quote</code> is the melt quote ID to be paid and <code>inputs</code> are the proofs with a total amount of at least <code>amount + fee_reserve</code> (see previous melt quote response).</p> <p>Like before, the mint <code>Bob</code> then responds with a <code>PostMeltQuoteBolt11Response</code>. If the payment was successful, the <code>state</code> field is set to <code>\"PAID\"</code> and the response includes the <code>payment_preimage</code> field containing the payment secret of the bolt11 payment.</p> <p>If <code>state==\"PAID\"</code>, <code>Alice</code>'s wallet can delete the <code>inputs</code> from her database (or move them to a history). If <code>state==\"UNPAID\"</code>, <code>Alice</code> can repeat the same request again until the payment is successful.</p>"},{"location":"05/#example_1","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/melt/bolt11 -d \\\n'{\n  \"quote\": \"od4CN5smMMS3K3QVHkbGGNCTxfcAIyIXeq8IrfhP\",\n  \"inputs\": [\n    {\n      \"amount\": 4,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"429700b812a58436be2629af8731a31a37fce54dbf8cbbe90b3f8553179d23f5\",\n      \"C\": \"03b01869f528337e161a6768b480fcf9f75fd248b649c382f5e352489fd84fd011\",\n    },\n    {\n      \"amount\": 8,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"4f3155acef6481108fcf354f6d06e504ce8b441e617d30c88924991298cdbcad\",\n      \"C\": \"0278ab1c1af35487a5ea903b693e96447b2034d0fd6bac529e753097743bf73ca9\",\n    }\n  ]\n}'\n</code></pre> <p>Response <code>PostMeltQuoteBolt11Response</code> of <code>Bob</code>:</p> <pre><code>{\n  \"quote\": \"TRmjduhIsPxd...\",\n  \"amount\": 10,\n  \"fee_reserve\": 2,\n  \"state\": \"PAID\",\n  \"expiry\": 1701704757,\n  \"payment_preimage\": \"c5a1ae1f639e1f4a3872e81500fd028bece7bedc1152f740cba5c3417b748c1b\"\n}\n</code></pre>"},{"location":"05/#settings","title":"Settings","text":"<p>The mint's settings for this nut indicate the supported method-unit pairs for melting. They are part of the info response of the mint (NUT-06) which in this case reads</p> <pre><code>{\n  \"5\": {\n    \"methods\": [\n      &lt;MeltMethodSetting&gt;,\n      ...\n    ],\n    \"disabled\": &lt;bool&gt;\n  }\n}\n</code></pre> <p><code>MeltMethodSetting</code> indicates supported <code>method</code> and <code>unit</code> pairs and additional settings of the mint. <code>disabled</code> indicates whether melting is disabled.</p> <p><code>MeltMethodSetting</code> is of the form:</p> <pre><code>{\n  \"method\": &lt;str&gt;,\n  \"unit\": &lt;str&gt;,\n  \"min_amount\": &lt;int|null&gt;,\n  \"max_amount\": &lt;int|null&gt;\n}\n</code></pre> <p><code>min_amount</code> and <code>max_amount</code> indicate the minimum and maximum amount for an operation of this method-unit pair.</p> <p>Example <code>MeltMethodSetting</code>:</p> <pre><code>{\n  \"method\": \"bolt11\",\n  \"unit\": \"sat\",\n  \"min_amount\": 100,\n  \"max_amount\": 10000\n}\n</code></pre>"},{"location":"06/","title":"NUT-06: Mint information","text":"<p><code>mandatory</code></p> <p>This endpoint returns information about the mint that a wallet can show to the user and use to make decisions on how to interact with the mint.</p>"},{"location":"06/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>GET https://mint.host:3338/v1/info\n</code></pre> <p>With the mint's response being of the form <code>GetInfoResponse</code>:</p> <pre><code>{\n  \"name\": \"Bob's Cashu mint\",\n  \"pubkey\": \"0283bf290884eed3a7ca2663fc0260de2e2064d6b355ea13f98dec004b7a7ead99\",\n  \"version\": \"Nutshell/0.15.0\",\n  \"description\": \"The short mint description\",\n  \"description_long\": \"A description that can be a long piece of text.\",\n  \"contact\": [\n    {\n      \"method\": \"email\",\n      \"info\": \"contact@me.com\"\n    },\n    {\n      \"method\": \"twitter\",\n      \"info\": \"@me\"\n    },\n    {\n      \"method\": \"nostr\",\n      \"info\": \"npub...\"\n    }\n  ],\n  \"motd\": \"Message to display to users.\",\n  \"icon_url\": \"https://mint.host/icon.jpg\",\n  \"urls\": [\n    \"https://mint.host\",\n    \"http://mint8gv0sq5ul602uxt2fe0t80e3c2bi9fy0cxedp69v1vat6ruj81wv.onion\"\n  ],\n  \"time\": 1725304480,\n  \"nuts\": {\n    \"4\": {\n      \"methods\": [\n        {\n          \"method\": \"bolt11\",\n          \"unit\": \"sat\",\n          \"min_amount\": 0,\n          \"max_amount\": 10000\n        }\n      ],\n      \"disabled\": false\n    },\n    \"5\": {\n      \"methods\": [\n        {\n          \"method\": \"bolt11\",\n          \"unit\": \"sat\",\n          \"min_amount\": 100,\n          \"max_amount\": 10000\n        }\n      ],\n      \"disabled\": false\n    },\n    \"7\": {\n      \"supported\": true\n    },\n    \"8\": {\n      \"supported\": true\n    },\n    \"9\": {\n      \"supported\": true\n    },\n    \"10\": {\n      \"supported\": true\n    },\n    \"12\": {\n      \"supported\": true\n    }\n  }\n}\n</code></pre> <ul> <li>(optional) <code>name</code> is the name of the mint and should be recognizable.</li> <li>(optional) <code>pubkey</code> is the hex pubkey of the mint.</li> <li>(optional) <code>version</code> is the implementation name and the version of the software running on this mint separated with a slash \"/\".</li> <li>(optional) <code>description</code> is a short description of the mint that can be shown in the wallet next to the mint's name.</li> <li>(optional) <code>description_long</code> is a long description that can be shown in an additional field.</li> <li>(optional) <code>contact</code> is an array of contact objects to reach the mint operator. A contact object consists of two fields. The <code>method</code> field denotes the contact method (like \"email\"), the <code>info</code> field denotes the identifier (like \"contact@me.com\").</li> <li>(optional) <code>motd</code> is the message of the day that the wallet must display to the user. It should only be used to display important announcements to users, such as scheduled maintenances.</li> <li>(optional) <code>icon_url</code> is the URL pointing to an image to be used as an icon for the mint. Recommended to be squared in shape.</li> <li>(optional) <code>urls</code> is the list of endpoint URLs where the mint is reachable from.</li> <li>(optional) <code>time</code> is the current time set on the server. The value is passed as a Unix timestamp integer.</li> <li>(optional) <code>nuts</code> indicates each NUT specification that the mint supports and its settings. The settings are defined in each NUT separately.</li> </ul> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/info\n</code></pre>"},{"location":"07/","title":"NUT-07: Token state check","text":"<p><code>optional</code></p> <p><code>used in: NUT-17, NUT-11, NUT-14</code></p> <p>With the token state check, wallets can ask the mint whether a specific proof is already spent and whether it is in-flight in a transaction. Wallets can also request the witness data that was used to spend a proof.</p>"},{"location":"07/#token-states","title":"Token states","text":"<p>A proof can be in one of the following states</p> <ul> <li>A proof is <code>UNSPENT</code> if it has not been spent yet</li> <li>A proof is <code>PENDING</code> if it is being processed in a transaction (in an ongoing payment). A <code>PENDING</code> proof cannot be used in another transaction until it is <code>live</code> again.</li> <li>A proof is <code>SPENT</code> if it has been redeemed and its secret is in the list of spent secrets of the mint.</li> </ul> <p>Note: Before deleting spent proofs from their database, wallets can check if the proof is <code>SPENT</code> to make sure that they don't accidentally delete an unspent proof. Beware that this behavior can make it easier for the mint to correlate the sender to the receiver.</p> <p>Important: Mints MUST remember which proofs are currently <code>PENDING</code> to avoid reuse of the same token in multiple concurrent transactions. This can be achieved with for example mutex lock whose key is the <code>Proof</code>'s <code>Y</code>.</p>"},{"location":"07/#use-cases","title":"Use cases","text":""},{"location":"07/#example-1-ecash-transaction","title":"Example 1: Ecash transaction","text":"<p>When <code>Alice</code> prepares a token to be sent to <code>Carol</code>, she can mark these tokens in her database as pending. She can then, periodically or upon user input, check with the mint if the token is <code>UNSPENT</code> or whether it has been redeemed by <code>Carol</code> already, i.e., is <code>SPENT</code>. If the proof is not spendable anymore (and, thus, has been redeemed by <code>Carol</code>), she can safely delete the proof from her database.</p>"},{"location":"07/#example-2-lightning-payments","title":"Example 2: Lightning payments","text":"<p>If <code>Alice</code>'s melt operation takes a long time to complete (for example if she requests a very slow Lightning payment) and she closes her wallet in the meantime, the next time she comes online, she can check all proofs marked as pending in her database to determine whether the payment is still in flight (mint returns <code>PENDING</code>), it has succeeded (mint returns <code>SPENT</code>), or it has failed (mint returns <code>UNSPENT</code>).</p>"},{"location":"07/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/checkstate\n</code></pre> <p>With the data being of the form <code>PostCheckStateRequest</code>:</p> <pre><code>{\n  \"Ys\": &lt;Array[hex_str]&gt;,\n}\n</code></pre> <p>Where the elements of the array in <code>Ys</code> are the hexadecimal representation of the compressed point <code>Y = hash_to_curve(secret)</code> of the <code>Proof</code> to check (see NUT-00).</p> <p>Response of <code>Bob</code>:</p> <p><code>Bob</code> responds with a <code>PostCheckStateResponse</code>:</p> <pre><code>{\n  \"states\": [\n    {\n      \"Y\": &lt;hex_str&gt;,\n      \"state\": &lt;str_enum[STATE]&gt;,\n      \"witness\": &lt;str|null&gt;,\n    },\n    ...\n  ]\n}\n</code></pre> <p>The elements of the <code>states</code> array MUST be returned in the same order as the corresponding <code>Ys</code> checked in the request.</p> <ul> <li><code>Y</code> corresponds to the <code>Proof</code> checked in the request.</li> <li><code>state</code> is an enum string field with possible values <code>\"UNSPENT\"</code>, <code>\"PENDING\"</code>, <code>\"SPENT\"</code></li> <li><code>witness</code> is the serialized witness data that was used to spend the <code>Proof</code> if the token has a NUT-10 spending condition that requires a witness such as in the case of P2PK (NUT-11) or HTLCs (NUT-14).</li> </ul> <p>With curl:</p> <p>Request of <code>Alice</code>:</p> <pre><code>curl -X POST https://mint.host:3338/v1/checkstate -H 'Content-Type: application/json' -d '{\n  \"Ys\": [\n    \"02599b9ea0a1ad4143706c2a5a4a568ce442dd4313e1cf1f7f0b58a317c1a355ee\"\n  ]\n}'\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"states\": [\n    {\n      \"Y\": \"02599b9ea0a1ad4143706c2a5a4a568ce442dd4313e1cf1f7f0b58a317c1a355ee\",\n      \"state\": \"SPENT\",\n      \"witness\": \"{\\\"signatures\\\": [\\\"b2cf120a49cb1ac3cb32e1bf5ccb6425e0a8372affdc1d41912ca35c13908062f269c0caa53607d4e1ac4c8563246c4c8a869e6ee124ea826fd4746f3515dc1e\\\"]}\"\n    }\n  ]\n}\n</code></pre> <p>Where <code>Y</code> belongs to the provided <code>Proof</code> to check in the request, <code>state</code> indicates its state, and <code>witness</code> is the witness data that was potentially provided in a previous spend operation (can be empty).</p>"},{"location":"07/#mint-info-setting","title":"Mint info setting","text":"<p>The NUT-06 <code>MintMethodSetting</code> indicates support for this feature:</p> <pre><code>{\n  \"7\": {\n    \"supported\": true\n  }\n}\n</code></pre>"},{"location":"08/","title":"NUT-08: Lightning fee return","text":"<p><code>optional</code></p> <p><code>depends on: NUT-05</code></p> <p>This document describes how the overpaid Lightning fees are handled and extends NUT-05 which describes melting tokens (i.e. paying a Lightning invoice). In short, a wallet includes blank outputs when paying a Lightning invoice which can be assigned a value by the mint if the user has overpaid Lightning fees. This can be the case due to the unpredictability of Lightning network fees. To solve this issue, we introduce so-called blank outputs which are blinded messages with an undetermined value.</p> <p>The problem is also described in this gist.</p>"},{"location":"08/#description","title":"Description","text":"<p>Before requesting a Lightning payment as described in NUT-05, <code>Alice</code> produces a number of <code>BlindedMessage</code> which are similar to ordinary blinded messages but their value is yet to be determined by the mint <code>Bob</code> and are thus called blank outputs. The number of necessary blank outputs is <code>max(ceil(log2(fee_reserve)), 1)</code> which ensures that there is at least one output if there is any fee. If the <code>fee_reserve</code> is <code>0</code>, then the number of blank outputs is <code>0</code> as well. The blank outputs will contain the overpaid fees that will be returned by the mint to the wallet.</p> <p>This code calculates the number of necessary blank outputs in Python:</p> <pre><code>def calculate_number_of_blank_outputs(fee_reserve_sat: int) -&gt; int:\n    assert fee_reserve_sat &gt;= 0, \"Fee reserve can't be negative.\"\n    if fee_reserve_sat == 0:\n        return 0\n    return max(math.ceil(math.log2(fee_reserve_sat)), 1)\n</code></pre>"},{"location":"08/#example","title":"Example","text":"<p>The wallet wants to pay an invoice with <code>amount := 100 000 sat</code> and determines by asking the mint that <code>fee_reserve</code> is <code>1000 sats</code>. The wallet then provides <code>101 000 sat</code> worth of proofs and 10 blank <code>outputs</code> to make the payment (since <code>ceil(log2(1000))=ceil(9.96..)=10</code>). The mint pays the invoice and determines that the actual fee was <code>100 sat</code>, i.e, the overpaid fee to return is <code>fee_return = 900 sat</code>. The mint splits the amount <code>900</code> into summands of <code>2^n</code> which is <code>4, 128, 256, 512</code>. The mint inserts these amounts into the blank <code>outputs</code> it received form the wallet and generates 4 new promises. The mint then returns these <code>BlindSignature</code>s to the wallet together with the successful payment status.</p>"},{"location":"08/#wallet-flow","title":"Wallet flow","text":"<p>The wallet asks the mint for the <code>fee_reserve</code> for paying a specific bolt11 invoice of value <code>amount</code> by calling <code>POST /v1/melt/quote</code> as described in NUT-05. The wallet then provides a <code>PostMeltBolt11Request</code> to <code>POST /v1/melt/bolt11</code> that has (1) proofs of the value <code>amount+fee_reserve</code>, (2) the bolt11 invoice to be paid, and finally, as a new entry, (3) a field <code>outputs</code> that has <code>n_blank_outputs</code> blinded messages that are generated before the payment attempt to receive potential overpaid fees back to her.</p>"},{"location":"08/#mint-flow","title":"Mint flow","text":"<p>Here we describe how the mint generates <code>BlindSignature</code>s for the overpaid fees. The mint <code>Bob</code> returns in <code>PostMeltQuoteBolt11Response</code> the field <code>change</code> ONLY IF <code>Alice</code> has previously provided <code>outputs</code> for the change AND if the Lightning <code>actual_fees</code> were smaller than the <code>fee_reserve</code>.</p> <p>If the <code>overpaid_fees = fee_reserve - actual_fees</code> is positive, <code>Bob</code> decomposes it to values of <code>2^n</code> (as in NUT-00) and then imprints them into the <code>blank_outputs</code> provided by <code>Alice</code>.</p> <p><code>Bob</code> then signs these blank outputs (now with the imprinted amounts) and thus generates <code>BlindSignature</code>s. <code>Bob</code> then returns a payment status to the wallet, and, in addition, all blind signatures it generated for the overpaid fees.</p> <p>Importantly, while <code>Bob</code> does not necessarily return the same number of blind signatures as it received blank outputs from <code>Alice</code> (since some of them may be of value 0), <code>Bob</code> MUST return the all blank signatures with a value greater than 0 in the same order as the blank outputs were received and should omit all blind signatures with value 0. For example, if <code>Bob</code> receives 10 blank outputs but the overpaid fees only occupy 4 blind signatures, <code>Bob</code> will only return these 4 blind signatures with the appropriate imprinted amounts and omit the remaining 6 blind signatures with value 0. Due to the well-defined order of the returned blind signatures, <code>Alice</code> can map the blind signatures returned from <code>Bob</code> to the blank outputs it provided so that she can further apply the correct unblinding operations on them.</p>"},{"location":"08/#example_1","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/melt/bolt11\n</code></pre> <p>With the data being of the form <code>PostMeltBolt11Request</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"inputs\": &lt;Array[Proof]&gt;,\n  \"outputs\": &lt;Array[BlindedMessage]&gt; &lt;-- New\n}\n</code></pre> <p>where the new <code>output</code> field carries the <code>BlindMessages</code>.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMeltQuoteBolt11Response</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"fee_reserve\": &lt;int&gt;,\n  \"state\": &lt;str_enum[STATE]&gt;,\n  \"expiry\": &lt;int&gt;,\n  \"payment_preimage\": &lt;str|null&gt;,\n  \"change\": &lt;Array[BlindSignature]&gt; &lt;-- New\n}\n</code></pre> <p>where the new <code>change</code> field carries the returned <code>BlindSignature</code>s due to overpaid fees.</p>"},{"location":"08/#example_2","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/melt/bolt11 -d \\\n'{\n  \"quote\": \"od4CN5smMMS3K3QVHkbGGNCTxfcAIyIXeq8IrfhP\",\n  \"inputs\": [\n    {\n      \"amount\": 4,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"429700b812a58436be2629af8731a31a37fce54dbf8cbbe90b3f8553179d23f5\",\n      \"C\": \"03b01869f528337e161a6768b480fcf9f75fd248b649c382f5e352489fd84fd011\",\n    },\n    {\n      \"amount\": 8,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"4f3155acef6481108fcf354f6d06e504ce8b441e617d30c88924991298cdbcad\",\n      \"C\": \"0278ab1c1af35487a5ea903b693e96447b2034d0fd6bac529e753097743bf73ca9\",\n    }\n  ],\n  \"outputs\": [\n    {\n      \"amount\": 1,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"03327fc4fa333909b70f08759e217ce5c94e6bf1fc2382562f3c560c5580fa69f4\"\n    }\n  ]\n}'\n</code></pre> <p>Everything here is the same as in NUT-05 except for <code>outputs</code>. The <code>amount</code> field in the <code>BlindedMessage</code>s here are ignored by <code>Bob</code> so they can be set to any arbitrary value by <code>Alice</code> (they should be set to a value, like <code>1</code> so potential JSON validations do not error).</p> <p>If the mint has made a successful payment, it will respond the following.</p> <p>Response <code>PostMeltQuoteBolt11Response</code> from <code>Bob</code>:</p> <pre><code>{\n  \"state\": \"PAID\",\n  \"payment_preimage\": \"c5a1ae1f639e1f4a3872e81500fd028bece7bedc1152f740cba5c3417b748c1b\",\n  \"change\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 2,\n      \"C_\": \"03c668f551855ddc792e22ea61d32ddfa6a45b1eb659ce66e915bf5127a8657be0\"\n    }\n  ]\n}\n</code></pre> <p>The field <code>change</code> is an array of <code>BlindSignatures</code> that account for the overpaid fees. Notice that the amount has been changed by the mint. <code>Alice</code> must take these and generate <code>Proofs</code> by unblinding them as described in NUT-00 and as she does in NUT-04 when minting new tokens. After generating the <code>Proofs</code>, <code>Alice</code> stores them in her database.</p>"},{"location":"08/#mint-info-setting","title":"Mint info setting","text":"<p>The NUT-06 <code>MintMethodSetting</code> indicates support for this feature:</p> <pre><code>{\n  \"8\": {\n    \"supported\": true\n  }\n}\n</code></pre>"},{"location":"09/","title":"NUT-09: Restore signatures","text":"<p><code>optional</code></p> <p><code>used in: NUT-13</code></p> <p>In this document, we describe how wallets can recover blind signatures, and with that their corresponding <code>Proofs</code>, by requesting from the mint to reissue the blind signatures. This can be used for a backup recovery of a lost wallet (see NUT-13) or for recovering the response of an interrupted swap request (see NUT-03).</p> <p>Mints must store the <code>BlindedMessage</code> and the corresponding <code>BlindSignature</code> in their database every time they issue a <code>BlindSignature</code>. Wallets provide the <code>BlindedMessage</code> for which they request the <code>BlindSignature</code>. Mints only respond with a <code>BlindSignature</code>, if they have previously signed the <code>BlindedMessage</code>. Each returned <code>BlindSignature</code> also contains the <code>amount</code> and the keyset <code>id</code> (see NUT-00) which is all the necessary information for a wallet to recover a <code>Proof</code>.</p> <p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/restore\n</code></pre> <p>With the data being of the form <code>PostRestoreRequest</code>:</p> <pre><code>{\n  \"outputs\": &lt;Array[BlindedMessages]&gt;\n}\n</code></pre> <p>Response of <code>Bob</code>:</p> <p>The mint <code>Bob</code> then responds with a <code>PostRestoreResponse</code>.</p> <pre><code>{\n  \"outputs\": &lt;Array[BlindedMessages]&gt;,\n  \"signatures\": &lt;Array[BlindSignature]&gt;\n}\n</code></pre> <p>The returned arrays <code>outputs</code> and <code>signatures</code> are of the same length and for every entry <code>outputs[i]</code>, there is a corresponding entry <code>signatures[i]</code>.</p>"},{"location":"09/#mint-info-setting","title":"Mint info setting","text":"<p>The [NUT-06][06] <code>MintMethodSetting</code> indicates support for this feature:</p> <pre><code>{\n  \"9\": {\n    \"supported\": true\n  }\n}\n</code></pre>"},{"location":"10/","title":"NUT-10: Spending conditions","text":"<p><code>optional</code></p> <p><code>used in: NUT-11, NUT-14</code></p> <p>An ordinary ecash token is a set of <code>Proofs</code> each with a random string <code>secret</code>. To spend such a token in a swap or a melt operation, wallets include <code>proofs</code> in their request each with a unique <code>secret</code>. To autorize a transaction, the mint requires that the <code>secret</code> has not been seen before. This is the most fundamental spending condition in Cashu, which ensures that a token can't be double-spent.</p> <p>In this NUT, we define a well-known format of <code>secret</code> that can be used to express more complex spending conditions. These conditions need to be met before the mint authorizes a transaction. Note that the specific type of spending condition is not part of this document but will be explained in other documents. Here, we describe the structure of <code>secret</code> which is expressed as a JSON <code>Secret</code> with a specific format.</p> <p>Spending conditions are enforced by the mint which means that, upon encountering a <code>Proof</code> where <code>Proof.secret</code> can be parsed into the well-known format, the mint can require additional conditions to be met.</p> <p>Caution: If the mint does not support spending conditions or a specific <code>kind</code> of spending condition, proofs may be treated as a regular anyone-can-spend tokens. Applications need to make sure to check whether the mint supports a specific <code>kind</code> of spending condition by checking the mint's info endpoint.</p>"},{"location":"10/#basic-components","title":"Basic components","text":"<p>An ecash transaction, i.e., a swap or a melt operation, with a spending condition consists of the following components:</p> <ul> <li>Inputs referring to the <code>Proofs</code> being spent</li> <li><code>Secret</code> containing the rules for unlocking a <code>Proof</code></li> <li>Additional witness data satisfying the unlock conditions such as signatures</li> <li>Outputs referring to the <code>BlindMessages</code> with new unlock conditions to which the <code>Proofs</code> are spent to</li> </ul> <p>Spending conditions are defined for each individual <code>Proof</code> and not on a transaction level that can consist of multiple <code>Proofs</code>. Similarly, spending conditions must be satisfied by providing signatures or additional witness data for each <code>Proof</code> separately. For a transaction to be valid, all <code>Proofs</code> in that transaction must be unlocked successfully.</p> <p>New <code>Secret</code>s of the outputs to which the inputs are spent to are provided as <code>BlindMessages</code> which means that they are blind-signed and not visible to the mint until they are actually spent.</p>"},{"location":"10/#well-known-secret","title":"Well-known Secret","text":"<p>Spending conditions are expressed in a well-known secret format that is revealed to the mint when spending (unlocking) a token, not when the token is minted (locked). The mint parses each <code>Proof</code>'s <code>secret</code>. If it can deserialize it into the following format it executes additional spending conditions that are further specified in additional NUTs.</p> <p>The well-known <code>Secret</code> stored in <code>Proof.secret</code> is a JSON of the format:</p> <pre><code>[\nkind &lt;str&gt;,\n  {\n    \"nonce\": &lt;str&gt;,\n    \"data\": &lt;str&gt;,\n    \"tags\": [[ \"key\", \"value1\", \"value2\", ...],  ... ], // (optional)\n  }\n]\n</code></pre> <ul> <li><code>kind</code> is the kind of the spending condition</li> <li><code>nonce</code> is a unique random string</li> <li><code>data</code> expresses the spending condition specific to each kind</li> <li><code>tags</code> hold additional data committed to and can be used for feature extensions</li> </ul>"},{"location":"10/#examples","title":"Examples","text":"<p>Example use cases of this secret format are</p> <ul> <li>NUT-11: Pay-to-Public-Key (P2PK)</li> <li>NUT-14: Hashed Timelock Contracts (HTLCs)</li> </ul>"},{"location":"10/#mint-info-setting","title":"Mint info setting","text":"<p>The NUT-06 <code>MintMethodSetting</code> indicates support for this feature:</p> <pre><code>{\n  \"10\": {\n    \"supported\": true\n  }\n}\n</code></pre>"},{"location":"11/","title":"NUT-11: Pay to Public Key (P2PK)","text":"<p><code>optional</code></p> <p><code>depends on: NUT-10</code></p> <p>This NUT describes Pay-to-Public-Key (P2PK) which is one kind of spending condition based on NUT-10's well-known <code>Secret</code>. Using P2PK, we can lock ecash tokens to a receiver's ECC public key and require a Schnorr signature with the corresponding private key to unlock the ecash. The spending condition is enforced by the mint.</p> <p>Caution: If the mint does not support this type of spending condition, proofs may be treated as a regular anyone-can-spend tokens. Applications need to make sure to check whether the mint supports a specific kind of spending condition by checking the mint's info endpoint.</p>"},{"location":"11/#pay-to-pubkey","title":"Pay-to-Pubkey","text":"<p>NUT-10 Secret <code>kind: P2PK</code></p> <p>If for a <code>Proof</code>, <code>Proof.secret</code> is a <code>Secret</code> of kind <code>P2PK</code>, the proof must be unlocked by providing a witness <code>Proof.witness</code> and one or more valid signatures in the array <code>Proof.witness.signatures</code>.</p> <p>In the basic case, when spending a locked token, the mint requires one valid Schnorr signature in <code>Proof.witness.signatures</code> on <code>Proof.secret</code> by the public key in <code>Proof.Secret.data</code>.</p> <p>To give a concrete example of the basic case, to mint a locked token we first create a P2PK <code>Secret</code> that reads:</p> <pre><code>[\n  \"P2PK\",\n  {\n    \"nonce\": \"859d4935c4907062a6297cf4e663e2835d90d97ecdd510745d32f6816323a41f\",\n    \"data\": \"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\",\n    \"tags\": [[\"sigflag\", \"SIG_INPUTS\"]]\n  }\n]\n</code></pre> <p>Here, <code>Secret.data</code> is the public key of the recipient of the locked ecash. We serialize this <code>Secret</code> to a string in <code>Proof.secret</code> and get a blind signature by the mint that is stored in <code>Proof.C</code> (see NUT-03]).</p> <p>The recipient who owns the private key of the public key <code>Secret.data</code> can spend this proof by providing a signature on the serialized <code>Proof.secret</code> string that is then added to <code>Proof.witness.signatures</code>:</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"859d4935c4907062a6297cf4e663e2835d90d97ecdd510745d32f6816323a41f\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"60f3c9b766770b46caac1d27e1ae6b77c8866ebaeba0b9489fe6a15a837eaa6fcd6eaa825499c72ac342983983fd3ba3a8a41f56677cc99ffd73da68b59e1383\\\"]}\"\n}\n</code></pre>"},{"location":"11/#signature-scheme","title":"Signature scheme","text":"<p>To spend a token locked with <code>P2PK</code>, the spender needs to include signatures in the spent proofs. We use <code>libsecp256k1</code>'s serialized 64 byte Schnorr signatures on the SHA256 hash of the message to sign. The message to sign is the field <code>Proof.secret</code> in the inputs. If indicated by <code>Secret.tags.sigflag</code> in the inputs, outputs might also require signatures on the message <code>BlindedMessage.B_</code>.</p> <p>An ecash spending operation like swap and melt can have multiple inputs and outputs. If we have more than one input or output, we provide signatures in each <code>Proof</code> and <code>BlindedMessage</code> individually. The inputs are the <code>Proofs</code> provided in the <code>inputs</code> field and the outputs are the <code>BlindedMessages</code> in the <code>outputs</code> field in the request body (see <code>PostMeltRequest</code> in NUT-05 and <code>PostSwapRequest</code> in NUT-03).</p>"},{"location":"11/#tags","title":"Tags","text":"<p>More complex spending conditions can be defined in the tags in <code>Proof.tags</code>. All tags are optional. Tags are arrays with two or more strings being <code>[\"key\", \"value1\", \"value2\", ...]</code>.</p> <p>Supported tags are:</p> <ul> <li><code>sigflag: &lt;str&gt;</code> determines whether outputs have to be signed as well</li> <li><code>n_sigs: &lt;int&gt;</code> specifies the minimum number of valid signatures expected</li> <li><code>pubkeys: &lt;hex_str&gt;</code> are additional public keys that can provide signatures (allows multiple entries)</li> <li><code>locktime: &lt;int&gt;</code> is the Unix timestamp of when the lock expires</li> <li><code>refund: &lt;hex_str&gt;</code> are optional refund public keys that can exclusively spend after <code>locktime</code> (allows multiple entries)</li> </ul> <p>Note: The tag serialization type is <code>[&lt;str&gt;, &lt;str&gt;, ...]</code> but some tag values are <code>int</code>. Wallets and mints must cast types appropriately for de/serialization.</p>"},{"location":"11/#signature-flags","title":"Signature flags","text":"<p>Signature flags are defined in the tag <code>Secret.tags['sigflag']</code>. Currently, there are two signature flags.</p> <ul> <li><code>SIG_INPUTS</code> requires valid signatures on all inputs. It is the default signature flag and will be applied even if the <code>sigflag</code> tag is absent.</li> <li><code>SIG_ALL</code> requires valid signatures on all inputs and on all outputs.</li> </ul> <p>The signature flag <code>SIG_ALL</code> is enforced if at least one of the <code>Proofs</code> have the flag <code>SIG_ALL</code>. Otherwise, <code>SIG_INPUTS</code> is enforced.</p>"},{"location":"11/#signature","title":"Signature","text":"<p>Signatures must be provided in the field <code>Proof.witness.signatures</code> for each <code>Proof</code> which is an input. If the signature flag <code>SIG_ALL</code> is enforced, signatures must also be provided for every output in its field <code>BlindedMessage.witness.signatures</code>.</p>"},{"location":"11/#signed-inputs","title":"Signed inputs","text":"<p>A <code>Proof</code> (an input) with a signature <code>P2PKWitness.signatures</code> on <code>secret</code> is the JSON (see NUT-00):</p> <pre><code>{\n  \"amount\": &lt;int&gt;,\n  \"secret\": &lt;str&gt;,\n  \"C\": &lt;hex_str&gt;,\n  \"id\": &lt;str&gt;,\n  \"witness\": &lt;P2PKWitness | str&gt; // Signatures on \"secret\"\n}\n</code></pre> <p>The <code>secret</code> of each input is signed as a string.</p>"},{"location":"11/#signed-outputs","title":"Signed outputs","text":"<p>A <code>BlindedMessage</code> (an output) with a signature <code>P2PKWitness.signatures</code> on <code>B_</code> is the JSON (see NUT-00):</p> <pre><code>{\n  \"amount\": &lt;int&gt;,\n  \"B_\": &lt;hex_str&gt;,\n  \"witness\": &lt;P2PKWitness | str&gt; // Signatures on \"B_\"\n}\n</code></pre> <p>The <code>B_</code> of each output is signed as bytes which comes from the original hex string.</p>"},{"location":"11/#witness-format","title":"Witness format","text":"<p><code>P2PKWitness</code> is a serialized JSON string of the form</p> <pre><code>{\n  \"signatures\": &lt;Array[&lt;hex_str&gt;]&gt;\n}\n</code></pre> <p>The <code>signatures</code> are an array of signatures in hex. The witness for a spent proof can be obtained with a <code>Proof</code> state check (see NUT-07).</p>"},{"location":"11/#multisig","title":"Multisig","text":"<p>If the tag <code>n_sigs</code> is a positive integer, the mint will also consider signatures from public keys specified in the <code>pubkeys</code> tag additional to the public key in <code>Secret.data</code>. If the number of valid signatures is greater or equal to the number specified in <code>n_sigs</code>, the transaction is valid.</p> <p>Expressed as an \"n-of-m\" scheme, <code>n = n_sigs</code> is the number of required signatures and <code>m = 1 (\"data\" field) + len(pubkeys tag)</code> is the number of public keys that could sign.</p>"},{"location":"11/#locktime","title":"Locktime","text":"<p>If the tag <code>locktime</code> is the unix time and the mint's local clock is greater than <code>locktime</code>, the <code>Proof</code> becomes spendable by anyone, except if the following condition is also true. Note: A <code>Proof</code> is considered spendable by anyone if it only requires a <code>secret</code> and a valid signature <code>C</code> to be spent (which is the default case).</p>"},{"location":"11/#refund-public-keys","title":"Refund public keys","text":"<p>If the <code>locktime</code> is in the past and a tag <code>refund</code> is present, the <code>Proof</code> is spendable only if a valid signature by one of the the <code>refund</code> pubkeys is provided in <code>Proof.witness.signatures</code> and, depending on the signature flag, in <code>BlindedMessage.witness.signatures</code>.</p>"},{"location":"11/#complex-example","title":"Complex Example","text":"<p>This is an example <code>secret</code> that locks a <code>Proof</code> with a Pay-to-Pubkey (P2PK) condition that requires 2-of-3 signatures from the public keys in the <code>data</code> field and the <code>pubkeys</code> tag. If the <code>timelock</code> has passed, the <code>Proof</code> becomes spendable with a single signature from the public key in the <code>refund</code> tag. The signature flag <code>sigflag</code> indicates that signatures are necessary on the <code>inputs</code> and the <code>outputs</code> of a transaction.</p> <pre><code>[\n  \"P2PK\",\n  {\n    \"nonce\": \"da62796403af76c80cd6ce9153ed3746\",\n    \"data\": \"033281c37677ea273eb7183b783067f5244933ef78d8c3f15b1a77cb246099c26e\",\n    \"tags\": [\n      [\"sigflag\", \"SIG_ALL\"],\n      [\"n_sigs\", \"2\"],\n      [\"locktime\", \"1689418329\"],\n      [\n        \"refund\",\n        \"033281c37677ea273eb7183b783067f5244933ef78d8c3f15b1a77cb246099c26e\"\n      ],\n      [\n        \"pubkeys\",\n        \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n        \"023192200a0cfd3867e48eb63b03ff599c7e46c8f4e41146b2d281173ca6c50c54\"\n      ]\n    ]\n  }\n]\n</code></pre>"},{"location":"11/#use-cases","title":"Use cases","text":"<p>The following use cases are unlocked using P2PK:</p> <ul> <li>Publicly post locked ecash that can only be redeemed by the intended receiver</li> <li>Final offline-receiver payments that can't be double-spent when combined with an offline signature check mechanism like DLEQ proofs</li> <li>Receiver of locked ecash can defer and batch multiple mint round trips for receiving proofs (requires DLEQ)</li> <li>Ecash that is owned by multiple people via the multisignature abilities</li> <li>Atomic swaps when used in combination with the locktime feature</li> </ul>"},{"location":"11/#mint-info-setting","title":"Mint info setting","text":"<p>The NUT-06 <code>MintMethodSetting</code> indicates support for this feature:</p> <pre><code>{\n  \"11\": {\n    \"supported\": true\n  }\n}\n</code></pre>"},{"location":"12/","title":"NUT-12: Offline ecash signature validation","text":"<p><code>optional</code></p> <p>In this document, we present an extension of Cashu's crypto system to allow a user <code>Alice</code> to verify the mint <code>Bob</code>'s signature using only <code>Bob</code>'s public keys. We explain how another user <code>Carol</code> who receives ecash from <code>Alice</code> can execute the DLEQ proof as well. This is achieved using a Discrete Log Equality (DLEQ) proof. Previously, <code>Bob</code>'s signature could only be checked by himself using his own private keys (NUT-00).</p>"},{"location":"12/#the-dleq-proof","title":"The DLEQ proof","text":"<p>The purpose of this DLEQ is to prove that the mint has used the same private key <code>a</code> for creating its public key <code>A</code> (NUT-01) and for signing the BlindedMessage <code>B'</code>. <code>Bob</code> returns the DLEQ proof additional to the blind signature <code>C'</code> for a mint or swap operation.</p> <p>The complete DLEQ proof reads</p> <pre><code># DLEQ Proof\n\n(These steps occur when Bob returns C')\n\nBob:\nr = random nonce\nR1 = r*G\nR2 = r*B'\ne = hash(R1,R2,A,C')\ns = r + e*a\nreturn e, s\n\nAlice:\nR1 = s*G - e*A\nR2 = s*B' - e*C'\ne == hash(R1,R2,A,C')\n\nIf true, a in A = a*G must be equal to a in C' = a*B'\n</code></pre>"},{"location":"12/#hashx-arraypublickey-bytes","title":"<code>hash(x: &lt;Array&lt;[PublicKey]&gt;) -&gt; bytes</code>","text":"<p>The hash(x) function generates a deterministic Sha256 hash for a given input list of <code>PublicKey</code>. The uncompressed hexadecimal representations of each <code>PublicKey</code> is concatenated before taking the Sha256 hash.</p> <pre><code>def hash_e(*publickeys: PublicKey) -&gt; bytes:\n    e_ = \"\"\n    for p in publickeys:\n        _p = p.serialize(compressed=False).hex()\n        e_ += str(_p)\n    e = hashlib.sha256(e_.encode(\"utf-8\")).digest()\n    return e\n</code></pre>"},{"location":"12/#mint-to-user-dleq-in-blindsignature","title":"Mint to user: DLEQ in <code>BlindSignature</code>","text":"<p>The mint produces these DLEQ proofs when returning <code>BlindSignature</code>'s in the responses for minting (NUT-04) and swapping (NUT-03) tokens. The <code>BlindSignature</code> object is extended in the following way to include the DLEQ proof:</p> <pre><code>{\n  \"id\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"C_\": &lt;str&gt;,\n  \"dleq\": { &lt;-- New: DLEQ proof\n    \"e\": &lt;str&gt;,\n    \"s\": &lt;str&gt;\n  }\n}\n</code></pre> <p><code>e</code> and <code>s</code> are the DLEQ proof.</p>"},{"location":"12/#user-to-user-dleq-in-proof","title":"User to user: DLEQ in <code>Proof</code>","text":"<p>In order for <code>Alice</code> to communicate the DLEQ to another user <code>Carol</code>, we extend the <code>Proof</code> (see NUT-00) object and include the DLEQ proof. As explained below, we also need to include the blinding factor <code>r</code> for the proof to be convincing to another user <code>Carol</code>.</p> <pre><code>{\n  \"id\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"secret\": &lt;str&gt;,\n  \"C\": &lt;str&gt;,\n  \"dleq\": { &lt;-- New: DLEQ proof\n    \"e\": &lt;str&gt;,\n    \"s\": &lt;str&gt;,\n    \"r\": &lt;str&gt;\n  }\n}\n</code></pre> <p><code>e</code> and <code>s</code> are the challenge and response of the DLEQ proof returned by <code>Bob</code>, <code>r</code> is the blinding factor of <code>Alice</code> that was used to generate the <code>Proof</code>. <code>Alice</code> serializes these proofs like any other in a token (see NUT-00) to send it to another user <code>Carol</code>.</p>"},{"location":"12/#alice-minting-user-verifies-dleq-proof","title":"Alice (minting user) verifies DLEQ proof","text":"<p>When minting or swapping tokens, <code>Alice</code> receives DLEQ proofs in the <code>BlindSignature</code> response from the mint <code>Bob</code>. <code>Alice</code> checks the validity of the DLEQ proofs for each ecash token she receives via the equations:</p> <pre><code>R1 = s*G - e*A\nR2 = s*B' - e*C'\ne == hash(R1,R2,A,C') # must be True\n</code></pre> <p>Here, the variables are</p> <ul> <li><code>A</code> \u2013\u00a0the public key <code>Bob</code> used to sign this Proof</li> <li><code>(e, s)</code> \u2013\u00a0the DLEQ proof returned by <code>Bob</code></li> <li><code>B'</code> \u2013 <code>Alice</code>'s <code>BlindedMessage</code></li> <li><code>C'</code> \u2013 <code>Bob</code>'s <code>BlindSignature</code> on <code>B'</code></li> </ul> <p>In order to execute the proof, <code>Alice</code> needs <code>e, s</code> that are returned in the <code>BlindSignature</code> by <code>Bob</code>. <code>Alice</code> further needs <code>B'</code> (the <code>BlindedMessage</code> <code>Alice</code> created and <code>Bob</code> signed) and <code>C'</code> (the blind signature in the <code>BlindSignature</code> response) from <code>Bob</code>, and <code>A</code> (the public key of <code>Bob</code> with which he signed the BlindedMessage). All these values are available to <code>Alice</code> during or after calling the mint and swap operations.</p> <p>If a DLEQ proof is included in the mint's <code>BlindSignature</code> response, wallets MUST verify the DLEQ proof.</p>"},{"location":"12/#carol-another-user-verifies-dleq-proof","title":"Carol (another user) verifies DLEQ proof","text":"<p><code>Carol</code> is a user that receives <code>Proofs</code> in a token from another user Alice. When <code>Alice</code> sends <code>Proofs</code> with DLEQ proofs to <code>Carol</code> or when <code>Alice</code> posts the <code>Proofs</code> publicly, <code>Carol</code> can validate the DLEQ proof herself and verify <code>Bob</code>'s signature without having to talk to <code>Bob</code>. <code>Alice</code> includes the following information in the <code>Proof</code> (see above):</p> <ul> <li><code>(x, C)</code> \u2013\u00a0the ecash <code>Proof</code></li> <li><code>(e, s)</code> \u2013\u00a0the DLEQ proof revealed by <code>Alice</code></li> <li><code>r</code> \u2013 <code>Alice</code>'s blinding factor</li> </ul> <p>Here, <code>x</code> is the Proof's secret, and <code>C</code> is the mint's signature on it. To execute the DLEQ proof like <code>Alice</code> did above, <code>Carol</code> needs <code>(B', C')</code> which she can compute herself using the blinding factor <code>r</code> that she receives from <code>Alice</code>.</p> <p>To verify the DLEQ proof of a received token, <code>Carol</code> needs to reconstruct <code>B'</code> and <code>C'</code> using the blinding factor <code>r</code> that <code>Alice</code> has included in the <code>Proof</code> she sent to <code>Carol</code>. Since <code>Carol</code> now has all the necessary information, she can execute the same equations to verify the DLEQ proof as <code>Alice</code> did:</p> <pre><code>Y = hash_to_curve(x)\nC' = C + r*A\nB' = Y + r*G\n\nR1 = ... (same as Alice)\n</code></pre> <p>If a DLEQ proof is included in a received token, wallets MUST verify the proof.</p>"},{"location":"12/#mint-info-setting","title":"Mint info setting","text":"<p>The NUT-06 <code>MintMethodSetting</code> indicates support for this feature:</p> <pre><code>{\n  \"12\": {\n    \"supported\": true\n  }\n}\n</code></pre>"},{"location":"13/","title":"NUT-13: Deterministic Secrets","text":"<p><code>optional</code></p> <p><code>depends on: NUT-09</code></p> <p>In this document, we describe the process that allows wallets to recover their ecash balance with the help of the mint using a familiar 12 word seed phrase (mnemonic). This allows us to restore the wallet's previous state in case of a device loss or other loss of access to the wallet. The basic idea is that wallets that generate the ecash deterministically can regenerate the same tokens during a recovery process. For this, they ask the mint to reissue previously generated signatures using NUT-09.</p>"},{"location":"13/#deterministic-secret-derivation","title":"Deterministic secret derivation","text":"<p>An ecash token, or a <code>Proof</code>, consists of a <code>secret</code> generated by the wallet, and a signature <code>C</code> generated by the wallet and the mint in collaboration. Here, we describe how wallets can deterministically generate the <code>secrets</code> and blinding factors <code>r</code> necessary to generate the signatures <code>C</code>.</p> <p>The wallet generates a <code>private_key</code> derived from a 12-word BIP39 <code>mnemonic</code> seed phrase that the user stores in a secure place. The wallet uses the <code>private_key</code>, to derive deterministic values for the <code>secret</code> and the blinding factors <code>r</code> for every new ecash token that it generates.</p> <p>In order to do this, the wallet keeps track of a <code>counter_k</code> for each <code>keyset_k</code> it uses. The index <code>k</code> indicates that the wallet needs to keep track of a separate counter for each keyset <code>k</code> it uses. Typically, the wallet will need to keep track of multiple keysets for every mint it interacts with. <code>counter_k</code> is used to generate a BIP32 derivation path which can then be used to derive <code>secret</code> and <code>r</code>.</p> <p>The following BIP32 derivation path is used. The derivation path depends on the keyset ID of <code>keyset_k</code>, and the <code>counter_k</code> of that keyset.</p> <ul> <li>Purpose' = <code>129372'</code> (UTF-8 for \ud83e\udd5c)</li> <li>Coin type' = Always <code>0'</code></li> <li>Keyset id' = Keyset ID represented as an integer (<code>keyset_k_int</code>)</li> <li>Coin counter' = <code>counter'</code> (this value is incremented)</li> <li><code>secret</code> or <code>r</code> = <code>0</code> or <code>1</code></li> </ul> <p><code>m / 129372' / 0' / keyset_k_int' / counter' / secret||r</code></p> <p>This results in the following derivation paths:</p> <pre><code>secret_derivation_path = `m/129372'/0'/{keyset_k_int}'/{counter_k}'/0`\nr_derivation_path = `m/129372'/0'/{keyset_id_k_int}'/{counter_k}'/1`\n</code></pre> <p>Here, <code>{keyset_k_int}</code> and <code>{counter_k}</code> are the only variables that can change. <code>keyset_id_k_int</code> is an integer representation (see below) of the keyset ID the token is generated with. This means that the derivation path is unique for each keyset. Note that the coin type is always <code>0'</code>, independent of the unit of the ecash.</p> <p>Note: For examples, see the test vectors.</p>"},{"location":"13/#counter","title":"Counter","text":"<p>The wallet starts with <code>counter_k := 0</code> upon encountering a new keyset and increments it by <code>1</code> every time it has successfully minted new ecash with this keyset. The wallet stores the latest <code>counter_k</code> in its database for all keysets it uses. Note that we have a <code>counter</code> (and therefore a derivation path) for each keyset <code>k</code>. We omit the keyset index <code>k</code> in the following of this document.</p>"},{"location":"13/#keyset-id","title":"Keyset ID","text":"<p>The integer representation <code>keyset_id_int</code> of a keyset is calculated from its hexadecimal ID which has a length of 8 bytes or 16 hex characters. First, we convert the hex string to a big-endian sequence of bytes. This value is then modulo reduced by <code>2^31 - 1</code> to arrive at an integer that is a unique identifier <code>keyset_id_int</code>.</p> <p>Example in Python:</p> <pre><code>keyset_id_int = int.from_bytes(bytes.fromhex(keyset_id_hex), \"big\") % (2**31 - 1)\n</code></pre> <p>Example in JavaScript:</p> <pre><code>keysetIdInt = BigInt(`0x${keysetIdHex}`) % BigInt(2 ** 31 - 1);\n</code></pre>"},{"location":"13/#restore-from-seed-phrase","title":"Restore from seed phrase","text":"<p>Using deterministic secret derivation, a user's wallet can regenerate the same <code>BlindedMessages</code> in case of loss of a previous wallet state. To also restore the corresponding <code>BlindSignatures</code> to fully recover the ecash, the wallet can either requests the mint to re-issue past <code>BlindSignatures</code> on the regenerated <code>BlindedMessages</code> (see NUT-09) or by downloading the entire database of the mint (TBD).</p> <p>The wallet takes the following steps during recovery:</p> <ol> <li>Generate <code>secret</code> and <code>r</code> from <code>counter</code> and <code>keyset</code></li> <li>Generate <code>BlindedMessage</code> from <code>secret</code></li> <li>Obtain <code>BlindSignature</code> for <code>secret</code> from the mint</li> <li>Unblind <code>BlindSignature</code> to <code>C</code> using <code>r</code></li> <li>Restore <code>Proof = (secret, C)</code></li> <li>Check if <code>Proof</code> is already spent</li> </ol>"},{"location":"13/#generate-blindedmessages","title":"Generate <code>BlindedMessages</code>","text":"<p>To generate the <code>BlindedMessages</code>, the wallet starts with a <code>counter := 0</code> and , for each increment of the <code>counter</code>, generates a <code>secret</code> using the BIP32 private key derived from <code>secret_derivation_path</code> and converts it to a hex string.</p> <pre><code>secret = bip32.get_privkey_from_path(secret_derivation_path).hex()\n</code></pre> <p>The wallet similarly generates a blinding factor <code>r</code> from the <code>r_derivation_path</code>:</p> <pre><code>r = self.bip32.get_privkey_from_path(r_derivation_path)\n</code></pre> <p>Note: For examples, see the test vectors.</p> <p>Using the <code>secret</code> string and the private key <code>r</code>, the wallet generates a <code>BlindedMessage</code>. The wallet then increases the <code>counter</code> by <code>1</code> and repeats the same process for a given batch size. It is recommended to use a batch size of 100.</p> <p>The user's wallet can now request the corresponding <code>BlindSignatures</code> for theses <code>BlindedMessages</code> from the mint using the NUT-09 restore endpoint or by downloading the entire mint's database.</p>"},{"location":"13/#generate-proofs","title":"Generate <code>Proofs</code>","text":"<p>Using the restored <code>BlindSignatures</code> and the <code>r</code> generated in the previous step, the wallet can unblind the signature to <code>C</code>. The triple <code>(secret, C, amount)</code> is a restored <code>Proof</code>.</p>"},{"location":"13/#check-proofs-states","title":"Check <code>Proofs</code> states","text":"<p>If the wallet used the restore endpoint NUT-09 for regenerating the <code>Proofs</code>, it additionally needs to check for the <code>Proofs</code> spent state using NUT-07. The wallet deletes all <code>Proofs</code> which are already spent and keeps the unspent ones in its database.</p>"},{"location":"13/#restoring-batches","title":"Restoring batches","text":"<p>Generally, the user won't remember the last state of <code>counter</code> when starting the recovery process. Therefore, wallets need to know how far they need to increment the <code>counter</code> during the restore process to be confident to have reached the most recent state.</p> <p>In short, following approach is recommended:</p> <ul> <li>Restore <code>Proofs</code> in batches of 100 and increment <code>counter</code></li> <li>Repeat until three consecutive batches are returned empty</li> <li>Reset <code>counter</code> to the value at the last successful restore + 1</li> </ul> <p>Wallets restore <code>Proofs</code> in batches of 100. The wallet starts with a <code>counter=0</code> and increments it for every <code>Proof</code> it generated during one batch. When the wallet begins restoring the first <code>Proofs</code>, it is likely that the first few batches will only contain spent <code>Proofs</code>. Eventually, the wallet will reach a <code>counter</code> that will result in unspent <code>Proofs</code> which it stores in its database. The wallet then continues to restore until three successive batches are returned empty by the mint. This is to be confident that the restore process did not miss any <code>Proofs</code> that might have been generated with larger gaps in the <code>counter</code> by the previous wallet that we are restoring.</p>"},{"location":"14/","title":"NUT-14: Hashed Timelock Contracts (HTLCs)","text":"<p><code>optional</code></p> <p><code>depends on: NUT-10</code></p> <p>This NUT describes the use of Hashed Timelock Contracts (HTLCs) which defines a spending condition based on NUT-10's well-known <code>Secret</code> format. Using HTLCs, ecash tokens can be locked to the hash of a preimage or a timelock. This enables use cases such as atomic swaps of ecash between users, and atomic coupling of an ecash spending condition to a Lightning HTLC.</p> <p><code>HTLC</code> spending conditions can be thought of as an extension of <code>P2PK</code> locks NUT-11 but with a hash lock in <code>Secret.data</code> and a new <code>Proof.witness.preimage</code> witness in the locked inputs to be spent. The <code>preimage</code> that was used to spend a locked token can be retrieved using NUT-07. Caution: applications that rely on being able to retrieve the witness independent from the spender must check via the mint's info endpoint that NUT-07 is supported.</p> <p>Caution: If the mint does not support this type of spending condition, proofs may be treated as a regular anyone-can-spend tokens. Applications need to make sure to check whether the mint supports a specific kind of spending condition by checking the mint's info endpoint.</p>"},{"location":"14/#htlc","title":"HTLC","text":"<p>NUT-10 Secret <code>kind: HTLC</code></p> <p>If for a <code>Proof</code>, <code>Proof.secret</code> is a <code>Secret</code> of kind <code>HTLC</code>, the hash of the lock is in <code>Proof.secret.data</code>. The preimage for unlocking the HTLC is in the witness <code>Proof.witness.preimage</code>. All additional tags from <code>P2PK</code> locks are used here as well, allowing us to add a locktime, signature flag, and use multisig (see NUT-11).</p> <p>Here is a concrete example of a <code>Secret</code> of kind <code>HTLC</code>:</p> <pre><code>[\n  \"HTLC\",\n  {\n    \"nonce\": \"da62796403af76c80cd6ce9153ed3746\",\n    \"data\": \"023192200a0cfd3867e48eb63b03ff599c7e46c8f4e41146b2d281173ca6c50c54\",\n    \"tags\": [\n      [\n        \"pubkeys\",\n        \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\"\n      ],\n      [\"locktime\", \"1689418329\"],\n      [\n        \"refund\",\n        \"033281c37677ea273eb7183b783067f5244933ef78d8c3f15b1a77cb246099c26e\"\n      ]\n    ]\n  }\n]\n</code></pre> <p>A <code>Proof</code> with this <code>Secret</code> can be spent in two ways. To spend the hash lock, the witness in <code>Proof.witness</code> includes the preimage to <code>Secret.data</code> and a signature from the key in <code>Secret.tag.pubkeys</code>. Additionally, if the current system time is later than <code>Secret.tag.locktime</code>, the <code>Proof</code> can be spent if <code>Proof.witness</code> includes a signature from the key in <code>Secret.tags.refund</code>.</p> <p>The hash lock in <code>Secret.data</code> and the preimage in <code>Proof.witness.preimage</code> is treated as 32 byte data encoded as 64 character hex strings.</p> <p>See NUT-11 for a description of the signature scheme, the additional use of signature flags, and how to require signature from multiple public keys (multisig).</p>"},{"location":"14/#witness-format","title":"Witness format","text":"<p><code>HTLCWitness</code> is a serialized JSON string of the form</p> <pre><code>{\n  \"preimage\": &lt;hex_str&gt;,\n  \"signatures\": &lt;Array[&lt;hex_str&gt;]&gt;\n}\n</code></pre> <p>The witness for a spent proof can be obtained with a <code>Proof</code> state check (see NUT-07).</p>"},{"location":"14/#mint-info-setting","title":"Mint info setting","text":"<p>The NUT-06 <code>MintMethodSetting</code> indicates support for this feature:</p> <pre><code>{\n  \"14\": {\n    \"supported\": true\n  }\n}\n</code></pre>"},{"location":"15/","title":"NUT-15: Partial multi-path payments","text":"<p><code>optional</code></p> <p><code>depends on: NUT-05</code></p> <p>In this document, we describe how wallets can instruct multiple mints to each pay a partial amount of a bolt11 Lightning invoice. The full payment is composed of partial payments (MPP) from multiple multi-path payments from different Lightning nodes. This way, wallets can pay a larger Lightning invoice combined from multiple smaller balances on different mints. Due to the atomic nature of MPP, either all payments will be successful or all of them will fail.</p> <p>The Lightning backend of the mint must support paying a partial amount of an Invoice and multi-path payments (MPP, see BOLT 4). For example, the mint's Lightning node must be able to pay 50 sats of a 100 sat bolt11 invoice. The receiving Lightning node must support receiving multi-path payments as well.</p>"},{"location":"15/#multimint-payment-execution","title":"Multimint payment execution","text":"<p><code>Alice</code>'s wallet coordinates multiple MPPs on different mints that support the feature (see below for the indicated setting). For a given Lightning invoice of <code>amount_total</code>, <code>Alice</code> splits the total amount into several partial amounts <code>amount_total = amount_1 + amount_2 + ...</code> that each must be covered by her individual balances on the mints she wants to use for the payment. She constructs multiple <code>PostMeltQuoteBolt11Request</code>'s that each include the corresponding partial amount in the payment option (see below) that she sends to all mints she wants to use for the payment. The mints then respond with a normal <code>PostMeltQuoteBolt11Response</code> (see NUT-05). <code>Alice</code> proceeds to pay the melt requests at each mint simultaneously. When all mints have sent out the partial Lightning payment, she receives a successful response from all mints individually.</p>"},{"location":"15/#melt-quote","title":"Melt quote","text":"<p>To request a melt quote with a partial <code>amount</code>, the wallet of <code>Alice</code> makes a <code>POST /v1/melt/quote/bolt11</code> similar to NUT-05.</p> <pre><code>POST https://mint.host:3338/v1/melt/quote/bolt11\n</code></pre> <p>The wallet <code>Alice</code> includes the following <code>PostMeltQuoteBolt11Request</code> data in its request which includes an additional (and optional) <code>options</code> object compared to the standard request in NUT-05:</p> <pre><code>{\n  \"request\": &lt;str&gt;,\n  \"unit\": &lt;str_enum[\"sat\"]&gt;,\n  \"options\": {\n    \"mpp\": {\n      \"amount\": &lt;int&gt;\n    }\n  }\n}\n</code></pre> <p>Here, <code>request</code> is the bolt11 Lightning invoice to be paid, <code>unit</code> is the unit the wallet would like to pay with, and <code>amount</code> is the amount for the requested payment. The wallet then pays the returned melt quote the same way as in NUT-05.</p>"},{"location":"15/#mint-info-setting","title":"Mint info setting","text":"<p>The settings returned in the info endpoint (NUT-06) indicate that a mint supports this NUT. The mint MUST indicate each <code>method</code> and <code>unit</code> that supports mpp. It can indicate this in an array of objects for multiple <code>method</code> and <code>unit</code> pairs.</p> <p><code>MultipathPaymentSetting</code> is of the form:</p> <pre><code>{\n  [\n    {\n      \"method\": &lt;str&gt;,\n      \"unit\": &lt;str&gt;\n    },\n    ...\n  ]\n}\n</code></pre> <p>Example <code>MultipathPaymentSetting</code>:</p> <pre><code>{\n  \"15\": {\n    \"methods\": [\n      {\n        \"method\": \"bolt11\",\n        \"unit\": \"sat\"\n      },\n      {\n        \"method\": \"bolt11\",\n        \"unit\": \"usd\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"16/","title":"NUT-16: Animated QR codes","text":"<p><code>optional</code></p> <p>This document outlines how tokens should be displayed as QR codes for sending them between two wallets.</p>"},{"location":"16/#introduction","title":"Introduction","text":"<p>QR codes are a great way to send and receive Cashu tokens. Before a token can be shared as a QR code, it needs to be serialized (see NUT-00).</p>"},{"location":"16/#static-qr-codes","title":"Static QR codes","text":"<p>If the serialized token is not too large (i.e. includes less than or equal to 2 proofs) it can usually be shared as a static QR code. This might not be the case if the secret includes long scripts or the token has a long memo or mint URL.</p>"},{"location":"16/#animated-qr-codes","title":"Animated QR codes","text":"<p>If a token is too large to be displayed as a single QR code, we use animated QR codes are based on the UR protocol. The sender produces an animated QR code from a serialized Cashu token. The receiver scans the animated QR code until the UR decoder is able to decode the token.</p>"},{"location":"16/#resources","title":"Resources","text":"<ul> <li>Blockchain commons UR</li> <li>Typescript library bc-ur</li> </ul>"},{"location":"17/","title":"NUT-17: WebSockets","text":"<p><code>optional</code></p> <p><code>depends on: NUT-07</code></p> <p>This NUT defines a websocket protocol that enables bidirectional communication between apps and mints using the JSON-RPC format.</p>"},{"location":"17/#subscriptions","title":"Subscriptions","text":"<p>The websocket enables real-time subscriptions that wallets can use to receive notifications for a state change of a <code>MintQuoteResponse</code> (NUT-04), <code>MeltQuoteResponse</code> (NUT-05), <code>CheckStateResponse</code> (NUT-07).</p> <p>A summary of the subscription flow is the following:</p> <ol> <li>A wallet connects to the websocket endpoint and sends a <code>WsRequest</code> with the <code>subscribe</code> command.</li> <li>The mint responds with a <code>WsResponse</code> containing an ok or an error.</li> <li>If the subscription was accepted, the mint sends a <code>WsNotification</code> of the current state of the subscribed objects and whenever there is an update for the wallet's subscriptions.</li> <li>To close a subscription, the wallet sends <code>WsRequest</code> with the <code>unsubscribe</code> command.</li> </ol>"},{"location":"17/#specifications","title":"Specifications","text":"<p>The websocket is reachable via the mint's URL path <code>/v1/ws</code>:</p> <pre><code>https://mint.com/v1/ws\n</code></pre> <p><code>NUT-17</code> uses the JSON-RPC format for all messages. There are three types of messages defined in this NUT.</p>"},{"location":"17/#requests","title":"Requests","text":"<p>All requests from the wallet to the mint are of the form of a <code>WsRequest</code>:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": &lt;str_enum[WsRequestMethod]&gt;,\n  \"params\": &lt;str_WsRequestParams&gt;,\n  \"id\": &lt;int&gt;\n}\n</code></pre> <p><code>WsRequestMethod</code> is a enum of strings with the supported commands <code>\"subscribe\"</code> and <code>\"unsubscribe\"</code>:</p> <pre><code>enum WsRequestMethod {\n  sub = \"subscribe\",\n  unsub = \"unsubscribe\",\n}\n</code></pre> <p><code>WsRequestParams</code> is a serialized JSON with the parameters of the corresponding command.</p>"},{"location":"17/#command-subscribe","title":"Command: Subscribe","text":"<p>To subscribe to updates, the wallet sends a <code>\"subscribe\"</code> command with the following <code>params</code> parameters:</p> <pre><code>{\n  \"kind\": &lt;str_enum[SubscriptionKind]&gt;,\n  \"subId\": &lt;string&gt;,\n  \"filters\": &lt;string[]&gt;\n}\n</code></pre> <p>Here, <code>subId</code> is a unique uuid generated by the wallet and allows the client to map its requests to the mint's responses.</p> <p><code>SubscriptionKind</code> is an enum with the following possible values:</p> <pre><code>enum SubscriptionKind {\n  bolt11_melt_quote = \"bolt11_melt_quote\",\n  bolt11_mint_quote = \"bolt11_mint_quote\",\n  proof_state = \"proof_state\",\n}\n</code></pre> <p>The <code>filters</code> are an array of mint quote IDs (NUT-04), or melt quote IDs (NUT-05), or <code>Y</code>'s (NUT-07) of the corresponding object to receive updates from.</p> <p>As an example, <code>filters</code> would be of the following form to subscribe for updates of three different mint quote IDs:</p> <pre><code>[\"20385fc7245...\", \"d06667cda9b...\", \"e14d8ca96f...\"]\n</code></pre> <p>Note that <code>id</code> and <code>subId</code> are unrelated. The <code>subId</code> is the ID for each subscription, whereas <code>id</code> is part of the JSON-RPC spec and is an integer counter that must be incremented for every request sent over the websocket.</p> <p>Important: If the subscription is accepted by the mint, the mint MUST first respond with the current state of the subscribed object and continue sending any further updates to it.</p> <p>For example, if the wallet subscribes to a <code>Proof.Y</code> of a <code>Proof</code> that has not been spent yet, the mint will first respond with a <code>ProofState</code> with <code>state == \"UNSPENT\"</code>. If the wallet then spends this <code>Proof</code>, the mint would send a <code>ProofState</code> with <code>state == \"PENDING\"</code> and then one with <code>state == \"SPENT\"</code>. In total, the mint would send three notifications to the wallet.</p>"},{"location":"17/#command-unsubscribe","title":"Command: Unsubscribe","text":"<p>The wallet should always unsubscribe any subscriptions that is isn't interested in anymore. The parameters for the <code>\"unsubscribe\"</code> command is only the subscription ID:</p> <pre><code>{\n  \"subId\": &lt;string&gt;\n}\n</code></pre>"},{"location":"17/#responses","title":"Responses","text":"<p>A <code>WsResponse</code> is returned by the mint to both the <code>\"subscribe\"</code> and <code>\"unsubscribe\"</code> commands and indicates whether the request was successful:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"status\": \"OK\",\n    \"subId\": &lt;str&gt;\n  },\n  \"id\": &lt;int&gt;\n}\n</code></pre> <p>Here, the <code>id</code> corresponds to the <code>id</code> in the request (as part of the JSON-RPC spec) and <code>subId</code> corresponds to the subscription ID.</p>"},{"location":"17/#notifications","title":"Notifications","text":"<p><code>WsNotification</code>'s are sent from the mint to the wallet and contain subscription data in the following format</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subscribe\",\n  \"params\": {\n    \"subId\": &lt;str&gt;,\n    \"payload\": NotificationPayload\n  }\n}\n</code></pre> <p><code>subId</code> is the subscription ID (previously generated by the wallet) this notification corresponds to. <code>NotificationPayload</code> carries the subscription data which is a <code>MintQuoteResponse</code> (NUT-04), a <code>MeltQuoteResponse</code> (NUT-05), or a <code>CheckStateResponse</code> (NUT-07), depending on what the corresponding <code>SubscriptionKind</code> was.</p>"},{"location":"17/#errors","title":"Errors","text":"<p><code>WsErrors</code> for a given <code>WsRequest</code> are returned in the following format</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32601,\n    \"message\": \"Human readable error message\"\n  },\n  \"id\": \"1\"\n}\n</code></pre>"},{"location":"17/#example-proofstate-subscription","title":"Example: <code>ProofState</code> subscription","text":"<p>To subscribe to the <code>ProofState</code> of a <code>Proof</code>, the wallet establishes a websocket connection to <code>https://mint.com/v1/ws</code> and sends a <code>WsRequest</code> with a <code>filters</code> chosen to be the a <code>Proof.Y</code> value of the <code>Proof</code> (see NUT-00). Note that <code>filters</code> is an array meaning multiple subscriptions of the same <code>kind</code> can be made in the same request.</p> <p>Wallet:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"method\": \"subscribe\",\n  \"params\": {\n    \"kind\": \"proof_state\",\n    \"filters\": [\n      \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\"\n    ],\n    \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\"\n  }\n}\n</code></pre> <p>The mint first responds with a <code>WsResponse</code> confirming that the subscription has been added.</p> <p>Mint:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"status\": \"OK\",\n    \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\"\n  },\n  \"id\": 0\n}\n</code></pre> <p>The mint immediately sends the current <code>ProofState</code> of the subscription as a <code>WsNotification</code>.</p> <p>Mint:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subscribe\",\n  \"params\": {\n    \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\",\n    \"payload\": {\n      \"Y\": \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\",\n      \"state\": \"UNSPENT\",\n      \"witness\": null\n    }\n  }\n}\n</code></pre> <p>While leaving the websocket connection open, the wallet then spends the ecash. The mint sends <code>WsNotification</code> updating the wallet about state changes of the <code>ProofState</code> accordingly:</p> <p>Mint:</p> <pre><code>{\"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": {\"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\", \"payload\": {\"Y\": \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\", \"state\": \"PENDING\"}}}\n\n{\"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": {\"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\", \"payload\": {\"Y\": \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\", \"state\": \"SPENT\"}}}\n</code></pre> <p>The wallet then unsubscribes.</p> <p>Wallet:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"unsubscribe\",\n  \"params\": { \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\" }\n}\n</code></pre>"},{"location":"17/#mint-info-setting","title":"Mint info setting","text":"<p>Mints signal websocket support via NUT-06 using the following setting:</p> <pre><code>\"nuts\": {\n    \"17\": {\n      \"supported\": [\n        {\n          \"method\": &lt;str&gt;,\n          \"unit\": &lt;str&gt;,\n          \"commands\": &lt;str[]&gt;\n        },\n        ...\n      ]\n    }\n}\n</code></pre> <p>Here, <code>commands</code> is an array of the commands that the mint supports. A mint that supports all commands would return <code>[\"bolt11_mint_quote\", \"bolt11_melt_quote\", \"proof_state\"]</code>. Supported commands are given for each method-unit pair.</p> <p>Example:</p> <pre><code>\"nuts\": {\n    \"17\": {\n      \"supported\": [\n        {\n          \"method\": \"bolt11\",\n          \"unit\": \"sat\",\n          \"commands\": [\n            \"bolt11_mint_quote\",\n            \"bolt11_melt_quote\",\n            \"proof_state\"\n            ]\n        },\n      ]\n    }\n}\n</code></pre>"},{"location":"18/","title":"NUT-18: Payment Requests","text":"<p><code>optional</code></p> <p>This NUT introduces a standardised format for payment requests, that supply a sending wallet with all information necessary to complete the transaction. This enables many use-cases where a transaction is better initiated by the receiver (e.g. point of sale).</p>"},{"location":"18/#flow","title":"Flow","text":"<ol> <li>Receiver creates a payment request, encodes it and displays it to the sender</li> <li>Sender scans the request and constructs a matching token</li> <li>Sender sends the token according to the transport specified in the payment request</li> <li>Receiver receives the token and finalises the transaction</li> </ol>"},{"location":"18/#payment-request","title":"Payment Request","text":"<p>A Payment Request is defined as follows</p> <pre><code>{\n  \"i\": str &lt;optional&gt;,\n  \"a\": int &lt;optional&gt;,\n  \"u\": str &lt;optional&gt;,\n  \"s\": bool &lt;optional&gt;,\n  \"m\": Array[str] &lt;optional&gt;,\n  \"d\": str &lt;optional&gt;,\n  \"t\": Array[Transport]\n}\n</code></pre> <p>Here, the fields are</p> <ul> <li><code>i</code>: Payment id to be included in the payment payload</li> <li><code>a</code>: The amount of the requested payment</li> <li><code>u</code>: The unit of the requested payment (MUST be set if <code>a</code> is set)</li> <li><code>s</code>: Whether the payment request is for single use</li> <li><code>m</code>: A set of mints from which the payment is requested</li> <li><code>d</code>: A human readable description that the sending wallet will display after scanning the request</li> <li><code>t</code>: The method of <code>Transport</code> chosen to transmit the payment (can be multiple, sorted by preference)</li> </ul>"},{"location":"18/#transport","title":"Transport","text":"<p><code>Transport</code> specifies methods for sending the ecash to the receiver. A transport consists of a type and a target.</p> <pre><code>{\n  \"t\": str,\n  \"a\": str,\n  \"g\": Array[Array[str, str]] &lt;optional&gt;\n}\n</code></pre> <ul> <li><code>t</code>: type of Transport</li> <li><code>a</code>: target of Transport</li> <li><code>g</code>: optional tags for the Transport</li> </ul>"},{"location":"18/#tags","title":"Tags","text":"<p>Tags are an optional array of <code>[tag, value, value, ...]</code> tuples that can be used to specify additional features about the transport. A single tag can have multiple values.</p>"},{"location":"18/#transport-types","title":"Transport types","text":"<p>The supported transport types are described below.</p>"},{"location":"18/#nostr","title":"Nostr","text":"<ul> <li>type: <code>nostr</code></li> <li>target: <code>&lt;nprofile&gt;</code></li> <li>tags: <code>[[\"n\", \"17\"]]</code></li> </ul> <p>The <code>n</code> tag specifies the NIPs the receiver supports. At least one tag value MUST be specified. For NIP-17 direct messages, the sender sends a <code>PaymentRequestPayload</code> as the message content.</p>"},{"location":"18/#http-post","title":"HTTP POST","text":"<ul> <li>type: <code>post</code></li> <li>target: <code>&lt;endpoint url&gt;</code></li> </ul> <p>The execute the payment, the sender makes a <code>POST</code> request to the specified endpoint URL with the <code>PaymentRequestPayload</code> as the body.</p>"},{"location":"18/#payment-payload","title":"Payment payload","text":"<p>If not specified otherwise, the payload sent to the receiver is a <code>PaymentRequestPayload</code> JSON serialized object as follows:</p> <pre><code>{\n  \"id\": str &lt;optional&gt;,\n  \"memo\": str &lt;optional&gt;,\n  \"mint\": str,\n  \"unit\": &lt;str_enum&gt;,\n  \"proofs\": Array&lt;Proof&gt;\n}\n</code></pre> <p>Here, <code>id</code> is the payment id (corresponding to <code>i</code> in request), <code>memo</code> is an optional memo to be sent to the receiver with the payment, <code>mint</code> is the mint URL from which the ecash is from, <code>unit</code> is the unit of the payment, and <code>proofs</code> is an array of proofs (see NUT-00, can also include DLEQ proofs).</p>"},{"location":"18/#encoded-request","title":"Encoded Request","text":"<p>The payment request is serialized using CBOR, encoded in <code>base64_urlsafe</code>, together with a prefix <code>creq</code> and a version <code>A</code>:</p> <p><code>\"creq\" + \"A\" + base64(CBOR(PaymentRequest))</code></p>"},{"location":"18/#example","title":"Example","text":"<p>This is an example payment request expressed as JSON:</p> <pre><code>{\n  \"i\": \"b7a90176\",\n  \"a\": 10,\n  \"u\": \"sat\",\n  \"m\": [\"https://nofees.testnut.cashu.space\"],\n  \"t\": [\n    {\n      \"t\": \"nostr\",\n      \"a\": \"nprofile1qy28wumn8ghj7un9d3shjtnyv9kh2uewd9hsz9mhwden5te0wfjkccte9curxven9eehqctrv5hszrthwden5te0dehhxtnvdakqqgydaqy7curk439ykptkysv7udhdhu68sucm295akqefdehkf0d495cwunl5\",\n      \"g\": [[\"n\", \"17\"]]\n    }\n  ]\n}\n</code></pre> <p>This payment request serializes to (see here):</p> <pre><code>creqApWF0gaNhdGVub3N0cmFheKlucHJvZmlsZTFxeTI4d3VtbjhnaGo3dW45ZDNzaGp0bnl2OWtoMnVld2Q5aHN6OW1od2RlbjV0ZTB3ZmprY2N0ZTljdXJ4dmVuOWVlaHFjdHJ2NWhzenJ0aHdkZW41dGUwZGVoaHh0bnZkYWtxcWd5ZGFxeTdjdXJrNDM5eWtwdGt5c3Y3dWRoZGh1NjhzdWNtMjk1YWtxZWZkZWhrZjBkNDk1Y3d1bmw1YWeBgmFuYjE3YWloYjdhOTAxNzZhYQphdWNzYXRhbYF4Imh0dHBzOi8vbm9mZWVzLnRlc3RudXQuY2FzaHUuc3BhY2U=\n</code></pre>"},{"location":"19/","title":"NUT-19: Cached Responses","text":"<p><code>optional</code></p> <p>To minimize the risk of loss of funds to due network errors during critical operations such as minting, swapping, and melting, we introduce a caching mechanism for successful responses. This allows wallet to replay requests on cached endpoints and allow it to recover the desired state after a network interruption.</p>"},{"location":"19/#requests-responses","title":"Requests &amp; Responses","text":"<p>Any Mint implementation should elect a data structure <code>D</code> that maps request objects to their respective responses. <code>D</code> should be fit for fast insertion, look-up and deletion (eviction) operations. This could be an in-memory database or a dedicated caching service like Redis.</p>"},{"location":"19/#derive-repeat","title":"Derive &amp; Repeat","text":"<p>Upon receiving a <code>request</code> on a cached endpoint, the mint derives a unique key <code>k</code> for it which should depend on the method, path, and the payload of <code>request</code>.</p> <p>The mint uses <code>k</code> to look up a <code>response = D[k]</code> and discriminates execution based on the following checks:</p> <ul> <li>If no cached <code>response</code> is found: <code>request</code> has no matching <code>response</code>. The mint processes <code>request</code> as per usual.</li> <li>If a cached <code>response</code> is found: <code>request</code> has a matching <code>response</code>. The mint returns the cached <code>response</code>.</li> </ul>"},{"location":"19/#store","title":"Store","text":"<p>For each successful response on a cached endpoint (<code>status_code == 200</code>), the mint stores the response in <code>D</code> under key <code>k</code> (<code>D[k] = response</code>).</p>"},{"location":"19/#expiry","title":"Expiry","text":"<p>The mint decides the <code>ttl</code> (Time To Live) of cached response, after which it can evict the entry from <code>D</code>.</p>"},{"location":"19/#settings","title":"Settings","text":"<p>Support for NUT-19 is announced as an extension to the <code>nuts</code> field of the <code>GetInfoResponse</code> described in NUT-06.</p> <p>The entry is structured as follows:</p> <pre><code>\"nuts\": {\n    ...,\n    \"19\": {\n        \"ttl\": &lt;int|null&gt;,\n        \"cached_endpoints\": [\n            {\n                \"method\": \"POST\",\n                \"path\": \"/v1/mint/bolt11\",\n            },\n            {\n                \"method\": \"POST\",\n                \"path\": \"/v1/swap\",\n            },\n            ...\n        ]\n    }\n}\n</code></pre> <p>Where:</p> <ul> <li><code>ttl</code> is the number of seconds the responses are cached for</li> <li><code>cached_endpoints</code> is a list of the methods and paths for which caching is enabled.</li> <li><code>path</code> and <code>method</code> describe the cached route and its method respectively.</li> </ul> <p>If <code>ttl</code> is <code>null</code>, the responses are expected to be cached indefinitely.</p>"},{"location":"20/","title":"NUT-20: Signature on Mint Quote","text":"<p><code>optional</code></p> <p><code>depends on: NUT-04</code></p> <p>This NUT defines signature-based authentication for mint quote redemption. When requesting a mint quote, clients provide a public key. The mint will then require a valid signature from the corresponding secret key to process the mint operation.</p> <p>[!CAUTION]</p> <p>NUT-04 mint quotes without a public key can be minted by anyone who knows the mint quote id without providing a signature.</p>"},{"location":"20/#mint-quote","title":"Mint quote","text":"<p>To request a mint quote, the wallet of <code>Alice</code> makes a <code>POST /v1/mint/quote/{method}</code> request where <code>method</code> is the payment method requested. We present an example with the <code>method</code> being <code>bolt11</code> here.</p> <pre><code>POST https://mint.host:3338/v1/mint/quote/bolt11\n</code></pre> <p>The wallet of <code>Alice</code> includes the following <code>PostMintQuoteBolt11Request</code> data in its request:</p> <pre><code>{\n  \"amount\": &lt;int&gt;,\n  \"unit\": &lt;str_enum[\"sat\"]&gt;,\n  \"description\": &lt;str&gt;, // Optional\n  \"pubkey\": &lt;str&gt; // Optional &lt;-- New\n}\n</code></pre> <p>with the requested <code>amount</code>,<code>unit</code>, and <code>description</code> according to NUT-04.</p> <p><code>pubkey</code> is the public key that will be required for signature verification during the minting operation. The mint will only mint ecash after receiving a valid signature from the corresponding private key in the subsequent <code>PostMintRequest</code>.</p> <p>[!IMPORTANT]</p> <p>Privacy: To prevent the mint from being able to link multiple mint quotes, wallets SHOULD generate a unique public key for each mint quote request.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMintQuoteBolt11Response</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"request\": &lt;str&gt;,\n  \"state\": &lt;str_enum[STATE]&gt;,\n  \"expiry\": &lt;int&gt;,\n  \"pubkey\": &lt;str&gt; // Optional &lt;-- New\n}\n</code></pre> <p>The response is the same as in NUT-04 except for <code>pubkey</code> which has been provided by the wallet in the previous request.</p>"},{"location":"20/#example","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST http://localhost:3338/v1/mint/quote/bolt11 -d '{\"amount\": 10, \"unit\": \"sat\", \"pubkey\": \"03d56ce4e446a85bbdaa547b4ec2b073d40ff802831352b8272b7dd7a4de5a7cac\"}' -H \"Content-Type: application/json\"\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"quote\": \"9d745270-1405-46de-b5c5-e2762b4f5e00\",\n  \"request\": \"lnbc100n1pj4apw9...\",\n  \"state\": \"UNPAID\",\n  \"expiry\": 1701704757,\n  \"pubkey\": \"03d56ce4e446a85bbdaa547b4ec2b073d40ff802831352b8272b7dd7a4de5a7cac\"\n}\n</code></pre>"},{"location":"20/#signing-the-mint-request","title":"Signing the mint request","text":""},{"location":"20/#message-aggregation","title":"Message aggregation","text":"<p>To provide a signature for a mint request, the owner of the signing public keys must concatenate the quote ID <code>quote</code> in <code>PostMintQuoteBolt11Response</code> and the <code>B_</code> fields of all <code>BlindedMessages</code> in the <code>PostMintBolt11Request</code> (i.e., the outputs, see NUT-00) to a single message string in the order they appear in the <code>PostMintRequest</code>. This concatenated string is then hashed and signed (see Signature scheme).</p> <p>[!NOTE]</p> <p>Concatenating the quote ID and the outputs into a single message prevents maliciously replacing the outputs.</p> <p>If a request has <code>n</code> outputs, the message to sign becomes:</p> <pre><code>msg_to_sign =  quote || B_0 || ... || B_(n-1)\n</code></pre> <p>Where <code>||</code> denotes concatenation, <code>quote</code> is the UTF-8 quote id in <code>PostMintQuoteBolt11Response</code>, and each <code>B_n</code> is a UTF-8 encoded hex string of the outputs in the <code>PostMintBolt11Request</code>.</p>"},{"location":"20/#signature-scheme","title":"Signature scheme","text":"<p>To mint a quote where a public key was provided, the wallet includes a signature on <code>msg_to_sign</code> in the <code>PostMintBolt11Request</code>. We use a BIP340 Schnorr signature on the SHA-256 hash of the message to sign as defined above.</p>"},{"location":"20/#minting-tokens","title":"Minting tokens","text":"<p>After requesting a mint quote and paying the request, the wallet proceeds with minting new tokens by calling the <code>POST /v1/mint/{method}</code> endpoint where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/mint/bolt11\n</code></pre> <p>The wallet <code>Alice</code> includes the following <code>PostMintBolt11Request</code> data in its request</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"outputs\": &lt;Array[BlindedMessage]&gt;,\n  \"signature\": &lt;str|null&gt; &lt;-- New\n}\n</code></pre> <p>with the <code>quote</code> being the quote ID from the previous step and <code>outputs</code> being <code>BlindedMessages</code> as in NUT-04.</p> <p><code>signature</code> is the signature on the <code>msg_to_sign</code> which is the concatenated quote id and the outputs as defined above.</p> <p>The mint responds with a <code>PostMintBolt11Response</code> as in NUT-04 if all validations are successful.</p>"},{"location":"20/#example_1","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/mint/bolt11 -H \"Content-Type: application/json\" -d \\\n'{\n  \"quote\": \"9d745270-1405-46de-b5c5-e2762b4f5e00\",\n  \"outputs\": [\n    {\n      \"amount\": 8,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"035015e6d7ade60ba8426cefaf1832bbd27257636e44a76b922d78e79b47cb689d\"\n    },\n    {\n      \"amount\": 2,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"0288d7649652d0a83fc9c966c969fb217f15904431e61a44b14999fabc1b5d9ac6\"\n    }\n  ],\n  \"signature\": \"d9be080b33179387e504bb6991ea41ae0dd715e28b01ce9f63d57198a095bccc776874914288e6989e97ac9d255ac667c205fa8d90a211184b417b4ffdd24092\"\n\n}'\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"signatures\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 2,\n      \"C_\": \"0224f1c4c564230ad3d96c5033efdc425582397a5a7691d600202732edc6d4b1ec\"\n    },\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 8,\n      \"C_\": \"0277d1de806ed177007e5b94a8139343b6382e472c752a74e99949d511f7194f6c\"\n    }\n  ]\n}\n</code></pre>"},{"location":"20/#errors","title":"Errors","text":"<p>If the wallet user <code>Alice</code> does not include a signature on the <code>PostMintBolt11Request</code> but did include a <code>pubkey</code> in the <code>PostMintBolt11QuoteRequest</code> then <code>Bob</code> MUST respond with an error. <code>Alice</code> CAN repeat the request with a valid signature.</p> <p>See Error Codes:</p> <ul> <li><code>20008</code>: Mint quote with <code>pubkey</code> but no valid <code>signature</code> provided for mint request.</li> <li><code>20009</code>: Mint quote requires <code>pubkey</code> but none given or invalid <code>pubkey</code>.</li> </ul>"},{"location":"20/#settings","title":"Settings","text":"<p>The settings for this NUT indicate the support for requiring a signature before minting. They are part of the info response of the mint (NUT-06) which in this case reads</p> <pre><code>{\n  \"20\": {\n    \"supported\": &lt;bool&gt;,\n  }\n}\n</code></pre>"},{"location":"21/","title":"NUT-21: Clear Authentication","text":"<p><code>optional</code></p> <p><code>used in: NUT-22</code></p> <p>This NUT defines a clear authentication scheme that allows operators to limit the use of their mint to registered users using the OAuth 2.0 and OpenID Connect protocols. The mint operator can protect chosen endpoints from access by requiring user authentication. Only users that provide a clear authentication token (CAT) from the specified OpenID Connect (OIDC) service can use the protected endpoints. The CAT is an Oauth 2.0 Access token (also known as the <code>access_token</code>) commonly in the form of a JWT that contains user information, a signature from the OIDC service, and an expiry time. To access protected endpoints, the wallet includes the CAT in the HTTP request header.</p> <p>Note: The primary purpose of this NUT is to restrict access to a mint by allowing registered users to obtain Blind Authentication Tokens as specified in NUT-22.</p> <p>Warning: This authentication scheme breaks the user's privacy as the CAT contains user information. Mint operators SHOULD require clear authentication only on selected endpoints, such as those for obtaining blind authentication tokens (BATs, see NUT-22).</p>"},{"location":"21/#openid-connect-service-configuration","title":"OpenID Connect service configuration","text":"<p>The OpenID Connect (OIDC) service is typically run by the mint operator (but it does not have to be). The OIDC service must be configured to meet the following criteria:</p> <ul> <li>No client secret: The OIDC service MUST NOT use a client secret.</li> <li>Authorization code flow: The OIDC service MUST enable the authorization code flow with PKCE for public clients, so that an authorization code can be exchanged for an access token and a refresh token.</li> <li>Signature algorithm: The OIDC service MUST support at least one of the two asymmetric JWS signature algorithms for access token and ID token signatures: <code>ES256</code> and <code>RS256</code>.</li> <li>Wallet redirect URLs: To support the OpenID Connect Authorization Code flow, the OIDC service MUST allow redirect URLs that correspond to the wallets it wants to support. You can find a list of common redirect URLs for well-known Cashu wallets here.</li> <li>Localhost redirect URL: The OIDC service MUST also allow redirects to the URL <code>http://localhost:33388/callback</code>.</li> <li>Authentication flows: Although, strictly speaking, this NUT does not restrict the OpenID Connect grant types that can be used to obtain a CAT, it is recommended to enable at least the <code>authorization_code</code> (Authorization Code) flow and the <code>urn:ietf:params:oauth:grant-type:device_code</code> (Device Code) flow in the <code>grant_types_supported</code> field of the <code>openid_discovery</code> configuration. The <code>password</code> (Resource Owner Password Credentials, ROPC) flow SHOULD NOT be used as it requires handling the user's credentials in the wallet application.</li> </ul>"},{"location":"21/#mint","title":"Mint","text":""},{"location":"21/#signalling-protected-endpoints","title":"Signalling protected endpoints","text":"<p>The mint lists each protected endpoint that requires a clear authentication token (CAT) in the <code>MintClearAuthSetting</code> in its NUT-06 info response:</p> <pre><code>\"21\" : {\n  \"openid_discovery\": \"https://mint.com:8080/realms/nutshell/.well-known/openid-configuration\",\n  \"client_id\": \"cashu-client\",\n  \"protected_endpoints\": [\n    {\n        \"method\": \"POST\",\n        \"path\": \"/v1/auth/blind/mint\"\n    }\n  ]\n}\n</code></pre> <p><code>openid_discovery</code> is the OpenID Connect Discovery endpoint which has all the information necessary for a client to authenticate with the service. <code>client_id</code> is the OpenID Connect Client ID that the wallet needs to use to authenticate.</p> <p><code>protected_endpoints</code> is an array of objects that specify each endpoint that requires a CAT in the request headers. <code>method</code> is the HTTP method and <code>path</code> the path for the endpoint that is protected.</p> <p>The <code>path</code> can either be a string (exact match), such as <code>\"/v1/auth/blind/mint\"</code> or a regex pattern such as <code>\"^/v1/mint/quote/bolt11/.*\"</code>.</p> <p>In this example, the entry in <code>protected_endpoints</code> is the NUT-22 endpoint for obtaining blind authentication tokens (BATs).</p>"},{"location":"21/#clear-authentication-token-verification","title":"Clear authentication token verification","text":"<p>When receiving a request to a protected endpoint, the mint checks the included CAT (which is a JWT) in the HTTP request header (see below in section Wallet) and verifies the JWT. To verify the JWT, the mint checks the signature of the OIDC and the expiry of the JWT.</p> <p>The JWT includes a <code>sub</code> field which identifies a specific user. The <code>sub</code> identifier can, for example, be used to rate limit the user.</p> <p>Note: The JWT MAY include an audience field called <code>aud</code> that contains the mint's public key</p> <p>More on OpenID Connect ID token validation here.</p>"},{"location":"21/#wallet","title":"Wallet","text":"<p>To make a request to one of the <code>protected_endpoints</code> of the mint, the wallet needs to obtain a valid clear auth token (CAT) from the OIDC service. The wallet uses the <code>openid_discovery</code> URL in the <code>MintClearAuthSetting</code> from the info endpoint of the mint to authenticate with the OIDC service and obtain a CAT.</p>"},{"location":"21/#obtaining-a-cat","title":"Obtaining a CAT","text":"<p>Depending on the wallet implementation and use case, an appropriate authorization flow should be used. For mobile wallets, the Authorization Code is recommended. For command-line wallets, the Device Code flow is recommended. For headless wallets, the ROPC flow may be used.</p> <p>It is recommended to use language-specific libraries that can handle OpenID Connect authentication on behalf of the user. The wallet should be able to handle and store access tokens and refresh tokens for each mint that it authenticates with. If the wallet connects to a mint for the first time, or if the refresh token is about to expire, the wallet should allow the user to log in again to obtain a new access token (<code>access_token</code>) and a new refresh token (<code>refresh_token</code>).</p> <p>The <code>access_token</code> is what is referred to as a clear authentication token (CAT) throughout this document.</p>"},{"location":"21/#cat-in-request-header","title":"CAT in request header","text":"<p>When making a request to the mint's endpoint, the wallet matches the requested URL with the <code>protected_endpoints</code> from the <code>MintClearAuthSetting</code> (either exact match or regex pattern match). If the match is positive, the mint requires the wallet to provide a CAT with the request.</p> <p>After obtaining a CAT from the OIDC service, the wallet includes a valid CAT in the HTTP request header when it makes requests to one of the mint's <code>protected_endpoints</code>:</p> <pre><code>Clear-auth: &lt;CAT&gt;\n</code></pre> <p>The <code>CAT</code> is a JWT (or <code>access_token</code>) encoded with base64 that is signed by and obtained from the OIDC authority. The mint verifies the JWT as described above.</p>"},{"location":"21/#error-codes","title":"Error codes","text":"<p>See Error Codes:</p> <ul> <li><code>30001</code>: Endpoint requires clear auth</li> <li><code>30002</code>: Clear authentication failed</li> </ul>"},{"location":"22/","title":"NUT-22: Blind Authentication","text":"<p><code>optional</code></p> <p><code>depends on: NUT-21</code></p> <p>This NUT defines a blind authentication scheme that allows mint operators to limit the use of their mint to a set of authorized users while still providing privacy within that anonymity set.</p> <p>We use two authentication schemes in conjunction: clear authentication using an external OpenID Connect / OAuth 2.0 service (described in NUT-21), and blind authentication with the mint to access its resources. A user's wallet first needs to obtain a clear authentication token (CAT) from an OpenID Connect authority that the mint selected, which is not subject of this specification. Once the user has obtained the CAT from the OpenID Connect service, they can use it to obtain multiple blind authentication tokens (BAT) from the mint. We describe this process in this document.</p> <p>Blind authentication tokens (BATs) are used to access the protected endpoints of the mint and make sure that only users that previously presented a valid CAT can access the mint's features such as minting, melting, or swapping ecash. Wallets provide a BAT in the request header when making a request to one of the mint's protected endpoints. The mint parses the header for a BAT, verifies the signature (like with normal ecash as described in NUT-00), checks if the token has previously been spent, and if not, adds it to its spent BAT token database.</p>"},{"location":"22/#blind-authentication-tokens-are-ecash","title":"Blind authentication tokens are ecash","text":"<p>Blind authentication tokens (BATs) are essentially the same as normal ecash tokens and are minted in the same way. They are signed with a special keyset of the mint that has the unit <code>auth</code> and a single amount <code>1</code>.</p> <p>BATs can only be used a single time for each request that the wallet makes to the mint's protected endpoints. After each for each successful request, the BAT is added to the mint's spent token list after which they are regarded as spent. The BAT is not marked as spent if the request results in an error.</p> <p>To summarize:</p> <ul> <li>Wallet connects to mint and user is prompted to register or log in with an OAuth 2.0 service</li> <li>Upon login, wallet receives a clear authentication (CAT) token that identifies the user</li> <li>CAT is used to obtain blind authentication tokens (BAT) from the mint</li> <li>BATs are used to access the mint</li> </ul> <p>The diagram below illustrates the protocol flow.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502  User  \u2502                     \u2502  Mint  \u2502                  \u2502   OpenID  \u2502 \u2502\n\u251c\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2524\n\u2502                                                                          \u2502\n\u2502                           1. Clear authentication                        \u2502\n\u2502                           =======================                        \u2502\n\u2502                                                                          \u2502\n\u2502                                       Mint registers OpenID service      \u2502\n\u2502                                     \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500     \u2502\n\u2502                                                                          \u2502\n\u2502           Wallet GET /v1/info                                            \u2502\n\u2502    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba                                    \u2502\n\u2502                                                                          \u2502\n\u2502                                OpenID login                              \u2502\n\u2502    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba     \u2502\n\u2502                                                                          \u2502\n\u2502                              Respond with CAT                            \u2502\n\u2502    \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500     \u2502\n\u2502                                                                          \u2502\n\u2502                           2. Blind authentication                        \u2502\n\u2502                           =======================                        \u2502\n\u2502                                                                          \u2502\n\u2502           Request BAT using CAT                                          \u2502\n\u2502    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba                                    \u2502\n\u2502                                                                          \u2502\n\u2502                Return BAT                                                \u2502\n\u2502    \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                    \u2502\n\u2502                                                                          \u2502\n\u2502           Use BAT to access mint                                         \u2502\n\u2502    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba                                    \u2502\n\u2502                                                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The steps for <code>1. Clear authentication</code> are described in NUT-21, whereas the steps in <code>2. Blind authentication</code> are subject of this document.</p>"},{"location":"22/#endpoints","title":"Endpoints","text":"<p>The mint offers new endpoints that behave similarly to the endpoints for getting the keys, keysets, and minting tokens with normal ecash (NUT-01, NUT-02, NUT-04). These endpoints start with a prefix <code>/v1/auth/</code> to differentiate them from the normal endpoints of the mint. Using these endpoints, wallets can mint blind authentication tokens (BATs) and use them later when accessing the protected endpoints of the mint. Note that BATs cannot be swapped against other BATs.</p>"},{"location":"22/#keys","title":"Keys","text":"<p>Like in NUT-01 and NUT-02, the mint responds with its BAT keyset for the following request:</p> <pre><code>GET /v1/auth/blind/keys\n</code></pre> <p>or</p> <pre><code>GET /v1/auth/blind/keys/{keyset_id}\n</code></pre> <p>where the mint returns a <code>GetKeysResponse</code>:</p> <pre><code>{\n  \"keysets\": [\n    {\n      \"id\": \"000e479673849bf6\",\n      \"unit\": \"auth\",\n      \"keys\": {\n        \"1\": \"024ec000e31e230e4c59760def29601557c0b1650617dc8f38d3b2cfd21ad0351b\"\n      }\n    }\n  ]\n}\n</code></pre> <p>Notice that the unit is <code>auth</code> and only a single amount of <code>1</code> is supported.</p>"},{"location":"22/#keysets","title":"Keysets","text":"<p>Like in NUT-02 the mint also offers the endpoints returning the keysets:</p> <pre><code>GET v1/auth/blind/keysets\n</code></pre> <p>The mint returns the same <code>GetKeysetsResponse</code> response types as described in NUT-02.</p>"},{"location":"22/#minting-blind-authentication-tokens","title":"Minting blind authentication tokens","text":"<p>To mint blind authentication tokens (BATs), the wallet makes a request to the following endpoint:</p> <pre><code>POST /v1/auth/blind/mint\n</code></pre> <p>To access this endpoint the wallet MUST provide a valid CAT (obtained via NUT-21) in its request header, IF this endpoint is marked as protected in the info response of the mint as per NUT-21.</p> <pre><code>Clear-auth: &lt;CAT&gt;\n</code></pre> <p>Like in NUT-04, the wallet includes a <code>PostAuthBlindMintRequest</code> in the request body:</p> <pre><code>{\n  \"outputs\": &lt;Array[BlindedMessage]&gt;\n}\n</code></pre> <p>where <code>outputs</code> are <code>BlindedMessages</code> (see NUT-00) from the blind auth keyset of the mint with a unit <code>amount</code>. The sum of all amounts of the outputs cannot exceed the maximum allowed amount of BATs as specified in <code>bat_max_mint</code> in the mint's <code>MintBlindAuthSetting</code>.</p> <p>Notice that in contrast to NUT-04, we did not create a quote and did not include it in this request. Instead, we directly minted the maximum allowed amount of BATs.</p> <p>The mint responds with a <code>PostAuthBlindMintResponse</code>:</p> <pre><code>{\n  \"signatures\": &lt;Array[BlindSignature]&gt;\n}\n</code></pre> <p>The wallet un-blinds the response to obtain the signatures <code>C</code> as described in NUT-00. It then stores the resulting <code>AuthProofs</code> in its database:</p> <pre><code>{\n  \"id\": hex_str,\n  \"secret\": str,\n  \"C\": hex_str\n}\n</code></pre>"},{"location":"22/#using-blind-authentication-tokens","title":"Using blind authentication tokens","text":"<p>The wallet checks the <code>MintBlindAuthSetting</code> of the mint to determine which endpoints require blind authentication. Similar to <code>NUT-21</code>, the wallet performs a match on the <code>protected_endpoints</code> in the <code>MintBlindAuthSetting</code> before attempting a request to one of the mint's endpoints. If the match is positive, the wallet needs to add a blind authentication token (BAT) to the request header.</p>"},{"location":"22/#serialization","title":"Serialization","text":"<p>To add a blind authentication token (BAT) to the request header, we need to serialize a single <code>AuthProof</code> JSON in base64 with the prefix <code>authA</code>:</p> <pre><code>authA[base64_authproof_json]\n</code></pre> <p>This string is a BAT.</p>"},{"location":"22/#request-header","title":"Request header","text":"<p>We add this serialized BAT to the request header:</p> <pre><code>Blind-auth: &lt;BAT&gt;\n</code></pre> <p>and make the request as we usually would.</p> <p><code>AuthProofs</code> are single-use. The wallet MUST delete the <code>AuthProof</code> after a successful request, and SHOULD delete it even if request results in an error. If the wallet runs out of <code>AuthProofs</code>, it can mint new ones using its clear authentication token (CAT).</p>"},{"location":"22/#mint","title":"Mint","text":""},{"location":"22/#signaling-protected-endpoints-and-settings","title":"Signaling protected endpoints and settings","text":"<p>The mint lists each protected endpoint that requires a blind authentication token (BAT) in the <code>MintBlindAuthSetting</code> in its NUT-06 info response:</p> <pre><code>\"22\" : {\n  \"bat_max_mint\": 50,\n  \"protected_endpoints\": [\n    {\n      \"method\": \"GET\",\n      \"path\": \"^/v1/mint/.*\"\n    },\n    {\n      \"method\": \"POST\",\n      \"path\": \"^/v1/mint/.*\"\n    }\n  ]\n}\n</code></pre> <p><code>bat_max_mint</code> is the number of blind authentication tokens (BATs) that can be minted in a single request using the <code>POST /v1/auth/blind/mint</code> endpoint.</p> <p><code>protected_endpoints</code> contains the endpoints that are protected by blind authentication. <code>method</code> denotes the HTTP method of the endpoint, and <code>path</code> is a regex pattern that must match the path of the URL. In this example, all <code>/v1/mint/*</code> endpoints are protected and require blind authentication. <code>path</code> entries without regex pattern are required to match exactly.</p>"},{"location":"22/#error-codes","title":"Error codes","text":"<p>See Error Codes:</p> <ul> <li><code>31001</code>: Endpoint requires blind auth</li> <li><code>31002</code>: Blind authentication failed</li> <li><code>31003</code>: Maximum BAT mint amount exceeded</li> <li><code>31004</code>: BAT mint rate limit exceeded</li> </ul>"},{"location":"error_codes/","title":"NUT Errors","text":"Code Description Relevant nuts 10002 Blinded message of output already signed NUT-03, NUT-04, NUT-05 10003 Token could not be verified NUT-03, NUT-05 11001 Token is already spent NUT-03, NUT-05 11002 Transaction is not balanced (inputs != outputs) NUT-02, NUT-03, NUT-05 11005 Unit in request is not supported NUT-04, NUT-05 11006 Amount outside of limit range NUT-04, NUT-05 12001 Keyset is not known NUT-02, NUT-04 12002 Keyset is inactive, cannot sign messages NUT-02, NUT-03, NUT-04 20001 Quote request is not paid NUT-04 20002 Tokens have already been issued for quote NUT-04 20003 Minting is disabled NUT-04 20005 Quote is pending NUT-04, NUT-05 20006 Invoice already paid NUT-05 20007 Quote is expired NUT-04, NUT-05 20008 Signature for mint request invalid NUT-20 20009 Pubkey required for mint quote NUT-20 30001 Endpoint requires clear auth NUT-21 30002 Clear authentication failed NUT-21 31001 Endpoint requires blind auth NUT-22 31002 Blind authentication failed NUT-22 31003 Maximum BAT mint amount exceeded NUT-22 31004 BAT mint rate limit exceeded NUT-22"},{"location":"suppl/","title":"Index","text":""},{"location":"suppl/#supplementary-material","title":"Supplementary Material","text":"<p>This directory contains supplementary material for some specifications in the parent directory.</p>"},{"location":"suppl/21/","title":"NUT-XX-SUPPL: Clear Authentication","text":"<p><code>for: NUT-XX</code></p> <p>Well-known Cashu wallet redirect URLs for the OpenID Connect Authorization Code flow:</p> Wallet Redirect URL Cashu.me <code>https://wallet.cashu.me/callback</code>"},{"location":"tests/","title":"Test Vectors","text":"<p>The files in this directory contain test vectors for NUTs that warrant them.</p>"},{"location":"tests/00-tests/","title":"NUT-00 Test Vectors","text":""},{"location":"tests/00-tests/#hash-to-curve-function","title":"Hash-to-curve function","text":"<p>The hash to curve function takes a message of any length and outputs a valid point on the secp256k1 curve. Note that unless you are using complex spend conditions (NUT-10), standardized secrets (random 32-bytes-long byte arrays) should be used in order to prevent wallet fingerprinting.</p> <pre><code># Test 1 (hex encoded)\nMessage: 0000000000000000000000000000000000000000000000000000000000000000\nPoint:   024cce997d3b518f739663b757deaec95bcd9473c30a14ac2fd04023a739d1a725\n\n# Test 2 (hex encoded)\nMessage: 0000000000000000000000000000000000000000000000000000000000000001\nPoint:   022e7158e11c9506f1aa4248bf531298daa7febd6194f003edcd9b93ade6253acf\n\n# Test 3 (hex encoded)\n# Note that this message will take a few iterations of the loop before finding a valid point\nMessage: 0000000000000000000000000000000000000000000000000000000000000002\nPoint:   026cdbe15362df59cd1dd3c9c11de8aedac2106eca69236ecd9fbe117af897be4f\n</code></pre>"},{"location":"tests/00-tests/#blinded-messages","title":"Blinded messages","text":"<p>These are test vectors for the the blinded secret (public key) <code>B_</code> Alice sends to the mint Bob given a secret <code>x</code> and a random blinding factor <code>r</code>.</p> <pre><code># Test 1\nx:  d341ee4871f1f889041e63cf0d3823c713eea6aff01e80f1719f08f9e5be98f6   # hex encoded byte array\nr:  99fce58439fc37412ab3468b73db0569322588f62fb3a49182d67e23d877824a   # hex encoded private key\nB_: 033b1a9737a40cc3fd9b6af4b723632b76a67a36782596304612a6c2bfb5197e6d # hex encoded public key\n\n# Test 2\nx:  f1aaf16c2239746f369572c0784d9dd3d032d952c2d992175873fb58fae31a60   # hex encoded byte array\nr:  f78476ea7cc9ade20f9e05e58a804cf19533f03ea805ece5fee88c8e2874ba50   # hex encoded private key\nB_: 029bdf2d716ee366eddf599ba252786c1033f47e230248a4612a5670ab931f1763 # hex encoded public key\n</code></pre>"},{"location":"tests/00-tests/#blinded-signatures","title":"Blinded signatures","text":"<p>These are test vectors for the blinded key <code>C_</code> given the mint's private key <code>k</code> and Alice's blinded message containing <code>B_</code>.</p> <pre><code># Test 1\nmint private key: 0000000000000000000000000000000000000000000000000000000000000001\nB_: 02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\nC_: 02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\n\n# Test 2\nmint private key: 7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\nB_: 02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\nC_: 0398bc70ce8184d27ba89834d19f5199c84443c31131e48d3c1214db24247d005d\n</code></pre>"},{"location":"tests/00-tests/#serialization-of-tokenv3","title":"Serialization of TokenV3","text":"<p>The following are JSON-formatted v3 tokens and their serialized counterparts.</p> <pre><code>{\n  \"token\": [\n    {\n      \"mint\": \"https://8333.space:3338\",\n      \"proofs\": [\n        {\n          \"amount\": 2,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n          \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n        },\n        {\n          \"amount\": 8,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be\",\n          \"C\": \"029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059\"\n        }\n      ]\n    }\n  ],\n  \"unit\": \"sat\",\n  \"memo\": \"Thank you.\"\n}\n</code></pre> <p>Serialized:</p> <pre><code>cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre>"},{"location":"tests/00-tests/#deserialization-of-tokenv3","title":"Deserialization of TokenV3","text":"<p>The following are incorrectly formatted serialized v3 tokens.</p> <pre><code># Incorrect prefix (casshuA)\ncasshuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n\n# No prefix\neyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre> <p>The following is a correctly serialized v3 token.</p> <pre><code>cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre> <p>Both of the following v3 tokens are valid, one includes padding characters at the end and the other does not.</p> <pre><code># Clients should be able to deserialize both\ncashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91IHZlcnkgbXVjaC4ifQ==\ncashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91IHZlcnkgbXVjaC4ifQ\n</code></pre>"},{"location":"tests/00-tests/#serialization-of-tokenv4","title":"Serialization of TokenV4","text":"<p>The following are JSON-formatted v4 tokens and their serialized counterparts. The <code>h''</code> values are <code>bytes</code> but displayed as hex strings here.</p>"},{"location":"tests/00-tests/#single-keyset","title":"Single keyset","text":"<p>Token from a single keyset and including a memo.</p> <pre><code>{\n    \"t\": [\n        {\n            \"i\": h'00ad268c4d1f5826',\n            \"p\": [\n                {\n                    \"a\": 1,\n                    \"s\": \"9a6dbb847bd232ba76db0df197216b29d3b8cc14553cd27827fc1cc942fedb4e\",\n                    \"c\": h'038618543ffb6b8695df4ad4babcde92a34a96bdcd97dcee0d7ccf98d472126792',\n                },\n            ],\n        },\n    ],\n    \"d\": \"Thank you\",\n    \"m\": \"http://localhost:3338\",\n    \"u\": \"sat\",\n}\n</code></pre> <p>Encoded:</p> <pre><code>cashuBpGF0gaJhaUgArSaMTR9YJmFwgaNhYQFhc3hAOWE2ZGJiODQ3YmQyMzJiYTc2ZGIwZGYxOTcyMTZiMjlkM2I4Y2MxNDU1M2NkMjc4MjdmYzFjYzk0MmZlZGI0ZWFjWCEDhhhUP_trhpXfStS6vN6So0qWvc2X3O4NfM-Y1HISZ5JhZGlUaGFuayB5b3VhbXVodHRwOi8vbG9jYWxob3N0OjMzMzhhdWNzYXQ=\n</code></pre>"},{"location":"tests/00-tests/#multiple-keysets","title":"Multiple keysets","text":"<p>The token below includes proofs from two different keysets.</p> <pre><code>{\n    \"t\": [\n        {\n            \"i\": h'00ffd48b8f5ecf80',\n            \"p\": [\n                {\n                    \"a\": 1,\n                    \"s\": \"acc12435e7b8484c3cf1850149218af90f716a52bf4a5ed347e48ecc13f77388\",\n                    \"c\": h'0244538319de485d55bed3b29a642bee5879375ab9e7a620e11e48ba482421f3cf',\n                },\n            ],\n        },\n        {\n            \"i\": h'00ad268c4d1f5826',\n            \"p\": [\n                {\n                    \"a\": 2,\n                    \"s\": \"1323d3d4707a58ad2e23ada4e9f1f49f5a5b4ac7b708eb0d61f738f48307e8ee\",\n                    \"c\": h'023456aa110d84b4ac747aebd82c3b005aca50bf457ebd5737a4414fac3ae7d94d',\n                },\n                {\n                    \"a\": 1,\n                    \"s\": \"56bcbcbb7cc6406b3fa5d57d2174f4eff8b4402b176926d3a57d3c3dcbb59d57\",\n                    \"c\": h'0273129c5719e599379a974a626363c333c56cafc0e6d01abe46d5808280789c63',\n                },\n            ],\n        },\n    ],\n    \"m\": \"http://localhost:3338\",\n    \"u\": \"sat\",\n}\n</code></pre> <p>Serialized:</p> <pre><code>cashuBo2F0gqJhaUgA_9SLj17PgGFwgaNhYQFhc3hAYWNjMTI0MzVlN2I4NDg0YzNjZjE4NTAxNDkyMThhZjkwZjcxNmE1MmJmNGE1ZWQzNDdlNDhlY2MxM2Y3NzM4OGFjWCECRFODGd5IXVW-07KaZCvuWHk3WrnnpiDhHki6SCQh88-iYWlIAK0mjE0fWCZhcIKjYWECYXN4QDEzMjNkM2Q0NzA3YTU4YWQyZTIzYWRhNGU5ZjFmNDlmNWE1YjRhYzdiNzA4ZWIwZDYxZjczOGY0ODMwN2U4ZWVhY1ghAjRWqhENhLSsdHrr2Cw7AFrKUL9Ffr1XN6RBT6w659lNo2FhAWFzeEA1NmJjYmNiYjdjYzY0MDZiM2ZhNWQ1N2QyMTc0ZjRlZmY4YjQ0MDJiMTc2OTI2ZDNhNTdkM2MzZGNiYjU5ZDU3YWNYIQJzEpxXGeWZN5qXSmJjY8MzxWyvwObQGr5G1YCCgHicY2FtdWh0dHA6Ly9sb2NhbGhvc3Q6MzMzOGF1Y3NhdA\n</code></pre>"},{"location":"tests/00-tests/#raw-token-serialization","title":"Raw Token Serialization","text":""},{"location":"tests/00-tests/#tokenv4","title":"TokenV4","text":"<p>What follows is a TokenV4 Token serialized in its raw binary form. <code>h''</code> values are bytes in hex notation.</p> <p>Token:</p> <pre><code>{\n    \"t\": [\n        {\n            \"i\": h'00ad268c4d1f5826',\n            \"p\": [\n                {\n                    \"a\": 1,\n                    \"s\": \"9a6dbb847bd232ba76db0df197216b29d3b8cc14553cd27827fc1cc942fedb4e\",\n                    \"c\": h'038618543ffb6b8695df4ad4babcde92a34a96bdcd97dcee0d7ccf98d472126792',\n                },\n            ],\n        },\n    ],\n    \"d\": \"Thank you\",\n    \"m\": \"http://localhost:3338\",\n    \"u\": \"sat\",\n}\n</code></pre> <p>Serialized to raw binary:</p> <p><code>h'6372617742a4617481a261694800ad268c4d1f5826617081a3616101617378403961366462623834376264323332626137366462306466313937323136623239643362386363313435353363643237383237666331636339343266656462346561635821038618543ffb6b8695df4ad4babcde92a34a96bdcd97dcee0d7ccf98d4721267926164695468616e6b20796f75616d75687474703a2f2f6c6f63616c686f73743a33333338617563736174'</code></p>"},{"location":"tests/01-tests/","title":"NUT-01 Test Vectors","text":"<p>The following are incorrect keysets that should be rejected by wallets implementing the NUT-01 specification.</p> <p>Key 1 is missing a byte</p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38\",\n  \"2\": \"03fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <p>Key 2 is a valid key but is not in the compressed format.</p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38bc\",\n  \"2\": \"04fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de3625246cb2c27dac965cb7200a5986467eee92eb7d496bbf1453b074e223e481\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <p>The following are correct keysets that should be accepted by wallets implementing the NUT-01 specification. Note that the second (bigger) keyset's biggest amount is <code>9223372036854775808</code>, one unit over what can fit into a 64-bit signed integer (often known as a <code>Long</code>). To handle this you'll need to use either an unsigned 64-bit integer or a 128-bit signed integer (sometimes known as a <code>BigInteger</code>).</p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38bc\",\n  \"2\": \"03fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <pre><code>{\n  \"1\": \"03ba786a2c0745f8c30e490288acd7a72dd53d65afd292ddefa326a4a3fa14c566\",\n  \"2\": \"03361cd8bd1329fea797a6add1cf1990ffcf2270ceb9fc81eeee0e8e9c1bd0cdf5\",\n  \"4\": \"036e378bcf78738ddf68859293c69778035740e41138ab183c94f8fee7572214c7\",\n  \"8\": \"03909d73beaf28edfb283dbeb8da321afd40651e8902fcf5454ecc7d69788626c0\",\n  \"16\": \"028a36f0e6638ea7466665fe174d958212723019ec08f9ce6898d897f88e68aa5d\",\n  \"32\": \"03a97a40e146adee2687ac60c2ba2586a90f970de92a9d0e6cae5a4b9965f54612\",\n  \"64\": \"03ce86f0c197aab181ddba0cfc5c5576e11dfd5164d9f3d4a3fc3ffbbf2e069664\",\n  \"128\": \"0284f2c06d938a6f78794814c687560a0aabab19fe5e6f30ede38e113b132a3cb9\",\n  \"256\": \"03b99f475b68e5b4c0ba809cdecaae64eade2d9787aa123206f91cd61f76c01459\",\n  \"512\": \"03d4db82ea19a44d35274de51f78af0a710925fe7d9e03620b84e3e9976e3ac2eb\",\n  \"1024\": \"031fbd4ba801870871d46cf62228a1b748905ebc07d3b210daf48de229e683f2dc\",\n  \"2048\": \"0276cedb9a3b160db6a158ad4e468d2437f021293204b3cd4bf6247970d8aff54b\",\n  \"4096\": \"02fc6b89b403ee9eb8a7ed457cd3973638080d6e04ca8af7307c965c166b555ea2\",\n  \"8192\": \"0320265583e916d3a305f0d2687fcf2cd4e3cd03a16ea8261fda309c3ec5721e21\",\n  \"16384\": \"036e41de58fdff3cb1d8d713f48c63bc61fa3b3e1631495a444d178363c0d2ed50\",\n  \"32768\": \"0365438f613f19696264300b069d1dad93f0c60a37536b72a8ab7c7366a5ee6c04\",\n  \"65536\": \"02408426cfb6fc86341bac79624ba8708a4376b2d92debdf4134813f866eb57a8d\",\n  \"131072\": \"031063e9f11c94dc778c473e968966eac0e70b7145213fbaff5f7a007e71c65f41\",\n  \"262144\": \"02f2a3e808f9cd168ec71b7f328258d0c1dda250659c1aced14c7f5cf05aab4328\",\n  \"524288\": \"038ac10de9f1ff9395903bb73077e94dbf91e9ef98fd77d9a2debc5f74c575bc86\",\n  \"1048576\": \"0203eaee4db749b0fc7c49870d082024b2c31d889f9bc3b32473d4f1dfa3625788\",\n  \"2097152\": \"033cdb9d36e1e82ae652b7b6a08e0204569ec7ff9ebf85d80a02786dc7fe00b04c\",\n  \"4194304\": \"02c8b73f4e3a470ae05e5f2fe39984d41e9f6ae7be9f3b09c9ac31292e403ac512\",\n  \"8388608\": \"025bbe0cfce8a1f4fbd7f3a0d4a09cb6badd73ef61829dc827aa8a98c270bc25b0\",\n  \"16777216\": \"037eec3d1651a30a90182d9287a5c51386fe35d4a96839cf7969c6e2a03db1fc21\",\n  \"33554432\": \"03280576b81a04e6abd7197f305506476f5751356b7643988495ca5c3e14e5c262\",\n  \"67108864\": \"03268bfb05be1dbb33ab6e7e00e438373ca2c9b9abc018fdb452d0e1a0935e10d3\",\n  \"134217728\": \"02573b68784ceba9617bbcc7c9487836d296aa7c628c3199173a841e7a19798020\",\n  \"268435456\": \"0234076b6e70f7fbf755d2227ecc8d8169d662518ee3a1401f729e2a12ccb2b276\",\n  \"536870912\": \"03015bd88961e2a466a2163bd4248d1d2b42c7c58a157e594785e7eb34d880efc9\",\n  \"1073741824\": \"02c9b076d08f9020ebee49ac8ba2610b404d4e553a4f800150ceb539e9421aaeee\",\n  \"2147483648\": \"034d592f4c366afddc919a509600af81b489a03caf4f7517c2b3f4f2b558f9a41a\",\n  \"4294967296\": \"037c09ecb66da082981e4cbdb1ac65c0eb631fc75d85bed13efb2c6364148879b5\",\n  \"8589934592\": \"02b4ebb0dda3b9ad83b39e2e31024b777cc0ac205a96b9a6cfab3edea2912ed1b3\",\n  \"17179869184\": \"026cc4dacdced45e63f6e4f62edbc5779ccd802e7fabb82d5123db879b636176e9\",\n  \"34359738368\": \"02b2cee01b7d8e90180254459b8f09bbea9aad34c3a2fd98c85517ecfc9805af75\",\n  \"68719476736\": \"037a0c0d564540fc574b8bfa0253cca987b75466e44b295ed59f6f8bd41aace754\",\n  \"137438953472\": \"021df6585cae9b9ca431318a713fd73dbb76b3ef5667957e8633bca8aaa7214fb6\",\n  \"274877906944\": \"02b8f53dde126f8c85fa5bb6061c0be5aca90984ce9b902966941caf963648d53a\",\n  \"549755813888\": \"029cc8af2840d59f1d8761779b2496623c82c64be8e15f9ab577c657c6dd453785\",\n  \"1099511627776\": \"03e446fdb84fad492ff3a25fc1046fb9a93a5b262ebcd0151caa442ea28959a38a\",\n  \"2199023255552\": \"02d6b25bd4ab599dd0818c55f75702fde603c93f259222001246569018842d3258\",\n  \"4398046511104\": \"03397b522bb4e156ec3952d3f048e5a986c20a00718e5e52cd5718466bf494156a\",\n  \"8796093022208\": \"02d1fb9e78262b5d7d74028073075b80bb5ab281edcfc3191061962c1346340f1e\",\n  \"17592186044416\": \"030d3f2ad7a4ca115712ff7f140434f802b19a4c9b2dd1c76f3e8e80c05c6a9310\",\n  \"35184372088832\": \"03e325b691f292e1dfb151c3fb7cad440b225795583c32e24e10635a80e4221c06\",\n  \"70368744177664\": \"03bee8f64d88de3dee21d61f89efa32933da51152ddbd67466bef815e9f93f8fd1\",\n  \"140737488355328\": \"0327244c9019a4892e1f04ba3bf95fe43b327479e2d57c25979446cc508cd379ed\",\n  \"281474976710656\": \"02fb58522cd662f2f8b042f8161caae6e45de98283f74d4e99f19b0ea85e08a56d\",\n  \"562949953421312\": \"02adde4b466a9d7e59386b6a701a39717c53f30c4810613c1b55e6b6da43b7bc9a\",\n  \"1125899906842624\": \"038eeda11f78ce05c774f30e393cda075192b890d68590813ff46362548528dca9\",\n  \"2251799813685248\": \"02ec13e0058b196db80f7079d329333b330dc30c000dbdd7397cbbc5a37a664c4f\",\n  \"4503599627370496\": \"02d2d162db63675bd04f7d56df04508840f41e2ad87312a3c93041b494efe80a73\",\n  \"9007199254740992\": \"0356969d6aef2bb40121dbd07c68b6102339f4ea8e674a9008bb69506795998f49\",\n  \"18014398509481984\": \"02f4e667567ebb9f4e6e180a4113bb071c48855f657766bb5e9c776a880335d1d6\",\n  \"36028797018963968\": \"0385b4fe35e41703d7a657d957c67bb536629de57b7e6ee6fe2130728ef0fc90b0\",\n  \"72057594037927936\": \"02b2bc1968a6fddbcc78fb9903940524824b5f5bed329c6ad48a19b56068c144fd\",\n  \"144115188075855872\": \"02e0dbb24f1d288a693e8a49bc14264d1276be16972131520cf9e055ae92fba19a\",\n  \"288230376151711744\": \"03efe75c106f931a525dc2d653ebedddc413a2c7d8cb9da410893ae7d2fa7d19cc\",\n  \"576460752303423488\": \"02c7ec2bd9508a7fc03f73c7565dc600b30fd86f3d305f8f139c45c404a52d958a\",\n  \"1152921504606846976\": \"035a6679c6b25e68ff4e29d1c7ef87f21e0a8fc574f6a08c1aa45ff352c1d59f06\",\n  \"2305843009213693952\": \"033cdc225962c052d485f7cfbf55a5b2367d200fe1fe4373a347deb4cc99e9a099\",\n  \"4611686018427387904\": \"024a4b806cf413d14b294719090a9da36ba75209c7657135ad09bc65328fba9e6f\",\n  \"9223372036854775808\": \"0377a6fe114e291a8d8e991627c38001c8305b23b9e98b1c7b1893f5cd0dda6cad\"\n}\n</code></pre>"},{"location":"tests/02-tests/","title":"NUT-02 Test Vectors","text":"<p>The following keysets and corresponding keyset IDs are correct: Keyset id: <code>00456a94ab4e1c46</code></p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38bc\",\n  \"2\": \"03fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <p>Keyset id: <code>000f01df73ea149a</code></p> <pre><code>{\n  \"1\": \"03ba786a2c0745f8c30e490288acd7a72dd53d65afd292ddefa326a4a3fa14c566\",\n  \"2\": \"03361cd8bd1329fea797a6add1cf1990ffcf2270ceb9fc81eeee0e8e9c1bd0cdf5\",\n  \"4\": \"036e378bcf78738ddf68859293c69778035740e41138ab183c94f8fee7572214c7\",\n  \"8\": \"03909d73beaf28edfb283dbeb8da321afd40651e8902fcf5454ecc7d69788626c0\",\n  \"16\": \"028a36f0e6638ea7466665fe174d958212723019ec08f9ce6898d897f88e68aa5d\",\n  \"32\": \"03a97a40e146adee2687ac60c2ba2586a90f970de92a9d0e6cae5a4b9965f54612\",\n  \"64\": \"03ce86f0c197aab181ddba0cfc5c5576e11dfd5164d9f3d4a3fc3ffbbf2e069664\",\n  \"128\": \"0284f2c06d938a6f78794814c687560a0aabab19fe5e6f30ede38e113b132a3cb9\",\n  \"256\": \"03b99f475b68e5b4c0ba809cdecaae64eade2d9787aa123206f91cd61f76c01459\",\n  \"512\": \"03d4db82ea19a44d35274de51f78af0a710925fe7d9e03620b84e3e9976e3ac2eb\",\n  \"1024\": \"031fbd4ba801870871d46cf62228a1b748905ebc07d3b210daf48de229e683f2dc\",\n  \"2048\": \"0276cedb9a3b160db6a158ad4e468d2437f021293204b3cd4bf6247970d8aff54b\",\n  \"4096\": \"02fc6b89b403ee9eb8a7ed457cd3973638080d6e04ca8af7307c965c166b555ea2\",\n  \"8192\": \"0320265583e916d3a305f0d2687fcf2cd4e3cd03a16ea8261fda309c3ec5721e21\",\n  \"16384\": \"036e41de58fdff3cb1d8d713f48c63bc61fa3b3e1631495a444d178363c0d2ed50\",\n  \"32768\": \"0365438f613f19696264300b069d1dad93f0c60a37536b72a8ab7c7366a5ee6c04\",\n  \"65536\": \"02408426cfb6fc86341bac79624ba8708a4376b2d92debdf4134813f866eb57a8d\",\n  \"131072\": \"031063e9f11c94dc778c473e968966eac0e70b7145213fbaff5f7a007e71c65f41\",\n  \"262144\": \"02f2a3e808f9cd168ec71b7f328258d0c1dda250659c1aced14c7f5cf05aab4328\",\n  \"524288\": \"038ac10de9f1ff9395903bb73077e94dbf91e9ef98fd77d9a2debc5f74c575bc86\",\n  \"1048576\": \"0203eaee4db749b0fc7c49870d082024b2c31d889f9bc3b32473d4f1dfa3625788\",\n  \"2097152\": \"033cdb9d36e1e82ae652b7b6a08e0204569ec7ff9ebf85d80a02786dc7fe00b04c\",\n  \"4194304\": \"02c8b73f4e3a470ae05e5f2fe39984d41e9f6ae7be9f3b09c9ac31292e403ac512\",\n  \"8388608\": \"025bbe0cfce8a1f4fbd7f3a0d4a09cb6badd73ef61829dc827aa8a98c270bc25b0\",\n  \"16777216\": \"037eec3d1651a30a90182d9287a5c51386fe35d4a96839cf7969c6e2a03db1fc21\",\n  \"33554432\": \"03280576b81a04e6abd7197f305506476f5751356b7643988495ca5c3e14e5c262\",\n  \"67108864\": \"03268bfb05be1dbb33ab6e7e00e438373ca2c9b9abc018fdb452d0e1a0935e10d3\",\n  \"134217728\": \"02573b68784ceba9617bbcc7c9487836d296aa7c628c3199173a841e7a19798020\",\n  \"268435456\": \"0234076b6e70f7fbf755d2227ecc8d8169d662518ee3a1401f729e2a12ccb2b276\",\n  \"536870912\": \"03015bd88961e2a466a2163bd4248d1d2b42c7c58a157e594785e7eb34d880efc9\",\n  \"1073741824\": \"02c9b076d08f9020ebee49ac8ba2610b404d4e553a4f800150ceb539e9421aaeee\",\n  \"2147483648\": \"034d592f4c366afddc919a509600af81b489a03caf4f7517c2b3f4f2b558f9a41a\",\n  \"4294967296\": \"037c09ecb66da082981e4cbdb1ac65c0eb631fc75d85bed13efb2c6364148879b5\",\n  \"8589934592\": \"02b4ebb0dda3b9ad83b39e2e31024b777cc0ac205a96b9a6cfab3edea2912ed1b3\",\n  \"17179869184\": \"026cc4dacdced45e63f6e4f62edbc5779ccd802e7fabb82d5123db879b636176e9\",\n  \"34359738368\": \"02b2cee01b7d8e90180254459b8f09bbea9aad34c3a2fd98c85517ecfc9805af75\",\n  \"68719476736\": \"037a0c0d564540fc574b8bfa0253cca987b75466e44b295ed59f6f8bd41aace754\",\n  \"137438953472\": \"021df6585cae9b9ca431318a713fd73dbb76b3ef5667957e8633bca8aaa7214fb6\",\n  \"274877906944\": \"02b8f53dde126f8c85fa5bb6061c0be5aca90984ce9b902966941caf963648d53a\",\n  \"549755813888\": \"029cc8af2840d59f1d8761779b2496623c82c64be8e15f9ab577c657c6dd453785\",\n  \"1099511627776\": \"03e446fdb84fad492ff3a25fc1046fb9a93a5b262ebcd0151caa442ea28959a38a\",\n  \"2199023255552\": \"02d6b25bd4ab599dd0818c55f75702fde603c93f259222001246569018842d3258\",\n  \"4398046511104\": \"03397b522bb4e156ec3952d3f048e5a986c20a00718e5e52cd5718466bf494156a\",\n  \"8796093022208\": \"02d1fb9e78262b5d7d74028073075b80bb5ab281edcfc3191061962c1346340f1e\",\n  \"17592186044416\": \"030d3f2ad7a4ca115712ff7f140434f802b19a4c9b2dd1c76f3e8e80c05c6a9310\",\n  \"35184372088832\": \"03e325b691f292e1dfb151c3fb7cad440b225795583c32e24e10635a80e4221c06\",\n  \"70368744177664\": \"03bee8f64d88de3dee21d61f89efa32933da51152ddbd67466bef815e9f93f8fd1\",\n  \"140737488355328\": \"0327244c9019a4892e1f04ba3bf95fe43b327479e2d57c25979446cc508cd379ed\",\n  \"281474976710656\": \"02fb58522cd662f2f8b042f8161caae6e45de98283f74d4e99f19b0ea85e08a56d\",\n  \"562949953421312\": \"02adde4b466a9d7e59386b6a701a39717c53f30c4810613c1b55e6b6da43b7bc9a\",\n  \"1125899906842624\": \"038eeda11f78ce05c774f30e393cda075192b890d68590813ff46362548528dca9\",\n  \"2251799813685248\": \"02ec13e0058b196db80f7079d329333b330dc30c000dbdd7397cbbc5a37a664c4f\",\n  \"4503599627370496\": \"02d2d162db63675bd04f7d56df04508840f41e2ad87312a3c93041b494efe80a73\",\n  \"9007199254740992\": \"0356969d6aef2bb40121dbd07c68b6102339f4ea8e674a9008bb69506795998f49\",\n  \"18014398509481984\": \"02f4e667567ebb9f4e6e180a4113bb071c48855f657766bb5e9c776a880335d1d6\",\n  \"36028797018963968\": \"0385b4fe35e41703d7a657d957c67bb536629de57b7e6ee6fe2130728ef0fc90b0\",\n  \"72057594037927936\": \"02b2bc1968a6fddbcc78fb9903940524824b5f5bed329c6ad48a19b56068c144fd\",\n  \"144115188075855872\": \"02e0dbb24f1d288a693e8a49bc14264d1276be16972131520cf9e055ae92fba19a\",\n  \"288230376151711744\": \"03efe75c106f931a525dc2d653ebedddc413a2c7d8cb9da410893ae7d2fa7d19cc\",\n  \"576460752303423488\": \"02c7ec2bd9508a7fc03f73c7565dc600b30fd86f3d305f8f139c45c404a52d958a\",\n  \"1152921504606846976\": \"035a6679c6b25e68ff4e29d1c7ef87f21e0a8fc574f6a08c1aa45ff352c1d59f06\",\n  \"2305843009213693952\": \"033cdc225962c052d485f7cfbf55a5b2367d200fe1fe4373a347deb4cc99e9a099\",\n  \"4611686018427387904\": \"024a4b806cf413d14b294719090a9da36ba75209c7657135ad09bc65328fba9e6f\",\n  \"9223372036854775808\": \"0377a6fe114e291a8d8e991627c38001c8305b23b9e98b1c7b1893f5cd0dda6cad\"\n}\n</code></pre>"},{"location":"tests/11-test/","title":"NUT-11 Test Vectors","text":"<p>The following is a <code>Proof</code> with a valid signature.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"859d4935c4907062a6297cf4e663e2835d90d97ecdd510745d32f6816323a41f\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"60f3c9b766770b46caac1d27e1ae6b77c8866ebaeba0b9489fe6a15a837eaa6fcd6eaa825499c72ac342983983fd3ba3a8a41f56677cc99ffd73da68b59e1383\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with an invalid signature as it is on a different secret.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"0ed3fcb22c649dd7bbbdcca36e0c52d4f0187dd3b6a19efcc2bfbebb5f85b2a1\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"02142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"83564aca48c668f50d022a426ce0ed19d3a9bdcffeeaee0dc1e7ea7e98e9eff1840fcc821724f623468c94f72a8b0a7280fa9ef5a54a1b130ef3055217f467b3\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with 2 signatures required to meet the multi-signature spend condition.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"0ed3fcb22c649dd7bbbdcca36e0c52d4f0187dd3b6a19efcc2bfbebb5f85b2a1\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"02142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"83564aca48c668f50d022a426ce0ed19d3a9bdcffeeaee0dc1e7ea7e98e9eff1840fcc821724f623468c94f72a8b0a7280fa9ef5a54a1b130ef3055217f467b3\\\",\\\"9a72ca2d4d5075be5b511ee48dbc5e45f259bcf4a4e8bf18587f433098a9cd61ff9737dc6e8022de57c76560214c4568377792d4c2c6432886cc7050487a1f22\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with one one signature failing the multi-signature spend condition.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"0ed3fcb22c649dd7bbbdcca36e0c52d4f0187dd3b6a19efcc2bfbebb5f85b2a1\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"02142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"83564aca48c668f50d022a426ce0ed19d3a9bdcffeeaee0dc1e7ea7e98e9eff1840fcc821724f623468c94f72a8b0a7280fa9ef5a54a1b130ef3055217f467b3\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with a signature from the refund key that is spendable because the locktime is in the past.</p> <pre><code>{\n  \"amount\": 1,\n  \"id\": \"009a1f293253e41e\",\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"902685f492ef3bb2ca35a47ddbba484a3365d143b9776d453947dcbf1ddf9689\\\",\\\"data\\\":\\\"026f6a2b1d709dbca78124a9f30a742985f7eddd894e72f637f7085bf69b997b9a\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"03142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"locktime\\\",\\\"21\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"refund\\\",\\\"026f6a2b1d709dbca78124a9f30a742985f7eddd894e72f637f7085bf69b997b9a\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"710507b4bc202355c91ea3c147c0d0189c75e179d995e566336afd759cb342bcad9a593345f559d9b9e108ac2c9b5bd9f0b4b6a295028a98606a0a2e95eb54f7\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with a signature from the refund key that is not spendable because the locktime is in the future.</p> <pre><code>{\n  \"amount\": 1,\n  \"id\": \"009a1f293253e41e\",\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"64c46e5d30df27286166814b71b5d69801704f23a7ad626b05688fbdb48dcc98\\\",\\\"data\\\":\\\"026f6a2b1d709dbca78124a9f30a742985f7eddd894e72f637f7085bf69b997b9a\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"03142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"locktime\\\",\\\"21\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"refund\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"f661d3dc046d636d47cb3d06586da42c498f0300373d1c2a4f417a44252cdf3809bce207c8888f934dba0d2b1671f1b8622d526840f2d5883e571b462630c1ff\\\"]}\"\n}\n</code></pre>"},{"location":"tests/12-tests/","title":"NUT-12 Test vectors","text":""},{"location":"tests/12-tests/#hash_e-function","title":"<code>hash_e</code> function","text":"<pre><code>R1: \"020000000000000000000000000000000000000000000000000000000000000001\"\nR2: \"020000000000000000000000000000000000000000000000000000000000000001\"\nK: \"020000000000000000000000000000000000000000000000000000000000000001\"\nC_: \"02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\"\n</code></pre> <pre><code>hash(R1, R2, K, C_): \"a4dc034b74338c28c6bc3ea49731f2a24440fc7c4affc08b31a93fc9fbe6401e\"\n</code></pre>"},{"location":"tests/12-tests/#dleq-verification-on-blindsignature","title":"DLEQ verification on <code>BlindSignature</code>","text":"<p>The following is a <code>BlindSignature</code> with a valid DLEQ proof.</p> <pre><code>A: \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"\nB_: \"02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\"\n</code></pre> <pre><code>{\n  \"amount\": 8,\n  \"id\": \"00882760bfa2eb41\",\n  \"C_\": \"02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\",\n  \"dleq\": {\n    \"e\": \"9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73d9\",\n    \"s\": \"9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73da\"\n  }\n}\n</code></pre>"},{"location":"tests/12-tests/#dleq-verification-on-proof","title":"DLEQ verification on <code>Proof</code>","text":"<p>The following is a <code>Proof</code> with a valid DLEQ proof.</p> <pre><code>A: \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"\n</code></pre> <pre><code>{\n  \"amount\": 1,\n  \"id\": \"00882760bfa2eb41\",\n  \"secret\": \"daf4dd00a2b68a0858a80450f52c8a7d2ccf87d375e43e216e0c571f089f63e9\",\n  \"C\": \"024369d2d22a80ecf78f3937da9d5f30c1b9f74f0c32684d583cca0fa6a61cdcfc\",\n  \"dleq\": {\n    \"e\": \"b31e58ac6527f34975ffab13e70a48b6d2b0d35abc4b03f0151f09ee1a9763d4\",\n    \"s\": \"8fbae004c59e754d71df67e392b6ae4e29293113ddc2ec86592a0431d16306d8\",\n    \"r\": \"a6d13fcd7a18442e6076f5e1e7c887ad5de40a019824bdfa9fe740d302e8d861\"\n  }\n}\n</code></pre>"},{"location":"tests/13-tests/","title":"NUT-13 Test vectors","text":""},{"location":"tests/13-tests/#keyset-id-integer-representation","title":"Keyset ID integer representation","text":"<p>The integer representation of a keyset with an ID <code>009a1f293253e41e</code> and its corresponding derivation path for a counter of value <code>{counter}</code> are</p> <pre><code>{\n  \"keyset_id\": \"009a1f293253e41e\",\n  \"keyest_id_int\": 864559728,\n  \"derivation_path\": \"m/129372'/0'/864559728'/{counter}'\"\n}\n</code></pre>"},{"location":"tests/13-tests/#secret-derivatoin","title":"Secret derivatoin","text":"<p>We derive values starting from the following BIP39 mnemonic.</p> <pre><code>{\n  \"mnemonic\": \"half depart obvious quality work element tank gorilla view sugar picture humble\"\n}\n</code></pre> <p>The secrets derived for the first five counters from <code>counter=0</code> to <code>counter=4</code> are</p> <pre><code>{\n  \"secret_0\": \"485875df74771877439ac06339e284c3acfcd9be7abf3bc20b516faeadfe77ae\",\n  \"secret_1\": \"8f2b39e8e594a4056eb1e6dbb4b0c38ef13b1b2c751f64f810ec04ee35b77270\",\n  \"secret_2\": \"bc628c79accd2364fd31511216a0fab62afd4a18ff77a20deded7b858c9860c8\",\n  \"secret_3\": \"59284fd1650ea9fa17db2b3acf59ecd0f2d52ec3261dd4152785813ff27a33bf\",\n  \"secret_4\": \"576c23393a8b31cc8da6688d9c9a96394ec74b40fdaf1f693a6bb84284334ea0\"\n}\n</code></pre> <p>The corresponding blinding factors <code>r</code> are</p> <pre><code>{\n  \"r_0\": \"ad00d431add9c673e843d4c2bf9a778a5f402b985b8da2d5550bf39cda41d679\",\n  \"r_1\": \"967d5232515e10b81ff226ecf5a9e2e2aff92d66ebc3edf0987eb56357fd6248\",\n  \"r_2\": \"b20f47bb6ae083659f3aa986bfa0435c55c6d93f687d51a01f26862d9b9a4899\",\n  \"r_3\": \"fb5fca398eb0b1deb955a2988b5ac77d32956155f1c002a373535211a2dfdc29\",\n  \"r_4\": \"5f09bfbfe27c439a597719321e061e2e40aad4a36768bb2bcc3de547c9644bf9\"\n}\n</code></pre> <p>The corresponding derivation paths are</p> <pre><code>{\n  \"derivation_path_0\": \"m/129372'/0'/864559728'/0'\",\n  \"derivation_path_1\": \"m/129372'/0'/864559728'/1'\",\n  \"derivation_path_2\": \"m/129372'/0'/864559728'/2'\",\n  \"derivation_path_3\": \"m/129372'/0'/864559728'/3'\",\n  \"derivation_path_4\": \"m/129372'/0'/864559728'/4'\"\n}\n</code></pre>"},{"location":"tests/20-test/","title":"NUT-20 Test Vectors","text":"<p>The following is a <code>PostMintBolt11Request</code> with a valid signature. Where the <code>pubkey</code> in the <code>PostMintQuoteBolt11Request</code> is <code>03d56ce4e446a85bbdaa547b4ec2b073d40ff802831352b8272b7dd7a4de5a7cac</code>.</p> <pre><code>{\n  \"quote\": \"9d745270-1405-46de-b5c5-e2762b4f5e00\",\n  \"outputs\": [\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"0342e5bcc77f5b2a3c2afb40bb591a1e27da83cddc968abdc0ec4904201a201834\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"032fd3c4dc49a2844a89998d5e9d5b0f0b00dde9310063acb8a92e2fdafa4126d4\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"033b6fde50b6a0dfe61ad148fff167ad9cf8308ded5f6f6b2fe000a036c464c311\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"02be5a55f03e5c0aaea77595d574bce92c6d57a2a0fb2b5955c0b87e4520e06b53\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"02209fc2873f28521cbdde7f7b3bb1521002463f5979686fd156f23fe6a8aa2b79\"\n    }\n  ],\n  \"signature\": \"d4b386f21f7aa7172f0994ee6e4dd966539484247ea71c99b81b8e09b1bb2acbc0026a43c221fd773471dc30d6a32b04692e6837ddaccf0830a63128308e4ee0\"\n}\n</code></pre> <p>The following is the expected message to sign on the above <code>PostMintBolt11Request</code>.</p> <pre><code>[57, 100, 55, 52, 53, 50, 55, 48, 45, 49, 52, 48, 53, 45, 52, 54, 100, 101, 45, 98, 53, 99, 53, 45, 101, 50, 55, 54, 50, 98, 52, 102, 53, 101, 48, 48, 48, 51, 52, 50, 101, 53, 98, 99, 99, 55, 55, 102, 53, 98, 50, 97, 51, 99, 50, 97, 102, 98, 52, 48, 98, 98, 53, 57, 49, 97, 49, 101, 50, 55, 100, 97, 56, 51, 99, 100, 100, 99, 57, 54, 56, 97, 98, 100, 99, 48, 101, 99, 52, 57, 48, 52, 50, 48, 49, 97, 50, 48, 49, 56, 51, 52, 48, 51, 50, 102, 100, 51, 99, 52, 100, 99, 52, 57, 97, 50, 56, 52, 52, 97, 56, 57, 57, 57, 56, 100, 53, 101, 57, 100, 53, 98, 48, 102, 48, 98, 48, 48, 100, 100, 101, 57, 51, 49, 48, 48, 54, 51, 97, 99, 98, 56, 97, 57, 50, 101, 50, 102, 100, 97, 102, 97, 52, 49, 50, 54, 100, 52, 48, 51, 51, 98, 54, 102, 100, 101, 53, 48, 98, 54, 97, 48, 100, 102, 101, 54, 49, 97, 100, 49, 52, 56, 102, 102, 102, 49, 54, 55, 97, 100, 57, 99, 102, 56, 51, 48, 56, 100, 101, 100, 53, 102, 54, 102, 54, 98, 50, 102, 101, 48, 48, 48, 97, 48, 51, 54, 99, 52, 54, 52, 99, 51, 49, 49, 48, 50, 98, 101, 53, 97, 53, 53, 102, 48, 51, 101, 53, 99, 48, 97, 97, 101, 97, 55, 55, 53, 57, 53, 100, 53, 55, 52, 98, 99, 101, 57, 50, 99, 54, 100, 53, 55, 97, 50, 97, 48, 102, 98, 50, 98, 53, 57, 53, 53, 99, 48, 98, 56, 55, 101, 52, 53, 50, 48, 101, 48, 54, 98, 53, 51, 48, 50, 50, 48, 57, 102, 99, 50, 56, 55, 51, 102, 50, 56, 53, 50, 49, 99, 98, 100, 100, 101, 55, 102, 55, 98, 51, 98, 98, 49, 53, 50, 49, 48, 48, 50, 52, 54, 51, 102, 53, 57, 55, 57, 54, 56, 54, 102, 100, 49, 53, 54, 102, 50, 51, 102, 101, 54, 97, 56, 97, 97, 50, 98, 55, 57]\n</code></pre> <p>The following is a <code>PostMintBolt11Request</code> with an invalid signature. Where the <code>pubkey</code> in the <code>PostMintQuoteBolt11Request</code> is <code>03d56ce4e446a85bbdaa547b4ec2b073d40ff802831352b8272b7dd7a4de5a7cac</code>.</p> <pre><code>{\n  \"quote\": \"9d745270-1405-46de-b5c5-e2762b4f5e00\",\n  \"outputs\": [\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"0342e5bcc77f5b2a3c2afb40bb591a1e27da83cddc968abdc0ec4904201a201834\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"032fd3c4dc49a2844a89998d5e9d5b0f0b00dde9310063acb8a92e2fdafa4126d4\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"033b6fde50b6a0dfe61ad148fff167ad9cf8308ded5f6f6b2fe000a036c464c311\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"02be5a55f03e5c0aaea77595d574bce92c6d57a2a0fb2b5955c0b87e4520e06b53\"\n    },\n    {\n      \"amount\": 1,\n      \"id\": \"00456a94ab4e1c46\",\n      \"B_\": \"02209fc2873f28521cbdde7f7b3bb1521002463f5979686fd156f23fe6a8aa2b79\"\n    }\n  ],\n  \"signature\": \"cb2b8e7ea69362dfe2a07093f2bbc319226db33db2ef686c940b5ec976bcbfc78df0cd35b3e998adf437b09ee2c950bd66dfe9eb64abd706e43ebc7c669c36c3\"\n}\n</code></pre>"}]}