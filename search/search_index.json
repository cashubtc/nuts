{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cashu NUTs (Notation, Usage, and Terminology)","text":"<p>These documents each specify parts of the Cashu protocol. Read the specifications for the legacy API here.</p>"},{"location":"#specifications","title":"Specifications","text":"<p>Wallets and mints <code>MUST</code> implement all mandatory specs and <code>CAN</code> implement optional specs.</p>"},{"location":"#mandatory","title":"Mandatory","text":"NUT # Description 00 Cryptography and Models 01 Mint public keys 02 Keysets and fees 03 Swapping tokens 04 Minting tokens 05 Melting tokens 06 Mint info"},{"location":"#optional","title":"Optional","text":"# Description Wallets Mints 07 Token state check Nutshell, Moksha, Nutstash, cashu-ts, cdk-cli Nutshell, Moksha, cdk-mintd 08 Overpaid Lightning fees Nutshell, Moksha, Nutstash, cashu-ts, cdk-cli Nutshell, Moksha, cdk-mintd 09 Signature restore Nutshell, cdk-cli, cashu-ts, gonuts Nutshell, cdk-mintd 10 Spending conditions Nutshell, cdk-cli, cashu-ts Nutshell, cdk-mintd, nutmix 11 Pay-To-Pubkey (P2PK) Nutshell, cdk-cli, cashu-ts Nutshell, cdk-mintd, nutmix 12 DLEQ proofs Nutshell, cdk-cli Nutshell, cdk-mintd 13 Deterministic secrets Nutshell, Moksha, cashu-ts, cdk-cli, gonuts - 14 Hashed Timelock Contracts (HTLCs) Nutshell, cdk-cli Nutshell, cdk-mintd 15 Partial multi-path payments (MPP) Nutshell Nutshell 16 Animated QR codes Cashu.me - 17 WebSocket subscriptions Nutshell Nutshell"},{"location":"#wallets","title":"Wallets:","text":"<ul> <li>Nutshell</li> <li>cdk-cli</li> <li>cashu-ts</li> <li>eNuts</li> <li>Minibits</li> <li>Moksha</li> <li>Nutstash</li> <li>Cashu.me</li> <li>Gonuts</li> <li>Boardwalk Cash</li> </ul>"},{"location":"#mints","title":"Mints:","text":"<ul> <li>Nutshell</li> <li>Gonuts</li> <li>Moksha</li> <li>cdk-mintd</li> <li>Nutmix</li> </ul>"},{"location":"00/","title":"NUT-00: Notation, Utilization, and Terminology","text":"<p><code>mandatory</code></p> <p>This document details the notation and models used throughout the specification and lays the groundwork for understanding the basic cryptography used in the Cashu protocol.</p> <ul> <li>Sending user: <code>Alice</code></li> <li>Receiving user: <code>Carol</code></li> <li>Mint: <code>Bob</code></li> </ul>"},{"location":"00/#blind-diffie-hellmann-key-exchange-bdhke","title":"Blind Diffie-Hellmann key exchange (BDHKE)","text":""},{"location":"00/#variables","title":"Variables","text":"<ul> <li><code>G</code> elliptic curve generator point</li> </ul>"},{"location":"00/#bob-mint","title":"Bob (mint)","text":"<ul> <li><code>k</code> private key of mint (one for each amount)</li> <li><code>K</code> public key of mint</li> <li><code>Q</code> promise (blinded signature)</li> </ul>"},{"location":"00/#alice-user","title":"Alice (user)","text":"<ul> <li><code>x</code> random string (secret message), corresponds to point <code>Y</code> on curve</li> <li><code>r</code> private key (blinding factor)</li> <li><code>T</code> blinded message</li> <li><code>Z</code> proof (unblinded signature)</li> </ul>"},{"location":"00/#hash_to_curvex-bytes-curve-point-y","title":"<code>hash_to_curve(x: bytes) -&gt; curve point Y</code>","text":"<p>Deterministically maps a message to a public key point on the secp256k1 curve, utilizing a domain separator to ensure uniqueness.</p> <p><code>Y = PublicKey('02' || SHA256(msg_hash || counter))</code> where <code>msg_hash</code> is <code>SHA256(DOMAIN_SEPARATOR || x)</code></p> <ul> <li><code>Y</code> derived public key</li> <li><code>DOMAIN_SEPARATOR</code> constant byte string <code>b\"Secp256k1_HashToCurve_Cashu_\"</code></li> <li><code>x</code> message to hash</li> <li><code>counter</code> uint32 counter(byte order little endian) incremented from 0 until a point is found that lies on the curve</li> </ul>"},{"location":"00/#protocol","title":"Protocol","text":"<ul> <li>Mint <code>Bob</code> publishes public key <code>K = kG</code></li> <li><code>Alice</code> picks secret <code>x</code> and computes <code>Y = hash_to_curve(x)</code></li> <li><code>Alice</code> sends to <code>Bob</code>: <code>B_ = Y + rG</code> with <code>r</code> being a random blinding factor (blinding)</li> <li><code>Bob</code> sends back to <code>Alice</code> blinded key: <code>C_ = kB_</code> (these two steps are the DH key exchange) (signing)</li> <li><code>Alice</code> can calculate the unblinded key as <code>C_ - rK = kY + krG - krG = kY = C</code> (unblinding)</li> <li>Alice can take the pair <code>(x, C)</code> as a token and can send it to <code>Carol</code>.</li> <li><code>Carol</code> can send <code>(x, C)</code> to <code>Bob</code> who then checks that <code>k*hash_to_curve(x) == C</code> (verification), and if so treats it as a valid spend of a token, adding <code>x</code> to the list of spent secrets.</li> </ul>"},{"location":"00/#01-models","title":"0.1 - Models","text":""},{"location":"00/#blindedmessage","title":"<code>BlindedMessage</code>","text":"<p>An encrypted (\"blinded\") secret and an amount is sent from <code>Alice</code> to <code>Bob</code> for minting tokens or for swapping tokens. A <code>BlindedMessage</code> is also called an <code>output</code>.</p> <pre><code>{\n  \"amount\": int,\n  \"id\": hex_str,\n  \"B_\": hex_str\n}\n</code></pre> <p><code>amount</code> is the value for the requested <code>BlindSignature</code>, <code>id</code> is the requested keyset ID from which we expect a signature, and <code>B_</code> is the blinded secret message generated by <code>Alice</code>. An array <code>[BlindedMessage]</code> is also referred to as <code>BlindedMessages</code>.</p>"},{"location":"00/#blindsignature","title":"<code>BlindSignature</code>","text":"<p>A <code>BlindSignature</code> is sent from <code>Bob</code> to <code>Alice</code> after minting tokens or after swapping tokens. A <code>BlindSignature</code> is also called a <code>promise</code>.</p> <pre><code>{\n  \"amount\": int,\n  \"id\": hex_str,\n  \"C_\": hex_str\n}\n</code></pre> <p><code>amount</code> is the value of the blinded token, <code>id</code> is the keyset id of the mint keys that signed the token, and <code>C_</code> is the blinded signature on the secret message <code>B_</code> sent in the previous step.</p>"},{"location":"00/#proof","title":"<code>Proof</code>","text":"<p>A <code>Proof</code> is also called an input and is generated by <code>Alice</code> from a <code>BlindSignature</code> it received. An array <code>[Proof]</code> is called <code>Proofs</code>. <code>Alice</code> sends <code>Proofs</code> to <code>Bob</code> for melting tokens. Serialized <code>Proofs</code> can also be sent from <code>Alice</code> to <code>Carol</code>. Upon receiving the token, <code>Carol</code> deserializes it and requests a swap from <code>Bob</code> to receive new <code>Proofs</code>.</p> <pre><code>{\n  \"amount\": int,\n  \"id\": hex_str,\n  \"secret\": str,\n  \"C\": hex_str,\n}\n</code></pre> <p><code>amount</code> is the amount of the <code>Proof</code>, <code>secret</code> is the secret message and is a utf-8 encoded string (the use of a 64 character hex string generated from 32 random bytes is recommended to prevent fingerprinting), <code>C</code> is the unblinded signature on <code>secret</code> (hex string), <code>id</code> is the keyset id of the mint public keys that signed the token (hex string).</p>"},{"location":"00/#02-protocol","title":"0.2 - Protocol","text":""},{"location":"00/#errors","title":"Errors","text":"<p>In case of an error, mints respond with the HTTP status code <code>400</code> and include the following data in their response:</p> <pre><code>{\n  \"detail\": \"oops\",\n  \"code\": 1337\n}\n</code></pre> <p>Here, <code>detail</code> is the error message, and <code>code</code> is the error code. Error codes are to be defined in the documents concerning the use of a certain API endpoint.</p>"},{"location":"00/#03-methods","title":"0.3 - Methods","text":""},{"location":"00/#serialization-of-tokens","title":"Serialization of tokens","text":"<p>Tokens can be serialized to send them between users <code>Alice</code> and <code>Carol</code>. Serialized tokens have a Cashu token prefix, a versioning flag, and the token. Optionally, a URI prefix for making tokens clickable on the web.</p> <p>We use the following format for token serialization:</p> <pre><code>cashu[version][token]\n</code></pre> <p><code>cashu</code> is the Cashu token prefix. <code>[version]</code> is a single <code>base64_urlsafe</code> character to denote the token format version.</p>"},{"location":"00/#uri-tags","title":"URI tags","text":"<p>To make Cashu tokens clickable on the web, we use the URI scheme <code>cashu:</code>. An example of a serialized token with URI tag is</p> <pre><code>cashu:cashuAeyJwcm9vZn...\n</code></pre>"},{"location":"00/#v3-tokens","title":"V3 tokens","text":"<p>V3 tokens are deprecated and the use of the more space-efficient V4 tokens is encouraged.</p>"},{"location":"00/#version","title":"Version","text":"<p>This token format has the <code>[version]</code> value <code>A</code>.</p>"},{"location":"00/#format","title":"Format","text":"<p>V3 tokens are base64-encoded JSON objects. The token format supports tokens from multiple mints. The JSON is serialized with a <code>base64_urlsafe</code> (base64 encoding with <code>/</code> replaced by <code>_</code> and <code>+</code> by <code>-</code>). <code>base64_urlsafe</code> strings may have padding characters (usually <code>=</code>) at the end which can be omitted. Clients need to be able to decode both cases.</p> <pre><code>cashuA[base64_token_json]\n</code></pre> <p><code>[base64_token_json]</code> is the token JSON serialized in <code>base64_urlsafe</code>. <code>[base64_token_json]</code> should be cleared of any whitespace before serializing.</p>"},{"location":"00/#token-format","title":"Token format","text":"<p>The deserialized <code>base64_token_json</code> is</p> <pre><code>{\n  \"token\": [\n    {\n      \"mint\": str,\n      \"proofs\": Proofs\n    },\n    ...\n  ],\n  \"unit\": str &lt;optional&gt;,\n  \"memo\": str &lt;optional&gt;\n}\n</code></pre> <p><code>mint</code> is the mint URL. The mint URL must be stripped of any trailing slashes (<code>/</code>). <code>Proofs</code> is an array of <code>Proof</code> objects. The next two elements are only for displaying the receiving user appropriate information: <code>unit</code> is the currency unit of the token keysets (see Keysets for supported units), and <code>memo</code> is an optional text memo from the sender.</p>"},{"location":"00/#example","title":"Example","text":"<p>Below is a TokenV3 JSON before <code>base64_urlsafe</code> serialization.</p> <pre><code>{\n  \"token\": [\n    {\n      \"mint\": \"https://8333.space:3338\",\n      \"proofs\": [\n        {\n          \"amount\": 2,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n          \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n        },\n        {\n          \"amount\": 8,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be\",\n          \"C\": \"029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059\"\n        }\n      ]\n    }\n  ],\n  \"unit\": \"sat\",\n  \"memo\": \"Thank you.\"\n}\n</code></pre> <p>When serialized, this becomes:</p> <pre><code>cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre>"},{"location":"00/#v4-tokens","title":"V4 tokens","text":"<p>V4 tokens are a space-efficient way of serializing tokens using the CBOR binary format. All field are single characters and hex strings are encoded in binary. V4 tokens can only hold proofs from a single mint.</p>"},{"location":"00/#version_1","title":"Version","text":"<p>This token format has the <code>[version]</code> value <code>B</code>.</p>"},{"location":"00/#format_1","title":"Format","text":"<p>Wallets serialize tokens in a <code>base64_urlsafe</code> format (base64 encoding with <code>/</code> replaced by <code>_</code> and <code>+</code> by <code>-</code>). <code>base64_urlsafe</code> strings may have padding characters (usually <code>=</code>) at the end which can be omitted. Clients need to be able to decode both cases.</p> <pre><code>cashuB[base64_token_cbor]\n</code></pre>"},{"location":"00/#token-format_1","title":"Token format","text":"<p>The deserialized <code>base64_token_cbor</code> is a JSON of the same form as a TokenV4 but with shorter keys and data represented as binary data (<code>bytes</code>) instead of hex strings (<code>hex_str</code>). Note that we have expanded what is called <code>Proofs</code> in TokenV3 (called <code>p</code> here with TokenV4) showing that its values are also different from the TokenV3 serialization.</p> <pre><code>{\n  \"m\": str, // mint URL\n  \"u\": str, // unit\n  \"d\": str &lt;optional&gt;, // memo\n  \"t\": [\n    {\n      \"i\": bytes, // keyset ID\n      \"p\": [ // proofs with this keyset ID\n        {\n          \"a\": int, // amount\n          \"s\": str, // secret\n          \"c\": bytes, // signature\n          \"d\": { &lt;optional&gt; // DLEQ proof\n            \"e\": bytes,\n            \"s\": bytes,\n            \"r\": bytes\n          },\n          \"w\": str &lt;optional&gt; // witness\n        },\n        ...\n      ]\n    },\n    ...\n  ],\n}\n</code></pre> <p><code>m</code> is the mint URL. The mint URL must be stripped of any trailing slashes (<code>/</code>). <code>u</code> is the currency unit of the token keysets (see Keysets for supported units), and <code>d</code> is an optional text memo from the sender.</p> <p><code>i</code> is the keyset ID of the profs in <code>p</code>, which is an array of <code>Proof</code> objects without the <code>id</code> field. We extracted the keyset ID <code>id</code> from each proof and grouped all proofs by their keyset ID <code>i</code> one level above (in <code>p</code>).</p> <p>Note that all fields of the <code>bytes</code> type encode hex strings in the original representation of <code>Proof</code>'s.</p>"},{"location":"00/#example_1","title":"Example","text":"<p>Below is a TokenV4 JSON before CBOR and <code>base64_urlsafe</code> serialization.</p> <pre><code>{\n    \"t\": [\n        {\n            \"i\": h'00ffd48b8f5ecf80',\n            \"p\": [\n                {\n                    \"a\": 1,\n                    \"s\": \"acc12435e7b8484c3cf1850149218af90f716a52bf4a5ed347e48ecc13f77388\",\n                    \"c\": h'0244538319de485d55bed3b29a642bee5879375ab9e7a620e11e48ba482421f3cf',\n                },\n            ],\n        },\n        {\n            \"i\": h'00ad268c4d1f5826',\n            \"p\": [\n                {\n                    \"a\": 2,\n                    \"s\": \"1323d3d4707a58ad2e23ada4e9f1f49f5a5b4ac7b708eb0d61f738f48307e8ee\",\n                    \"c\": h'023456aa110d84b4ac747aebd82c3b005aca50bf457ebd5737a4414fac3ae7d94d',\n                },\n                {\n                    \"a\": 1,\n                    \"s\": \"56bcbcbb7cc6406b3fa5d57d2174f4eff8b4402b176926d3a57d3c3dcbb59d57\",\n                    \"c\": h'0273129c5719e599379a974a626363c333c56cafc0e6d01abe46d5808280789c63',\n                },\n            ],\n        },\n    ],\n    \"m\": \"http://localhost:3338\",\n    \"u\": \"sat\",\n}\n</code></pre> <p>The <code>h''</code> values are <code>bytes</code> but displayed as hex strings here.</p> <p>We serialize this JSON using CBOR which can be seen here. The resulting bytes are then serialized to a string using <code>base64_urlsafe</code> and the prefix <code>cashuB</code> is added. This leaves us with the following serialized TokenV4:</p> <pre><code>cashuBo2F0gqJhaUgA_9SLj17PgGFwgaNhYQFhc3hAYWNjMTI0MzVlN2I4NDg0YzNjZjE4NTAxNDkyMThhZjkwZjcxNmE1MmJmNGE1ZWQzNDdlNDhlY2MxM2Y3NzM4OGFjWCECRFODGd5IXVW-07KaZCvuWHk3WrnnpiDhHki6SCQh88-iYWlIAK0mjE0fWCZhcIKjYWECYXN4QDEzMjNkM2Q0NzA3YTU4YWQyZTIzYWRhNGU5ZjFmNDlmNWE1YjRhYzdiNzA4ZWIwZDYxZjczOGY0ODMwN2U4ZWVhY1ghAjRWqhENhLSsdHrr2Cw7AFrKUL9Ffr1XN6RBT6w659lNo2FhAWFzeEA1NmJjYmNiYjdjYzY0MDZiM2ZhNWQ1N2QyMTc0ZjRlZmY4YjQ0MDJiMTc2OTI2ZDNhNTdkM2MzZGNiYjU5ZDU3YWNYIQJzEpxXGeWZN5qXSmJjY8MzxWyvwObQGr5G1YCCgHicY2FtdWh0dHA6Ly9sb2NhbGhvc3Q6MzMzOGF1Y3NhdA\n</code></pre>"},{"location":"01/","title":"NUT-01: Mint public key exchange","text":"<p><code>mandatory</code></p> <p>This document outlines the exchange of the public keys of the mint <code>Bob</code> with the wallet user <code>Alice</code>. <code>Alice</code> uses the keys to unblind <code>Bob</code>'s blind signatures (see NUT-00).</p>"},{"location":"01/#description","title":"Description","text":"<p>Wallet user <code>Alice</code> receives public keys from mint <code>Bob</code> via <code>GET /v1/keys</code>. The set of all public keys for a set of amounts is called a keyset.</p> <p>The mint responds only with its <code>active</code> keysets. Keyset are <code>active</code> if the mint will sign promises with it. The mint will accept tokens from inactive keysets as inputs but will not sign with them for new outputs. The <code>active</code> keysets can change over time, for example due to key rotation. A list of all keysets, active and inactive, can be requested separately (see NUT-02).</p> <p>Note that a mint can support multiple keysets at the same time but will only respond with the active keysets on the endpoint <code>GET /v1/keys</code>. A wallet can ask for the keys of a specific (active or inactive) keyset via the endpoint <code>GET /v1/keys/{keyset_id}</code> (see NUT-02).</p>"},{"location":"01/#keyset-generation","title":"Keyset generation","text":"<p>Keysets are generated by the mint. The mint is free to use any key generation method they like. Each keyset is identified by its keyset <code>id</code> which can be computed by anyone from its public keys (see NUT-02).</p> <p>Keys in Keysets are maps of the form <code>{&lt;amount_1&gt; : &lt;mint_pubkey_1&gt;, &lt;amount_2&gt; : &lt;mint_pubkey_2&gt;, ...}</code> for each <code>&lt;amount_i&gt;</code> of the amounts the mint <code>Bob</code> supports and the corresponding public key <code>&lt;mint_pubkey_1&gt;</code>, that is <code>K_i</code> (see NUT-00). The mint MUST use the compressed Secp256k1 public key format to represent its public keys.</p>"},{"location":"01/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>GET https://mint.host:3338/v1/keys\n</code></pre> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/keys\n</code></pre> <p>Response <code>GetKeysResponse</code> of <code>Bob</code>:</p> <pre><code>{\n  \"keysets\": [\n    {\n      \"id\": &lt;keyset_id_hex_str&gt;,\n      \"unit\": &lt;currency_unit_str&gt;,\n      \"keys\": {\n        &lt;amount_int&gt;: &lt;public_key_str&gt;,\n        ...\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"01/#example-response","title":"Example response","text":"<pre><code>{\n  \"keysets\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"unit\": \"sat\",\n      \"keys\": {\n          \"1\": \"02194603ffa36356f4a56b7df9371fc3192472351453ec7398b8da8117e7c3e104\",\n          \"2\": \"03b0f36d6d47ce14df8a7be9137712c42bcdd960b19dd02f1d4a9703b1f31d7513\",\n          \"4\": \"0366be6e026e42852498efb82014ca91e89da2e7a5bd3761bdad699fa2aec9fe09\",\n          \"8\": \"0253de5237f189606f29d8a690ea719f74d65f617bb1cb6fbea34f2bc4f930016d\",\n          ...\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"02/","title":"NUT-02: Keysets and fees","text":"<p><code>mandatory</code></p> <p>A keyset is a set of public keys that the mint <code>Bob</code> generates and shares with its users. It refers to the set of public keys that each correspond to the amount values that the mint supports (e.g. <code>1, 2, 4, 8, ...</code>) respectively.</p> <p>Each keyset indicates its keyset <code>id</code>, the currency <code>unit</code>, whether the keyset is <code>active</code>, and an <code>input_fee_ppk</code> that determines the fees for spending ecash from this keyset.</p> <p>A mint can have multiple keysets at the same time. For example, it could have one keyset for each currency <code>unit</code> that it supports. Wallets should support multiple keysets. They must respect the <code>active</code> and the <code>input_fee_ppk</code> properties of the keysets they use.</p>"},{"location":"02/#keyset-properties","title":"Keyset properties","text":""},{"location":"02/#keyset-id","title":"Keyset ID","text":"<p>A keyset <code>id</code> is an identifier for a specific keyset. It can be derived by anyone who knows the set of public keys of a mint. Wallets CAN compute the keyset <code>id</code> for a given keyset by themselves to confirm that the mint is supplying the correct keyset ID (see below).</p> <p>The keyset <code>id</code> is in each <code>Proof</code> so it can be used by wallets to identify which mint and keyset it was generated from. The keyset field <code>id</code> is also present in the <code>BlindedMessages</code> sent to the mint and <code>BlindSignatures</code> returned from the mint (see NUT-00).</p>"},{"location":"02/#active-keysets","title":"Active keysets","text":"<p>Mints can have multiple keysets at the same time but MUST have at least one <code>active</code> keyset (see NUT-01). The <code>active</code> property determines whether the mint allows generating new ecash from this keyset. <code>Proofs</code> from inactive keysets with <code>active=false</code> are still accepted as inputs but new outputs (<code>BlindedMessages</code> and <code>BlindSignatures</code>) MUST be from <code>active</code> keysets only.</p> <p>To rotate keysets, a mint can generate a new active keyset and inactive an old one. If the <code>active</code> flag of an old keyset is set to <code>false</code>, no new ecash from this keyset can be generated and the outstanding ecash supply of that keyset can be taken out of circulation as wallets rotate their ecash to active keysets.</p> <p>Wallets SHOULD prioritize swaps with <code>Proofs</code> from inactive keysets (see NUT-03) so they can quickly get rid of them. Wallets CAN swap their entire balance from an inactive keyset to an active one as soon as they detect that the keyset was inactivated. When constructing outputs for a transaction, wallets MUST choose only <code>active</code> keysets (see NUT-00).</p>"},{"location":"02/#fees","title":"Fees","text":"<p>Keysets indicate the fee <code>input_fee_ppk</code> that is charged when a <code>Proof</code> of that keyset is spent as an input to a transaction. The fee is given in parts per thousand (ppk) per input measured in the <code>unit</code> of the keyset. The total fee for a transaction is the sum of all fees per input rounded up to the next larger integer (that that can be represented with the keyest).</p> <p>As an example, we construct a transaction spending 3 inputs (<code>Proofs</code>) from a keyset with unit <code>sat</code> and <code>input_fee_ppk</code> of <code>100</code>. A fee of <code>100 ppk</code> means <code>0.1 sat</code> per input. The sum of the individual fees are 300 ppk for this transaction. Rounded up to the next smallest denomination, the mint charges <code>1 sat</code> in total fees, i.e. <code>fees = ceil(0.3) == 1</code>. In this case, the fees for spending 1-10 inputs is 1 sat, 11-20 inputs is 2 sat and so on.</p>"},{"location":"02/#wallet-transaction-construction","title":"Wallet transaction construction","text":"<p>When constructing a transaction with ecash <code>inputs</code> (example: <code>/v1/swap</code> or <code>/v1/melt</code>), wallets MUST add fees to the inputs or, vice versa, subtract from the outputs. The mint checks the following equation:</p> <pre><code>sum(inputs) - fees == sum(outputs)\n</code></pre> <p>Here, <code>sum(inputs)</code> and <code>sum(outputs)</code> mean the sum of the amounts of the inputs and outputs respectively. <code>fees</code> is calculated from the sum of each input's fee and rounded up to the next larger integer:</p> <pre><code>def fees(inputs: List[Proof]) -&gt; int:\n  sum_fees = 0\n  for proof in inputs:\n    sum_fees += keysets[proof.id].input_fee_ppk\n  return (sum_fees + 999) // 1000\n</code></pre> <p>Here, the <code>//</code> operator in <code>(sum_fees + 999) // 1000</code> denotes an integer division operator (aka floor division operator) that rounds down <code>sum_fees + 999</code> to the next lower integer. Alternatively, we could round up the sum using a floating point division with <code>ceil(sum_fees / 1000)</code> although it is not recommended to do so due to the non-deterministic behavior of floating point division.</p> <p>Notice that since transactions can spend inputs from different keysets, the sum considers the fee for each <code>Proof</code> indexed by the keyset ID individually.</p>"},{"location":"02/#deriving-the-keyset-id","title":"Deriving the keyset ID","text":""},{"location":"02/#keyset-id-version","title":"Keyset ID version","text":"<p>Keyset IDs have a version byte (two hexadecimal characters). The currently used version byte is <code>00</code>.</p> <p>The mint and the wallets of its users can derive a keyset ID from the keyset of the mint. The keyset ID is a lower-case hex string. To derive the keyset ID of a keyset, execute the following steps:</p> <pre><code>1 - sort public keys by their amount in ascending order\n2 - concatenate all public keys to one byte array\n3 - HASH_SHA256 the concatenated public keys\n4 - take the first 14 characters of the hex-encoded hash\n5 - prefix it with a keyset ID version byte\n</code></pre> <p>An example implementation in Python:</p> <pre><code>def derive_keyset_id(keys: Dict[int, PublicKey]) -&gt; str:\n    sorted_keys = dict(sorted(keys.items()))\n    pubkeys_concat = b\"\".join([p.serialize() for p in sorted_keys.values()])\n    return \"00\" + hashlib.sha256(pubkeys_concat).hexdigest()[:14]\n</code></pre>"},{"location":"02/#example-get-mint-keysets","title":"Example: Get mint keysets","text":"<p>A wallet can ask the mint for a list of all keysets via the <code>GET /v1/keysets</code> endpoint.</p> <p>Request of <code>Alice</code>:</p> <pre><code>GET https://mint.host:3338/v1/keysets\n</code></pre> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/keysets\n</code></pre> <p>Response <code>GetKeysetsResponse</code> of <code>Bob</code>:</p> <pre><code>{\n  \"keysets\": [\n    {\n      \"id\": &lt;hex_str&gt;,\n      \"unit\": &lt;str&gt;,\n      \"active\": &lt;bool&gt;,\n      \"input_fee_ppk\": &lt;int|null&gt;,\n    },\n    ...\n  ]\n}\n</code></pre> <p>Here, <code>id</code> is the keyset ID, <code>unit</code> is the unit string (e.g. \"sat\") of the keyset, <code>active</code> indicates whether new ecash can be minted with this keyset, and <code>input_fee_ppk</code> is the fee (per thousand units) to spend one input spent from this keyset. If <code>input_fee_ppk</code> is not given, we assume it to be <code>0</code>.</p>"},{"location":"02/#example-response","title":"Example response","text":"<pre><code>{\n  \"keysets\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"unit\": \"sat\",\n      \"active\": True,\n      \"input_fee_ppk\": 100\n    },\n    {\n      \"id\": \"0042ade98b2a370a\",\n      \"unit\": \"sat\",\n      \"active\": False,\n      \"input_fee_ppk\": 100\n    },\n    {\n      \"id\": \"00c074b96c7e2b0e\",\n      \"unit\": \"usd\",\n      \"active\": True,\n      \"input_fee_ppk\": 100\n    }\n  ]\n}\n</code></pre>"},{"location":"02/#requesting-public-keys-for-a-specific-keyset","title":"Requesting public keys for a specific keyset","text":"<p>To receive the public keys of a specific keyset, a wallet can call the <code>GET /v1/keys/{keyset_id}</code> endpoint where <code>keyset_id</code> is the keyset ID.</p>"},{"location":"02/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <p>We request the keys for the keyset <code>009a1f293253e41e</code>.</p> <pre><code>GET https://mint.host:3338/v1/keys/009a1f293253e41e\n</code></pre> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/keys/009a1f293253e41e\n</code></pre> <p>Response of <code>Bob</code> (same as NUT-01):</p> <pre><code>{\n  \"keysets\": [{\n    \"id\": \"009a1f293253e41e\",\n    \"unit\": \"sat\",\n    \"keys\": {\n        \"1\": \"02194603ffa36356f4a56b7df9371fc3192472351453ec7398b8da8117e7c3e104\",\n        \"2\": \"03b0f36d6d47ce14df8a7be9137712c42bcdd960b19dd02f1d4a9703b1f31d7513\",\n        \"4\": \"0366be6e026e42852498efb82014ca91e89da2e7a5bd3761bdad699fa2aec9fe09\",\n        \"8\": \"0253de5237f189606f29d8a690ea719f74d65f617bb1cb6fbea34f2bc4f930016d\",\n        ...\n    },\n  }, ...\n  ]\n}\n</code></pre>"},{"location":"02/#wallet-implementation-notes","title":"Wallet implementation notes","text":"<p>Wallets can request the list of keyset IDs from the mint upon startup and load only tokens from its database that have a keyset ID supported by the mint it interacts with. This also helps wallets to determine whether the mint has added a new current keyset or whether it has changed the <code>active</code> flag of an existing one.</p> <p>A useful flow is:</p> <ul> <li>If we don't have any keys from this mint yet, get all keys: <code>GET /v1/keys</code> and store them</li> <li>Get all keysets with <code>GET /v1/keysets</code></li> <li>For all new keyset returned here which we don't have yet, get it using <code>GET /v1/keys/{keyset_id}</code> and store it</li> <li>If any of the keysets has changed its <code>active</code> flag, update it in the db and use the keyset accordingly</li> </ul>"},{"location":"03/","title":"NUT-03: Swap tokens","text":"<p><code>mandatory</code></p> <p>The swap operation is the most important component of the Cashu system. A swap operation consists of multiple inputs (<code>Proofs</code>) and outputs (<code>BlindedMessages</code>). Mints verify and invalidate the inputs and issue new promises (<code>BlindSignatures</code>). These are then used by the wallet to generate new <code>Proofs</code> (see NUT-00).</p> <p>The swap operation can serve multiple use cases. The first use case is that <code>Alice</code> can use it to split her tokens to a target amount she needs to send to <code>Carol</code>, if she does not have the necessary amounts to compose the target amount in her wallet already. The second one is that <code>Carols</code>'s wallet can use it to receive tokens from <code>Alice</code> by sending them as inputs to the mint and receive new outputs in return.</p>"},{"location":"03/#swap-to-send","title":"Swap to send","text":"<p>To make this more clear, we present an example of a typical case of sending tokens from <code>Alice</code> to <code>Carol</code>.</p> <p><code>Alice</code> has 64 sat in her wallet, composed of three <code>Proofs</code>, one worth 32 sat and another two worth 16 sat. She wants to send <code>Carol</code> 40 sat but does not have the necessary <code>Proofs</code> to compose the target amount of 40 sat. For that, <code>Alice</code> requests a swap from the mint and uses <code>Proofs</code> worth <code>[16, 16, 32]</code> as inputs and asks for new outputs worth <code>[8, 32, 8, 16]</code> totalling 64 sat. Notice that the first two tokens can now be combined to 40 sat. The <code>Proofs</code> that <code>Alice</code> sent <code>Bob</code> as inputs of the swap operation are now invalidated.</p> <p>Note: In order to preserve privacy around the amount that a client might want to send to another user and keep the rest as change, the client SHOULD ensure that the list requested outputs is ordered by amount in ascending order. As an example of what to avoid, a request for outputs expressed like so: <code>[16, 8, 2, 64, 8]</code> might imply the client is preparing a payment for 26 sat; the client should instead order the list like so: <code>[2, 8, 8, 16, 64]</code> to mitigate this privacy leak to the mint.</p>"},{"location":"03/#swap-to-receive","title":"Swap to receive","text":"<p>Another useful case for the swap operation follows up the example above where <code>Alice</code> has swapped her <code>Proofs</code> ready to be sent to <code>Carol</code>. <code>Carol</code> can receive these <code>Proofs</code> using the same operation by using them as inputs to invalidate them and request new outputs from <code>Bob</code>. Only if <code>Carol</code> has redeemed new outputs, <code>Alice</code> can't double-spend the <code>Proofs</code> anymore and the transaction is settled. To continue our example, <code>Carol</code> requests a swap with input <code>Proofs</code> worth <code>[32, 8]</code> to receive new outputs (of an arbitrary distribution) with the same total amount.</p>"},{"location":"03/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/swap\n</code></pre> <p>With the data being of the form <code>PostSwapRequest</code>:</p> <pre><code>{\n  \"inputs\": &lt;Array[Proof]&gt;,\n  \"outputs\": &lt;Array[BlindedMessage]&gt;,\n}\n</code></pre> <p>With curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/swap -d \\\n{\n  \"inputs\":\n    [\n      {\n        \"amount\": 2,\n        \"id\": \"009a1f293253e41e\",\n        \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n        \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n      },\n      {\n      ...\n      }\n    ],\n  \"outputs\":\n    [\n      {\n        \"amount\": 2,\n        \"id\": \"009a1f293253e41e\",\n        \"B_\": \"02634a2c2b34bec9e8a4aba4361f6bf202d7fa2365379b0840afe249a7a9d71239\"\n      },\n      {\n      ...\n      }\n    ],\n}\n</code></pre> <p>If successful, <code>Bob</code> will respond with a <code>PostSwapResponse</code></p> <pre><code>{\n  \"signatures\": &lt;Array[BlindSignature]&gt;\n}\n</code></pre>"},{"location":"04/","title":"NUT-04: Mint tokens","text":"<p><code>mandatory</code></p> <p>Minting tokens is a two-step process: requesting a mint quote and minting new tokens. Here, we describe both steps.</p> <p>In the first request the wallet asks the mint for a quote for a specific <code>amount</code> and <code>unit</code> to mint, and the payment <code>method</code> to pay. The mint responds with a quote that includes a <code>quote</code> id and a payment <code>request</code>. The user pays the <code>request</code> and, if successful, requests minting of new tokens with the mint in a second request. The wallet includes the <code>quote</code> id and new <code>outputs</code> in the second request.</p> <p>We limit this document to mint quotes of <code>unit=\"sat\"</code> and <code>method=\"bolt11\"</code> which requests a bolt11 Lightning invoice (typically generated by the mint to add Bitcoin to its reserves) to mint ecash denominated in Satoshis.</p>"},{"location":"04/#mint-quote","title":"Mint quote","text":"<p>To request a mint quote, the wallet of <code>Alice</code> makes a <code>POST /v1/mint/quote/{method}</code> request where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/mint/quote/bolt11\n</code></pre> <p>The wallet of <code>Alice</code> includes the following <code>PostMintQuoteBolt11Request</code> data in its request:</p> <pre><code>{\n  \"amount\": &lt;int&gt;,\n  \"unit\": &lt;str_enum[\"sat\"]&gt;,\n  \"description\": &lt;str|null&gt;\n}\n</code></pre> <p>with the requested <code>amount</code> and the <code>unit</code>. An optional <code>description</code> can be passed if the mint signals support for it in <code>MintMethodSetting</code>.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMintQuoteBolt11Response</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"request\": &lt;str&gt;,\n  \"state\": &lt;str_enum[STATE]&gt;,\n  \"expiry\": &lt;int&gt;\n}\n</code></pre> <p>Where <code>quote</code> is the quote ID and <code>request</code> is the payment request to fulfill. <code>expiry</code> is the Unix timestamp until which the mint quote is valid.</p> <p><code>state</code> is an enum string field with possible values <code>\"UNPAID\"</code>, <code>\"PAID\"</code>, <code>\"ISSUED\"</code>:</p> <ul> <li><code>\"UNPAID\"</code> means that the quote's request has not been paid yet.</li> <li><code>\"PAID\"</code> means that the request has been paid.</li> <li><code>\"ISSUED\"</code> means that the quote has already been issued.</li> </ul> <p>Note: <code>quote</code> is a unique and random id generated by the mint to internally look up the payment state. <code>quote</code> MUST remain a secret between user and mint and MUST NOT be derivable from the payment request. A third party who knows the <code>quote</code> ID can front-run and steal the tokens that this operation mints.</p>"},{"location":"04/#example","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST http://localhost:3338/v1/mint/quote/bolt11 -d '{\"amount\": 10, \"unit\": \"sat\"}' -H \"Content-Type: application/json\"\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"quote\": \"DSGLX9kevM...\",\n  \"request\": \"lnbc100n1pj4apw9...\",\n  \"state\": \"UNPAID\",\n  \"expiry\": 1701704757\n}\n</code></pre> <p>The wallet MUST store the <code>amount</code> in the request and the <code>quote</code> id in the response in its database so it can later request the tokens after paying the request. After payment, the wallet continues with the next section.</p>"},{"location":"04/#check-mint-quote-state","title":"Check mint quote state","text":"<p>To check whether a mint quote has been paid, <code>Alice</code> makes a <code>GET /v1/mint/quote/bolt11/{quote_id}</code>.</p> <pre><code>GET https://mint.host:3338/v1/mint/quote/bolt11/{quote_id}\n</code></pre> <p>Like before, the mint <code>Bob</code> responds with a <code>PostMintQuoteBolt11Response</code>.</p> <p>Example request of <code>Alice</code> with curl:</p> <pre><code>curl -X GET http://localhost:3338/v1/mint/quote/bolt11/DSGLX9kevM...\n</code></pre>"},{"location":"04/#minting-tokens","title":"Minting tokens","text":"<p>After requesting a mint quote and paying the request, the wallet proceeds with minting new tokens by calling the <code>POST /v1/mint/{method}</code> endpoint where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/mint/bolt11\n</code></pre> <p>The wallet <code>Alice</code> includes the following <code>PostMintBolt11Request</code> data in its request</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"outputs\": &lt;Array[BlindedMessage]&gt;\n}\n</code></pre> <p>with the <code>quote</code> being the quote ID from the previous step and <code>outputs</code> being <code>BlindedMessages</code> (see NUT-00) that the wallet requests signatures on whose sum is <code>amount</code> as requested in the quote.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMintBolt11Response</code>:</p> <pre><code>{\n  \"signatures\": &lt;Array[BlindSignature]&gt;\n}\n</code></pre> <p>where <code>signatures</code> is an array of blind signatures on the outputs.</p>"},{"location":"04/#example_1","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/mint/bolt11 -H \"Content-Type: application/json\" -d \\\n'{\n  \"quote\": \"DSGLX9kevM...\",\n  \"outputs\": [\n    {\n      \"amount\": 8,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"035015e6d7ade60ba8426cefaf1832bbd27257636e44a76b922d78e79b47cb689d\"\n    },\n    {\n      \"amount\": 2,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"0288d7649652d0a83fc9c966c969fb217f15904431e61a44b14999fabc1b5d9ac6\"\n    }\n  ]\n}'\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"signatures\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 2,\n      \"C_\": \"0224f1c4c564230ad3d96c5033efdc425582397a5a7691d600202732edc6d4b1ec\"\n    },\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 8,\n      \"C_\": \"0277d1de806ed177007e5b94a8139343b6382e472c752a74e99949d511f7194f6c\"\n    }\n  ]\n}\n</code></pre> <p>If the invoice was not paid yet, <code>Bob</code> responds with an error. In that case, <code>Alice</code> CAN repeat the same request until the Lightning invoice is settled.</p>"},{"location":"04/#unblinding-signatures","title":"Unblinding signatures","text":"<p>Upon receiving the <code>BlindSignatures</code> from the mint <code>Bob</code>, the wallet of <code>Alice</code> unblinds them to generate <code>Proofs</code> (using the blinding factor <code>r</code> and the mint's public key <code>K</code>, see BDHKE NUT-00). The wallet then stores these <code>Proofs</code> in its database:</p> <pre><code>[\n  {\n    \"id\": \"009a1f293253e41e\",\n    \"amount\": 2,\n    \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n    \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n  },\n  {\n    \"id\": \"009a1f293253e41e\",\n    \"amount\": 8,\n    \"secret\": \"fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be\",\n    \"C\": \"029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059\"\n  }\n]\n</code></pre>"},{"location":"04/#settings","title":"Settings","text":"<p>The settings for this nut indicate the supported method-unit pairs for minting and whether minting is disabled or not. They are part of the info response of the mint (NUT-06) which in this case reads</p> <pre><code>{\n  \"4\": {\n    \"methods\": [\n      &lt;MintMethodSetting&gt;,\n      ...\n    ],\n    \"disabled\": &lt;bool&gt;\n  }\n}\n</code></pre> <p><code>MintMethodSetting</code> indicates supported <code>method</code> and <code>unit</code> pairs and additional settings of the mint. <code>disabled</code> indicates whether this minting is disabled.</p> <p><code>MintMethodSetting</code> is of the form:</p> <pre><code>{\n  \"method\": &lt;str&gt;,\n  \"unit\": &lt;str&gt;,\n  \"min_amount\": &lt;int|null&gt;,\n  \"max_amount\": &lt;int|null&gt;,\n  \"description\": &lt;bool|null&gt;\n}\n</code></pre> <p><code>min_amount</code> and <code>max_amount</code> indicate the minimum and maximum amount for an operation of this method-unit pair.</p> <p>Example <code>MintMethodSetting</code>:</p> <pre><code>{\n  \"method\": \"bolt11\",\n  \"unit\": \"sat\",\n  \"min_amount\": 0,\n  \"max_amount\": 10000,\n  \"description\": true\n}\n</code></pre>"},{"location":"05/","title":"NUT-05: Melting tokens","text":"<p><code>mandatory</code></p> <p>Melting tokens is the opposite of minting tokens (see NUT-04). Like minting tokens, melting is a two-step process: requesting a melt quote and melting tokens. Here, we describe both steps.</p> <p>In the first request the wallet asks the mint for a quote for a <code>request</code> it wants paid by the mint and the <code>unit</code> the wallet would like to spend as inputs. The mint responds with a quote that includes a <code>quote</code> id and an <code>amount</code> the mint demands in the requested unit. For the method <code>bolt11</code>, the mint includes a <code>fee_reserve</code> field indicating the reserve fee for a Lightning payment.</p> <p>In the second request, the wallet includes the <code>quote</code> id and provides <code>inputs</code> that sum up to <code>amount+fee_reserve</code> in the first response. For the method <code>bolt11</code>, the wallet can also include <code>outputs</code> in order for the mint to return overpaid Lightning fees (see NUT-08). The mint responds with a payment status <code>paid</code> and a <code>proof</code> of payment. If the request included <code>outputs</code>, the mint may respond with <code>change</code> for the overpaid fees (see NUT-08).</p> <p>We limit this document to mint quotes of <code>unit=\"sat\"</code> and <code>method=\"bolt11\"</code> which requests a bolt11 Lightning payment (typically paid by the mint from its Bitcoin reserves) using ecash denominated in Satoshis.</p>"},{"location":"05/#melt-quote","title":"Melt quote","text":"<p>To request a melt quote, the wallet of <code>Alice</code> makes a <code>POST /v1/melt/quote/{method}</code> request where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/melt/quote/bolt11\n</code></pre> <p>The wallet <code>Alice</code> includes the following <code>PostMeltQuoteBolt11Request</code> data in its request:</p> <pre><code>{\n  \"request\": &lt;str&gt;,\n  \"unit\": &lt;str_enum[\"sat\"]&gt;\n}\n</code></pre> <p>Here, <code>request</code> is the bolt11 Lightning invoice to be paid and <code>unit</code> is the unit the wallet would like to pay with.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMeltQuoteBolt11Response</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"fee_reserve\": &lt;int&gt;,\n  \"state\": &lt;str_enum[STATE]&gt;,\n  \"expiry\": &lt;int&gt;,\n  \"payment_preimage\": &lt;str|null&gt;\n}\n</code></pre> <p>Where <code>quote</code> is the quote ID, <code>amount</code> the amount that needs to be provided, and <code>fee_reserve</code> the additional fee reserve that is required. The mint expects <code>Alice</code> to include <code>Proofs</code> of at least <code>total_amount = amount + fee_reserve</code>. <code>expiry</code> is the Unix timestamp until which the melt quote is valid. <code>payment_preimage</code> is the bolt11 payment preimage in case of a successful payment.</p> <p><code>state</code> is an enum string field with possible values <code>\"UNPAID\"</code>, <code>\"PENDING\"</code>, <code>\"PAID\"</code>:</p> <ul> <li><code>\"UNPAID\"</code> means that the request has not been paid yet.</li> <li><code>\"PENDING\"</code> means that the request is currently being paid.</li> <li><code>\"PAID\"</code> means that the request has been paid successfully.</li> </ul>"},{"location":"05/#example","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/melt/quote/bolt11 -d \\\n{\n  \"request\": \"lnbc100n1p3kdrv5sp5lpdxzghe5j67q...\",\n  \"unit\": \"sat\"\n}\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"quote\": \"TRmjduhIsPxd...\",\n  \"amount\": 10,\n  \"fee_reserve\": 2,\n  \"state\": \"UNPAID\",\n  \"expiry\": 1701704757\n}\n</code></pre>"},{"location":"05/#check-melt-quote-state","title":"Check melt quote state","text":"<p>To check whether a melt quote has been paid, <code>Alice</code> makes a <code>GET /v1/melt/quote/bolt11/{quote_id}</code>.</p> <pre><code>GET https://mint.host:3338/v1/melt/quote/bolt11/{quote_id}\n</code></pre> <p>Like before, the mint <code>Bob</code> responds with a <code>PostMeltQuoteBolt11Response</code>.</p> <p>Example request of <code>Alice</code> with curl:</p> <pre><code>curl -X GET http://localhost:3338/v1/melt/quote/bolt11/TRmjduhIsPxd...\n</code></pre>"},{"location":"05/#melting-tokens","title":"Melting tokens","text":"<p>Now that <code>Alice</code> knows what the total amount is (<code>amount + fee_reserve</code>) in her requested <code>unit</code>, she can proceed to melting tokens for which a payment will be executed by the mint. She calls the <code>POST /v1/melt/{method}</code> endpoint where <code>method</code> is the payment method requested (here <code>bolt11</code>).</p> <pre><code>POST https://mint.host:3338/v1/melt/bolt11\n</code></pre> <p>\u26a0\ufe0f Attention: This call will block until the Lightning payment either succeeds or fails. This can take quite a long time in case the Lightning payment is slow. Make sure to use no (or a very long) timeout when making this call!</p> <p>The wallet of <code>Alice</code> includes the following <code>PostMeltBolt11Request</code> data in its request</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"inputs\": &lt;Array[Proof]&gt;\n}\n</code></pre> <p>Here, <code>quote</code> is the melt quote ID to be paid and <code>inputs</code> are the proofs with a total amount of at least <code>amount + fee_reserve</code> (see previous melt quote response).</p> <p>Like before, the mint <code>Bob</code> then responds with a <code>PostMeltQuoteBolt11Response</code>. If the payment was successful, the <code>state</code> field is set to <code>\"PAID\"</code> and the response includes the <code>payment_preimage</code> field containing the payment secret of the bolt11 payment.</p> <p>If <code>state==\"PAID\"</code>, <code>Alice</code>'s wallet can delete the <code>inputs</code> from her database (or move them to a history). If <code>state==\"UNPAID\"</code>, <code>Alice</code> can repeat the same request again until the payment is successful.</p>"},{"location":"05/#example_1","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/melt/bolt11 -d \\\n'{\n  \"quote\": \"od4CN5smMMS3K3QVHkbGGNCTxfcAIyIXeq8IrfhP\",\n  \"inputs\": [\n    {\n      \"amount\": 4,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"429700b812a58436be2629af8731a31a37fce54dbf8cbbe90b3f8553179d23f5\",\n      \"C\": \"03b01869f528337e161a6768b480fcf9f75fd248b649c382f5e352489fd84fd011\",\n    },\n    {\n      \"amount\": 8,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"4f3155acef6481108fcf354f6d06e504ce8b441e617d30c88924991298cdbcad\",\n      \"C\": \"0278ab1c1af35487a5ea903b693e96447b2034d0fd6bac529e753097743bf73ca9\",\n    }\n  ]\n}'\n</code></pre> <p>Response <code>PostMeltQuoteBolt11Response</code> of <code>Bob</code>:</p> <pre><code>{\n  \"quote\": \"TRmjduhIsPxd...\",\n  \"amount\": 10,\n  \"fee_reserve\": 2,\n  \"state\": \"PAID\",\n  \"expiry\": 1701704757,\n  \"payment_preimage\": \"c5a1ae1f639e1f4a3872e81500fd028bece7bedc1152f740cba5c3417b748c1b\"\n}\n</code></pre>"},{"location":"05/#settings","title":"Settings","text":"<p>The mint's settings for this nut indicate the supported method-unit pairs for melting. They are part of the info response of the mint (NUT-06) which in this case reads</p> <pre><code>{\n  \"5\": {\n    \"methods\": [\n      &lt;MeltMethodSetting&gt;,\n      ...\n    ],\n    \"disabled\": &lt;bool&gt;\n  }\n}\n</code></pre> <p><code>MeltMethodSetting</code> indicates supported <code>method</code> and <code>unit</code> pairs and additional settings of the mint. <code>disabled</code> indicates whether melting is disabled.</p> <p><code>MeltMethodSetting</code> is of the form:</p> <pre><code>{\n  \"method\": &lt;str&gt;,\n  \"unit\": &lt;str&gt;,\n  \"min_amount\": &lt;int|null&gt;,\n  \"max_amount\": &lt;int|null&gt;\n}\n</code></pre> <p><code>min_amount</code> and <code>max_amount</code> indicate the minimum and maximum amount for an operation of this method-unit pair.</p> <p>Example <code>MeltMethodSetting</code>:</p> <pre><code>{\n  \"method\": \"bolt11\",\n  \"unit\": \"sat\",\n  \"min_amount\": 100,\n  \"max_amount\": 10000\n}\n</code></pre>"},{"location":"06/","title":"NUT-06: Mint information","text":"<p><code>mandatory</code></p> <p>This endpoint returns information about the mint that a wallet can show to the user and use to make decisions on how to interact with the mint.</p>"},{"location":"06/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>GET https://mint.host:3338/v1/info\n</code></pre> <p>With the mint's response being of the form <code>GetInfoResponse</code>:</p> <pre><code>{\n  \"name\": \"Bob's Cashu mint\",\n  \"pubkey\": \"0283bf290884eed3a7ca2663fc0260de2e2064d6b355ea13f98dec004b7a7ead99\",\n  \"version\": \"Nutshell/0.15.0\",\n  \"description\": \"The short mint description\",\n  \"description_long\": \"A description that can be a long piece of text.\",\n  \"contact\": [\n    {\n      \"method\": \"email\",\n      \"info\": \"contact@me.com\"\n    },\n    {\n      \"method\": \"twitter\",\n      \"info\": \"@me\"\n    },\n    {\n      \"method\": \"nostr\",\n      \"info\": \"npub...\"\n    }\n  ],\n  \"motd\": \"Message to display to users.\",\n  \"icon_url\": \"https://mint.host/icon.jpg\",\n  \"time\": 1725304480,\n  \"nuts\": {\n    \"4\": {\n      \"methods\": [\n        {\n          \"method\": \"bolt11\",\n          \"unit\": \"sat\",\n          \"min_amount\": 0,\n          \"max_amount\": 10000\n        }\n      ],\n      \"disabled\": false\n    },\n    \"5\": {\n      \"methods\": [\n        {\n          \"method\": \"bolt11\",\n          \"unit\": \"sat\",\n          \"min_amount\": 100,\n          \"max_amount\": 10000\n        }\n      ],\n      \"disabled\": false\n    },\n    \"7\": {\n      \"supported\": true\n    },\n    \"8\": {\n      \"supported\": true\n    },\n    \"9\": {\n      \"supported\": true\n    },\n    \"10\": {\n      \"supported\": true\n    },\n    \"12\": {\n      \"supported\": true\n    }\n  }\n}\n</code></pre> <ul> <li>(optional) <code>name</code> is the name of the mint and should be recognizable.</li> <li>(optional) <code>pubkey</code> is the hex pubkey of the mint.</li> <li>(optional) <code>version</code> is the implementation name and the version of the software running on this mint separated with a slash \"/\".</li> <li>(optional) <code>description</code> is a short description of the mint that can be shown in the wallet next to the mint's name.</li> <li>(optional) <code>description_long</code> is a long description that can be shown in an additional field.</li> <li>(optional) <code>contact</code> is an array of contact objects to reach the mint operator. A contact object consists of two fields. The <code>method</code> field denotes the contact method (like \"email\"), the <code>info</code> field denotes the identifier (like \"contact@me.com\").</li> <li>(optional) <code>motd</code> is the message of the day that the wallet must display to the user. It should only be used to display important announcements to users, such as scheduled maintenances.</li> <li>(optional) <code>icon_url</code> is the URL pointing to an image to be used as an icon for the mint. Recommended to be squared in shape.</li> <li>(optional) <code>time</code> is the current time set on the server. The value is passed as a Unix timestamp integer.</li> <li>(optional) <code>nuts</code> indicates each NUT specification that the mint supports and its settings. The settings are defined in each NUT separately.</li> </ul> <p>With curl:</p> <pre><code>curl -X GET https://mint.host:3338/v1/info\n</code></pre>"},{"location":"07/","title":"NUT-07: Token state check","text":"<p><code>optional</code></p> <p>With the token state check, wallets can ask the mint whether a specific proof is already spent and whether it is in-flight in a transaction. Wallets can also request the witness data that was used to spend a proof.</p>"},{"location":"07/#token-states","title":"Token states","text":"<p>A proof can be in one of the following states</p> <ul> <li>A proof is <code>UNSPENT</code> if it has not been spent yet</li> <li>A proof is <code>PENDING</code> if it is being processed in a transaction (in an ongoing payment). A <code>PENDING</code> proof cannot be used in another transaction until it is <code>live</code> again.</li> <li>A proof is <code>SPENT</code> if it has been redeemed and its secret is in the list of spent secrets of the mint.</li> </ul> <p>Note: Before deleting spent proofs from their database, wallets can check if the proof is <code>SPENT</code> to make sure that they don't accidentally delete an unspent proof. Beware that this behavior can make it easier for the mint to correlate the sender to the receiver.</p> <p>Important: Mints MUST remember which proofs are currently <code>PENDING</code> to avoid reuse of the same token in multiple concurrent transactions. This can be achieved with for example mutex lock whose key is the <code>Proof</code>'s <code>Y</code>.</p>"},{"location":"07/#use-cases","title":"Use cases","text":""},{"location":"07/#example-1-ecash-transaction","title":"Example 1: Ecash transaction","text":"<p>When <code>Alice</code> prepares a token to be sent to <code>Carol</code>, she can mark these tokens in her database as pending. She can then, periodically or upon user input, check with the mint if the token is <code>UNSPENT</code> or whether it has been redeemed by <code>Carol</code> already, i.e., is <code>SPENT</code>. If the proof is not spendable anymore (and, thus, has been redeemed by <code>Carol</code>), she can safely delete the proof from her database.</p>"},{"location":"07/#example-2-lightning-payments","title":"Example 2: Lightning payments","text":"<p>If <code>Alice</code>'s melt operation takes a long time to complete (for example if she requests a very slow Lightning payment) and she closes her wallet in the meantime, the next time she comes online, she can check all proofs marked as pending in her database to determine whether the payment is still in flight (mint returns <code>PENDING</code>), it has succeeded (mint returns <code>SPENT</code>), or it has failed (mint returns <code>UNSPENT</code>).</p>"},{"location":"07/#example","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/checkstate\n</code></pre> <p>With the data being of the form <code>PostCheckStateRequest</code>:</p> <pre><code>{\n  \"Ys\": &lt;Array[hex_str]&gt;,\n}\n</code></pre> <p>Where the elements of the array in <code>Ys</code> are the hexadecimal representation of the compressed point <code>Y = hash_to_curve(secret)</code> of the <code>Proof</code> to check (see NUT-00).</p> <p>Response of <code>Bob</code>:</p> <p><code>Bob</code> will respond with a <code>PostCheckStateResponse</code></p> <pre><code>{\n  \"states\": [\n    {\n      \"Y\": &lt;hex_str&gt;,\n      \"state\": &lt;str_enum[STATE]&gt;,\n      \"witness\": &lt;str|null&gt;,\n    },\n    ...\n  ]\n}\n</code></pre> <ul> <li><code>Y</code> corresponds to the <code>Proof</code> checked in the request.</li> <li><code>state</code> is an enum string field with possible values <code>\"UNSPENT\"</code>, <code>\"PENDING\"</code>, <code>\"SPENT\"</code></li> <li><code>witness</code> is the serialized witness data that was used to spend the <code>Proof</code> if the token required it such as in the case of P2PK (see NUT-11).</li> </ul> <p>With curl:</p> <p>Request of <code>Alice</code>:</p> <pre><code>curl -X POST https://mint.host:3338/v1/checkstate -H 'Content-Type: application/json' -d '{\n  \"Ys\": [\n    \"02599b9ea0a1ad4143706c2a5a4a568ce442dd4313e1cf1f7f0b58a317c1a355ee\"\n  ]\n}'\n</code></pre> <p>Response of <code>Bob</code>:</p> <pre><code>{\n  \"states\": [\n    {\n      \"Y\": \"02599b9ea0a1ad4143706c2a5a4a568ce442dd4313e1cf1f7f0b58a317c1a355ee\",\n      \"state\": \"SPENT\",\n      \"witness\": \"{\\\"signatures\\\": [\\\"b2cf120a49cb1ac3cb32e1bf5ccb6425e0a8372affdc1d41912ca35c13908062f269c0caa53607d4e1ac4c8563246c4c8a869e6ee124ea826fd4746f3515dc1e\\\"]}\"\n    }\n  ]\n}\n</code></pre> <p>Where <code>Y</code> belongs to the provided <code>Proof</code> to check in the request, <code>state</code> indicates its state, and <code>witness</code> is the witness data that was potentially provided in a previous spend operation (can be empty).</p>"},{"location":"08/","title":"NUT-08: Lightning fee return","text":"<p><code>optional</code>, <code>depends on: NUT-05</code></p> <p>This document describes how the overpaid Lightning fees are handled and extends NUT-05 which describes melting tokens (i.e. paying a Lightning invoice). In short, a wallet includes blank outputs when paying a Lightning invoice which can be assigned a value by the mint if the user has overpaid Lightning fees. This can be the case due to the unpredictability of Lightning network fees. To solve this issue, we introduce so-called blank outputs which are blinded messages with an undetermined value.</p> <p>The problem is also described in this gist.</p>"},{"location":"08/#description","title":"Description","text":"<p>Before requesting a Lightning payment as described in NUT-05, <code>Alice</code> produces a number of <code>BlindedMessage</code> which are similar to ordinary blinded messages but their value is yet to be determined by the mint <code>Bob</code> and are thus called blank outputs. The number of necessary blank outputs is <code>max(ceil(log2(fee_reserve)), 1)</code> which ensures that there is at least one output if there is any fee. If the <code>fee_reserve</code> is <code>0</code>, then the number of blank outputs is <code>0</code> as well. The blank outputs will contain the overpaid fees that will be returned by the mint to the wallet.</p> <p>This code calculates the number of necessary blank outputs in Python:</p> <pre><code>def calculate_number_of_blank_outputs(fee_reserve_sat: int) -&gt; int:\n    assert fee_reserve_sat &gt;= 0, \"Fee reserve can't be negative.\"\n    if fee_reserve_sat == 0:\n        return 0\n    return max(math.ceil(math.log2(fee_reserve_sat)), 1)\n</code></pre>"},{"location":"08/#example","title":"Example","text":"<p>The wallet wants to pay an invoice with <code>amount := 100 000 sat</code> and determines by asking the mint that <code>fee_reserve</code> is <code>1000 sats</code>. The wallet then provides <code>101 000 sat</code> worth of proofs and 10 blank <code>outputs</code> to make the payment (since <code>ceil(log2(1000))=ceil(9.96..)=10</code>). The mint pays the invoice and determines that the actual fee was <code>100 sat</code>, i.e, the overpaid fee to return is <code>fee_return = 900 sat</code>. The mint splits the amount <code>900</code> into summands of <code>2^n</code> which is <code>4, 128, 256, 512</code>. The mint inserts these amounts into the blank <code>outputs</code> it received form the wallet and generates 4 new promises. The mint then returns these <code>BlindSignature</code>s to the wallet together with the successful payment status.</p>"},{"location":"08/#wallet-flow","title":"Wallet flow","text":"<p>The wallet asks the mint for the <code>fee_reserve</code> for paying a specific bolt11 invoice of value <code>amount</code> by calling <code>POST /v1/melt/quote</code> as described in NUT-05. The wallet then provides a <code>PostMeltBolt11Request</code> to <code>POST /v1/melt/bolt11</code> that has (1) proofs of the value <code>amount+fee_reserve</code>, (2) the bolt11 invoice to be paid, and finally, as a new entry, (3) a field <code>outputs</code> that has <code>n_blank_outputs</code> blinded messages that are generated before the payment attempt to receive potential overpaid fees back to her.</p>"},{"location":"08/#mint-flow","title":"Mint flow","text":"<p>Here we describe how the mint generates <code>BlindSignature</code>s for the overpaid fees. The mint <code>Bob</code> returns in <code>PostMeltQuoteBolt11Response</code> the field <code>change</code> ONLY IF <code>Alice</code> has previously provided <code>outputs</code> for the change AND if the Lightning <code>actual_fees</code> were smaller than the <code>fee_reserve</code>.</p> <p>If the <code>overpaid_fees = fee_reserve - actual_fees</code> is positive, <code>Bob</code> decomposes it to values of <code>2^n</code> (as in NUT-00) and then imprints them into the <code>blank_outputs</code> provided by <code>Alice</code>.</p> <p><code>Bob</code> then signs these blank outputs (now with the imprinted amounts) and thus generates <code>BlindSignature</code>s. <code>Bob</code> then returns a payment status to the wallet, and, in addition, all blind signatures it generated for the overpaid fees.</p> <p>Importantly, while <code>Bob</code> does not necessarily return the same number of blind signatures as it received blank outputs from <code>Alice</code> (since some of them may be of value 0), <code>Bob</code> MUST return the all blank signatures with a value greater than 0 in the same order as the blank outputs were received and should omit all blind signatures with value 0. For example, if <code>Bob</code> receives 10 blank outputs but the overpaid fees only occupy 4 blind signatures, <code>Bob</code> will only return these 4 blind signatures with the appropriate imprinted amounts and omit the remaining 6 blind signatures with value 0. Due to the well-defined order of the returned blind signatures, <code>Alice</code> can map the blind signatures returned from <code>Bob</code> to the blank outputs it provided so that she can further apply the correct unblinding operations on them.</p>"},{"location":"08/#example_1","title":"Example","text":"<p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/melt/bolt11\n</code></pre> <p>With the data being of the form <code>PostMeltBolt11Request</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"inputs\": &lt;Array[Proof]&gt;,\n  \"outputs\": &lt;Array[BlindedMessage]&gt; &lt;-- New\n}\n</code></pre> <p>where the new <code>output</code> field carries the <code>BlindMessages</code>.</p> <p>The mint <code>Bob</code> then responds with a <code>PostMeltQuoteBolt11Response</code>:</p> <pre><code>{\n  \"quote\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"fee_reserve\": &lt;int&gt;,\n  \"state\": &lt;str_enum[STATE]&gt;,\n  \"expiry\": &lt;int&gt;,\n  \"payment_preimage\": &lt;str|null&gt;,\n  \"change\": &lt;Array[BlindSignature]&gt; &lt;-- New\n}\n</code></pre> <p>where the new <code>change</code> field carries the returned <code>BlindSignature</code>s due to overpaid fees.</p>"},{"location":"08/#example_2","title":"Example","text":"<p>Request of <code>Alice</code> with curl:</p> <pre><code>curl -X POST https://mint.host:3338/v1/melt/bolt11 -d \\\n'{\n  \"quote\": \"od4CN5smMMS3K3QVHkbGGNCTxfcAIyIXeq8IrfhP\",\n  \"inputs\": [\n    {\n      \"amount\": 4,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"429700b812a58436be2629af8731a31a37fce54dbf8cbbe90b3f8553179d23f5\",\n      \"C\": \"03b01869f528337e161a6768b480fcf9f75fd248b649c382f5e352489fd84fd011\",\n    },\n    {\n      \"amount\": 8,\n      \"id\": \"009a1f293253e41e\",\n      \"secret\": \"4f3155acef6481108fcf354f6d06e504ce8b441e617d30c88924991298cdbcad\",\n      \"C\": \"0278ab1c1af35487a5ea903b693e96447b2034d0fd6bac529e753097743bf73ca9\",\n    }\n  ],\n  \"outputs\": [\n    {\n      \"amount\": 1,\n      \"id\": \"009a1f293253e41e\",\n      \"B_\": \"03327fc4fa333909b70f08759e217ce5c94e6bf1fc2382562f3c560c5580fa69f4\"\n    }\n  ]\n}'\n</code></pre> <p>Everything here is the same as in NUT-05 except for <code>outputs</code>. The <code>amount</code> field in the <code>BlindedMessage</code>s here are ignored by <code>Bob</code> so they can be set to any arbitrary value by <code>Alice</code> (they should be set to a value, like <code>1</code> so potential JSON validations do not error).</p> <p>If the mint has made a successful payment, it will respond the following.</p> <p>Response <code>PostMeltQuoteBolt11Response</code> from <code>Bob</code>:</p> <pre><code>{\n  \"state\": \"PAID\",\n  \"payment_preimage\": \"c5a1ae1f639e1f4a3872e81500fd028bece7bedc1152f740cba5c3417b748c1b\",\n  \"change\": [\n    {\n      \"id\": \"009a1f293253e41e\",\n      \"amount\": 2,\n      \"C_\": \"03c668f551855ddc792e22ea61d32ddfa6a45b1eb659ce66e915bf5127a8657be0\"\n    }\n  ]\n}\n</code></pre> <p>The field <code>change</code> is an array of <code>BlindSignatures</code> that account for the overpaid fees. Notice that the amount has been changed by the mint. <code>Alice</code> must take these and generate <code>Proofs</code> by unblinding them as described in NUT-00 and as she does in NUT-04 when minting new tokens. After generating the <code>Proofs</code>, <code>Alice</code> stores them in her database.</p>"},{"location":"09/","title":"NUT-09: Restore signatures","text":"<p><code>optional</code> <code>used in: NUT-13</code></p> <p>In this document, we describe how wallets can recover blind signatures, and with that their corresponding <code>Proofs</code>, by requesting from the mint to reissue the blind signatures. This can be used for a backup recovery of a lost wallet (see NUT-09) or for recovering the response of an interrupted swap request (see NUT-03).</p> <p>Mints must store the <code>BlindedMessage</code> and the corresponding <code>BlindSignature</code> in their database every time they issue a <code>BlindSignature</code>. Wallets provide the <code>BlindedMessage</code> for which they request the <code>BlindSignature</code>. Mints only respond with a <code>BlindSignature</code>, if they have previously signed the <code>BlindedMessage</code>. Each returned <code>BlindSignature</code> also contains the <code>amount</code> and the keyset <code>id</code> (see NUT-00) which is all the necessary information for a wallet to recover a <code>Proof</code>.</p> <p>Request of <code>Alice</code>:</p> <pre><code>POST https://mint.host:3338/v1/restore\n</code></pre> <p>With the data being of the form <code>PostRestoreRequest</code>:</p> <pre><code>{\n  \"outputs\": &lt;Array[BlindedMessages]&gt;\n}\n</code></pre> <p>Response of <code>Bob</code>:</p> <p>The mint <code>Bob</code> then responds with a <code>PostRestoreResponse</code>.</p> <pre><code>{\n  \"outputs\": &lt;Array[BlindedMessages]&gt;,\n  \"signatures\": &lt;Array[BlindSignature]&gt;\n}\n</code></pre> <p>The returned arrays <code>outputs</code> and <code>signatures</code> are of the same length and for every entry <code>outputs[i]</code>, there is a corresponding entry <code>signatures[i]</code>.</p>"},{"location":"10/","title":"NUT-10: Spending conditions","text":"<p><code>optional</code></p> <p>An ordinary ecash token is a set of <code>Proofs</code> each with a random string <code>secret</code>. To spend such a token in a swap or a melt operation, wallets include <code>proofs</code> in their request each with a unique <code>secret</code>. To autorize a transaction, the mint requires that the <code>secret</code> has not been seen before. This is the most fundamental spending condition in Cashu, which ensures that a token can't be double-spent.</p> <p>In this NUT, we define a well-known format of <code>secret</code> that can be used to express more complex spending conditions. These conditions need to be met before the mint authorizes a transaction. Note that the specific type of spending condition is not part of this document but will be explained in other documents. Here, we describe the structure of <code>secret</code> which is expressed as a JSON <code>Secret</code> with a specific format.</p> <p>Spending conditions are enforced by the mint which means that, upon encountering a <code>Proof</code> where <code>Proof.secret</code> can be parsed into the well-known format, the mint can require additional conditions to be met.</p> <p>Caution: If the mint does not support spending conditions or a specific <code>kind</code> of spending condition, proofs may be treated as a regular anyone-can-spend tokens. Applications need to make sure to check whether the mint supports a specific <code>kind</code> of spending condition by checking the mint's info endpoint.</p>"},{"location":"10/#basic-components","title":"Basic components","text":"<p>An ecash transaction, i.e., a swap or a melt operation, with a spending condition consists of the following components:</p> <ul> <li>Inputs referring to the <code>Proofs</code> being spent</li> <li><code>Secret</code> containing the rules for unlocking a <code>Proof</code></li> <li>Additional witness data satisfying the unlock conditions such as signatures</li> <li>Outputs referring to the <code>BlindMessages</code> with new unlock conditions to which the <code>Proofs</code> are spent to</li> </ul> <p>Spending conditions are defined for each individual <code>Proof</code> and not on a transaction level that can consist of multiple <code>Proofs</code>. Similarly, spending conditions must be satisfied by providing signatures or additional witness data for each <code>Proof</code> separately. For a transaction to be valid, all <code>Proofs</code> in that transaction must be unlocked successfully.</p> <p>New <code>Secret</code>s of the outputs to which the inputs are spent to are provided as <code>BlindMessages</code> which means that they are blind-signed and not visible to the mint until they are actually spent.</p>"},{"location":"10/#well-known-secret","title":"Well-known Secret","text":"<p>Spending conditions are expressed in a well-known secret format that is revealed to the mint when spending (unlocking) a token, not when the token is minted (locked). The mint parses each <code>Proof</code>'s <code>secret</code>. If it can deserialize it into the following format it executes additional spending conditions that are further specified in additional NUTs.</p> <p>The well-known <code>Secret</code> stored in <code>Proof.secret</code> is a JSON of the format:</p> <pre><code>[\nkind &lt;str&gt;,\n  {\n    \"nonce\": &lt;str&gt;,\n    \"data\": &lt;str&gt;,\n    \"tags\": [[ \"key\", \"value1\", \"value2\", ...],  ... ], // (optional)\n  }\n]\n</code></pre> <ul> <li><code>kind</code> is the kind of the spending condition</li> <li><code>nonce</code> is a unique random string</li> <li><code>data</code> expresses the spending condition specific to each kind</li> <li><code>tags</code> hold additional data committed to and can be used for feature extensions</li> </ul>"},{"location":"10/#examples","title":"Examples","text":"<p>Example use cases of this secret format are</p> <ul> <li>NUT-11: Pay-to-Public-Key (P2PK)</li> </ul>"},{"location":"11/","title":"NUT-11: Pay to Public Key (P2PK)","text":"<p><code>optional</code>, <code>depends on: NUT-10</code></p> <p>This NUT describes Pay-to-Public-Key (P2PK) which is one kind of spending condition based on NUT-10's well-known <code>Secret</code>. Using P2PK, we can lock ecash tokens to a receiver's ECC public key and require a Schnorr signature with the corresponding private key to unlock the ecash. The spending condition is enforced by the mint.</p> <p>Caution: If the mint does not support this type of spending condition, proofs may be treated as a regular anyone-can-spend tokens. Applications need to make sure to check whether the mint supports a specific kind of spending condition by checking the mint's info endpoint.</p>"},{"location":"11/#pay-to-pubkey","title":"Pay-to-Pubkey","text":"<p>NUT-10 Secret <code>kind: P2PK</code></p> <p>If for a <code>Proof</code>, <code>Proof.secret</code> is a <code>Secret</code> of kind <code>P2PK</code>, the proof must be unlocked by providing a witness <code>Proof.witness</code> and one or more valid signatures in the array <code>Proof.witness.signatures</code>.</p> <p>In the basic case, when spending a locked token, the mint requires one valid Schnorr signature in <code>Proof.witness.signatures</code> on <code>Proof.secret</code> by the public key in <code>Proof.Secret.data</code>.</p> <p>To give a concrete example of the basic case, to mint a locked token we first create a P2PK <code>Secret</code> that reads:</p> <pre><code>[\n  \"P2PK\",\n  {\n    \"nonce\": \"859d4935c4907062a6297cf4e663e2835d90d97ecdd510745d32f6816323a41f\",\n    \"data\": \"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\",\n    \"tags\": [[\"sigflag\", \"SIG_INPUTS\"]]\n  }\n]\n</code></pre> <p>Here, <code>Secret.data</code> is the public key of the recipient of the locked ecash. We serialize this <code>Secret</code> to a string in <code>Proof.secret</code> and get a blind signature by the mint that is stored in <code>Proof.C</code> (see NUT-03]).</p> <p>The recipient who owns the private key of the public key <code>Secret.data</code> can spend this proof by providing a signature on the serialized <code>Proof.secret</code> string that is then added to <code>Proof.witness.signatures</code>:</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"859d4935c4907062a6297cf4e663e2835d90d97ecdd510745d32f6816323a41f\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"60f3c9b766770b46caac1d27e1ae6b77c8866ebaeba0b9489fe6a15a837eaa6fcd6eaa825499c72ac342983983fd3ba3a8a41f56677cc99ffd73da68b59e1383\\\"]}\"\n}\n</code></pre>"},{"location":"11/#signature-scheme","title":"Signature scheme","text":"<p>To spend a token locked with <code>P2PK</code>, the spender needs to include signatures in the spent proofs. We use <code>libsecp256k1</code>'s serialized 64 byte Schnorr signatures on the SHA256 hash of the message to sign. The message to sign is the field <code>Proof.secret</code> in the inputs. If indicated by <code>Secret.tags.sigflag</code> in the inputs, outputs might also require signatures on the message <code>BlindedMessage.B_</code>.</p> <p>An ecash spending operation like swap and melt can have multiple inputs and outputs. If we have more than one input or output, we provide signatures in each <code>Proof</code> and <code>BlindedMessage</code> individually. The inputs are the <code>Proofs</code> provided in the <code>inputs</code> field and the outputs are the <code>BlindedMessages</code> in the <code>outputs</code> field in the request body (see <code>PostMeltRequest</code> in NUT-05 and <code>PostSwapRequest</code> in NUT-03).</p>"},{"location":"11/#tags","title":"Tags","text":"<p>More complex spending conditions can be defined in the tags in <code>Proof.tags</code>. All tags are optional. Tags are arrays with two or more strings being <code>[\"key\", \"value1\", \"value2\", ...]</code>.</p> <p>Supported tags are:</p> <ul> <li><code>sigflag: &lt;str&gt;</code> determines whether outputs have to be signed as well</li> <li><code>n_sigs: &lt;int&gt;</code> specifies the minimum number of valid signatures expected</li> <li><code>pubkeys: &lt;hex_str&gt;</code> are additional public keys that can provide signatures (allows multiple entries)</li> <li><code>locktime: &lt;int&gt;</code> is the Unix timestamp of when the lock expires</li> <li><code>refund: &lt;hex_str&gt;</code> are optional refund public keys that can exclusively spend after <code>locktime</code> (allows multiple entries)</li> </ul> <p>Note: The tag serialization type is <code>[&lt;str&gt;, &lt;str&gt;, ...]</code> but some tag values are <code>int</code>. Wallets and mints must cast types appropriately for de/serialization.</p>"},{"location":"11/#signature-flags","title":"Signature flags","text":"<p>Signature flags are defined in the tag <code>Secret.tags['sigflag']</code>. Currently, there are two signature flags.</p> <ul> <li><code>SIG_INPUTS</code> requires valid signatures on all inputs. It is the default signature flag and will be applied even if the <code>sigflag</code> tag is absent.</li> <li><code>SIG_ALL</code> requires valid signatures on all inputs and on all outputs.</li> </ul> <p>The signature flag <code>SIG_ALL</code> is enforced if at least one of the <code>Proofs</code> have the flag <code>SIG_ALL</code>. Otherwise, <code>SIG_INPUTS</code> is enforced.</p>"},{"location":"11/#signature","title":"Signature","text":"<p>Signatures must be provided in the field <code>Proof.witness.signatures</code> for each <code>Proof</code> which is an input. If the signature flag <code>SIG_ALL</code> is enforced, signatures must also be provided for every output in its field <code>BlindedMessage.witness.signatures</code>.</p>"},{"location":"11/#signed-inputs","title":"Signed inputs","text":"<p>A <code>Proof</code> (an input) with a signature <code>P2PKWitness.signatures</code> on <code>secret</code> is the JSON (see NUT-00):</p> <pre><code>{\n  \"amount\": &lt;int&gt;,\n  \"secret\": &lt;str&gt;,\n  \"C\": &lt;hex_str&gt;,\n  \"id\": &lt;str&gt;,\n  \"witness\": &lt;P2PKWitness | str&gt; // Signatures on \"secret\"\n}\n</code></pre> <p>The <code>secret</code> of each input is signed as a string.</p>"},{"location":"11/#signed-outputs","title":"Signed outputs","text":"<p>A <code>BlindedMessage</code> (an output) with a signature <code>P2PKWitness.signatures</code> on <code>B_</code> is the JSON (see NUT-00):</p> <pre><code>{\n  \"amount\": &lt;int&gt;,\n  \"B_\": &lt;hex_str&gt;,\n  \"witness\": &lt;P2PKWitness | str&gt; // Signatures on \"B_\"\n}\n</code></pre> <p>The <code>B_</code> of each output is signed as bytes which comes from the original hex string.</p>"},{"location":"11/#witness-format","title":"Witness format","text":"<p><code>P2PKWitness</code> is a serialized JSON string of the form</p> <pre><code>{\n  \"signatures\": &lt;Array[&lt;hex_str&gt;]&gt;\n}\n</code></pre> <p>The <code>signatures</code> are an array of signatures in hex.</p>"},{"location":"11/#multisig","title":"Multisig","text":"<p>If the tag <code>n_sigs</code> is a positive integer, the mint will also consider signatures from public keys specified in the <code>pubkeys</code> tag additional to the public key in <code>Secret.data</code>. If the number of valid signatures is greater or equal to the number specified in <code>n_sigs</code>, the transaction is valid.</p> <p>Expressed as an \"n-of-m\" scheme, <code>n = n_sigs</code> is the number of required signatures and <code>m = 1 (\"data\" field) + len(pubkeys tag)</code> is the number of public keys that could sign.</p>"},{"location":"11/#locktime","title":"Locktime","text":"<p>If the tag <code>locktime</code> is the unix time and the mint's local clock is greater than <code>locktime</code>, the <code>Proof</code> becomes spendable by anyone, except if the following condition is also true. Note: A <code>Proof</code> is considered spendable by anyone if it only requires a <code>secret</code> and a valid signature <code>C</code> to be spent (which is the default case).</p>"},{"location":"11/#refund-public-keys","title":"Refund public keys","text":"<p>If the <code>locktime</code> is in the past and a tag <code>refund</code> is present, the <code>Proof</code> is spendable only if a valid signature by one of the the <code>refund</code> pubkeys is provided in <code>Proof.witness.signatures</code> and, depending on the signature flag, in <code>BlindedMessage.witness.signatures</code>.</p>"},{"location":"11/#complex-example","title":"Complex Example","text":"<p>This is an example <code>secret</code> that locks a <code>Proof</code> with a Pay-to-Pubkey (P2PK) condition that requires 2-of-3 signatures from the public keys in the <code>data</code> field and the <code>pubkeys</code> tag. If the <code>timelock</code> has passed, the <code>Proof</code> becomes spendable with a single signature from the public key in the <code>refund</code> tag. The signature flag <code>sigflag</code> indicates that signatures are necessary on the <code>inputs</code> and the <code>outputs</code> of a transaction.</p> <pre><code>[\n  \"P2PK\",\n  {\n    \"nonce\": \"da62796403af76c80cd6ce9153ed3746\",\n    \"data\": \"033281c37677ea273eb7183b783067f5244933ef78d8c3f15b1a77cb246099c26e\",\n    \"tags\": [\n      [\"sigflag\", \"SIG_ALL\"],\n      [\"n_sigs\", \"2\"],\n      [\"locktime\", \"1689418329\"],\n      [\n        \"refund\",\n        \"033281c37677ea273eb7183b783067f5244933ef78d8c3f15b1a77cb246099c26e\"\n      ],\n      [\n        \"pubkeys\",\n        \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n        \"023192200a0cfd3867e48eb63b03ff599c7e46c8f4e41146b2d281173ca6c50c54\"\n      ]\n    ]\n  }\n]\n</code></pre>"},{"location":"11/#use-cases","title":"Use cases","text":"<p>The following use cases are unlocked using P2PK:</p> <ul> <li>Publicly post locked ecash that can only be redeemed by the intended receiver</li> <li>Final offline-receiver payments that can't be double-spent when combined with an offline signature check mechanism like DLEQ proofs</li> <li>Receiver of locked ecash can defer and batch multiple mint round trips for receiving proofs (requires DLEQ)</li> <li>Ecash that is owned by multiple people via the multisignature abilities</li> <li>Atomic swaps when used in combination with the locktime feature</li> </ul>"},{"location":"12/","title":"NUT-12: Offline ecash signature validation","text":"<p><code>optional</code></p> <p>In this document, we present an extension of Cashu's crypto system to allow a user <code>Alice</code> to verify the mint <code>Bob</code>'s signature using only <code>Bob</code>'s public keys. We explain how another user <code>Carol</code> who receives ecash from <code>Alice</code> can execute the DLEQ proof as well. This is achieved using a Discrete Log Equality (DLEQ) proof. Previously, <code>Bob</code>'s signature could only be checked by himself using his own private keys (NUT-00).</p>"},{"location":"12/#the-dleq-proof","title":"The DLEQ proof","text":"<p>The purpose of this DLEQ is to prove that the mint has used the same private key <code>a</code> for creating its public key <code>A</code> (NUT-01) and for signing the BlindedMessage <code>B'</code>. <code>Bob</code> returns the DLEQ proof additional to the blind signature <code>C'</code> for a mint or swap operation.</p> <p>The complete DLEQ proof reads</p> <pre><code># DLEQ Proof\n\n(These steps occur when Bob returns C')\n\nBob:\nr = random nonce\nR1 = r*G\nR2 = r*B'\ne = hash(R1,R2,A,C')\ns = r + e*a\nreturn e, s\n\nAlice:\nR1 = s*G - e*A\nR2 = s*B' - e*C'\ne == hash(R1,R2,A,C')\n\nIf true, a in A = a*G must be equal to a in C' = a*B'\n</code></pre>"},{"location":"12/#hashx-arraypublickey-bytes","title":"<code>hash(x: &lt;Array&lt;[PublicKey]&gt;) -&gt; bytes</code>","text":"<p>The hash(x) function generates a deterministic Sha256 hash for a given input list of <code>PublicKey</code>. The uncompressed hexadecimal representations of each <code>PublicKey</code> is concatenated before taking the Sha256 hash.</p> <pre><code>def hash_e(*publickeys: PublicKey) -&gt; bytes:\n    e_ = \"\"\n    for p in publickeys:\n        _p = p.serialize(compressed=False).hex()\n        e_ += str(_p)\n    e = hashlib.sha256(e_.encode(\"utf-8\")).digest()\n    return e\n</code></pre>"},{"location":"12/#mint-to-user-dleq-in-blindsignature","title":"Mint to user: DLEQ in <code>BlindSignature</code>","text":"<p>The mint produces these DLEQ proofs when returning <code>BlindSignature</code>'s in the responses for minting (NUT-04) and swapping (NUT-03) tokens. The <code>BlindSignature</code> object is extended in the following way to include the DLEQ proof:</p> <pre><code>{\n  \"id\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"C_\": &lt;str&gt;,\n  \"dleq\": { &lt;-- New: DLEQ proof\n    \"e\": &lt;str&gt;,\n    \"s\": &lt;str&gt;\n  }\n}\n</code></pre> <p><code>e</code> and <code>s</code> are the DLEQ proof.</p>"},{"location":"12/#user-to-user-dleq-in-proof","title":"User to user: DLEQ in <code>Proof</code>","text":"<p>In order for <code>Alice</code> to communicate the DLEQ to another user <code>Carol</code>, we extend the <code>Proof</code> (see NUT-00) object and include the DLEQ proof. As explained below, we also need to include the blinding factor <code>r</code> for the proof to be convincing to another user <code>Carol</code>.</p> <pre><code>{\n  \"id\": &lt;str&gt;,\n  \"amount\": &lt;int&gt;,\n  \"secret\": &lt;str&gt;,\n  \"C\": &lt;str&gt;,\n  \"dleq\": { &lt;-- New: DLEQ proof\n    \"e\": &lt;str&gt;,\n    \"s\": &lt;str&gt;,\n    \"r\": &lt;str&gt;\n  }\n}\n</code></pre> <p><code>e</code> and <code>s</code> are the challenge and response of the DLEQ proof returned by <code>Bob</code>, <code>r</code> is the blinding factor of <code>Alice</code> that was used to generate the <code>Proof</code>. <code>Alice</code> serializes these proofs like any other in a token (see NUT-00) to send it to another user <code>Carol</code>.</p>"},{"location":"12/#alice-minting-user-verifies-dleq-proof","title":"Alice (minting user) verifies DLEQ proof","text":"<p>When minting or swapping tokens, <code>Alice</code> receives DLEQ proofs in the <code>BlindSignature</code> response from the mint <code>Bob</code>. <code>Alice</code> checks the validity of the DLEQ proofs for each ecash token she receives via the equations:</p> <pre><code>R1 = s*G - e*A\nR2 = s*B' - e*C'\ne == hash(R1,R2,A,C') # must be True\n</code></pre> <p>Here, the variables are</p> <ul> <li><code>A</code> \u2013\u00a0the public key <code>Bob</code> used to sign this Proof</li> <li><code>(e, s)</code> \u2013\u00a0the DLEQ proof returned by <code>Bob</code></li> <li><code>B'</code> \u2013 <code>Alice</code>'s <code>BlindedMessage</code></li> <li><code>C'</code> \u2013 <code>Bob</code>'s <code>BlindSignature</code> on <code>B'</code></li> </ul> <p>In order to execute the proof, <code>Alice</code> needs <code>e, s</code> that are returned in the <code>BlindSignature</code> by <code>Bob</code>. <code>Alice</code> further needs <code>B'</code> (the <code>BlindedMessage</code> <code>Alice</code> created and <code>Bob</code> signed) and <code>C'</code> (the blind signature in the <code>BlindSignature</code> response) from <code>Bob</code>, and <code>A</code> (the public key of <code>Bob</code> with which he signed the BlindedMessage). All these values are available to <code>Alice</code> during or after calling the mint and swap operations.</p> <p>If a DLEQ proof is included in the mint's <code>BlindSignature</code> response, wallets MUST verify the DLEQ proof.</p>"},{"location":"12/#carol-another-user-verifies-dleq-proof","title":"Carol (another user) verifies DLEQ proof","text":"<p><code>Carol</code> is a user that receives <code>Proofs</code> in a token from another user Alice. When <code>Alice</code> sends <code>Proofs</code> with DLEQ proofs to <code>Carol</code> or when <code>Alice</code> posts the <code>Proofs</code> publicly, <code>Carol</code> can validate the DLEQ proof herself and verify <code>Bob</code>'s signature without having to talk to <code>Bob</code>. <code>Alice</code> includes the following information in the <code>Proof</code> (see above):</p> <ul> <li><code>(x, C)</code> \u2013\u00a0the ecash <code>Proof</code></li> <li><code>(e, s)</code> \u2013\u00a0the DLEQ proof revealed by <code>Alice</code></li> <li><code>r</code> \u2013 <code>Alice</code>'s blinding factor</li> </ul> <p>Here, <code>x</code> is the Proof's secret, and <code>C</code> is the mint's signature on it. To execute the DLEQ proof like <code>Alice</code> did above, <code>Carol</code> needs <code>(B', C')</code> which she can compute herself using the blinding factor <code>r</code> that she receives from <code>Alice</code>.</p> <p>To verify the DLEQ proof of a received token, <code>Carol</code> needs to reconstruct <code>B'</code> and <code>C'</code> using the blinding factor <code>r</code> that <code>Alice</code> has included in the <code>Proof</code> she sent to <code>Carol</code>. Since <code>Carol</code> now has all the necessary information, she can execute the same equations to verify the DLEQ proof as <code>Alice</code> did:</p> <pre><code>Y = hash_to_curve(x)\nC' = C + r*A\nB' = Y + r*G\n\nR1 = ... (same as Alice)\n</code></pre> <p>If a DLEQ proof is included in a received token, wallets MUST verify the proof.</p>"},{"location":"13/","title":"NUT-13: Deterministic Secrets","text":"<p><code>optional</code> <code>depends on: NUT-09</code></p> <p>In this document, we describe the process that allows wallets to recover their ecash balance with the help of the mint using a familiar 12 word seed phrase (mnemonic). This allows us to restore the wallet's previous state in case of a device loss or other loss of access to the wallet. The basic idea is that wallets that generate the ecash deterministically can regenerate the same tokens during a recovery process. For this, they ask the mint to reissue previously generated signatures using NUT-09.</p>"},{"location":"13/#deterministic-secret-derivation","title":"Deterministic secret derivation","text":"<p>An ecash token, or a <code>Proof</code>, consists of a <code>secret</code> generated by the wallet, and a signature <code>C</code> generated by the wallet and the mint in collaboration. Here, we describe how wallets can deterministically generate the <code>secrets</code> and blinding factors <code>r</code> necessary to generate the signatures <code>C</code>.</p> <p>The wallet generates a <code>private_key</code> derived from a 12-word BIP39 <code>mnemonic</code> seed phrase that the user stores in a secure place. The wallet uses the <code>private_key</code>, to derive deterministic values for the <code>secret</code> and the blinding factors <code>r</code> for every new ecash token that it generates.</p> <p>In order to do this, the wallet keeps track of a <code>counter_k</code> for each <code>keyset_k</code> it uses. The index <code>k</code> indicates that the wallet needs to keep track of a separate counter for each keyset <code>k</code> it uses. Typically, the wallet will need to keep track of multiple keysets for every mint it interacts with. <code>counter_k</code> is used to generate a BIP32 derivation path which can then be used to derive <code>secret</code> and <code>r</code>.</p> <p>The following BIP32 derivation path is used. The derivation path depends on the keyset ID of <code>keyset_k</code>, and the <code>counter_k</code> of that keyset.</p> <ul> <li>Purpose' = <code>129372'</code> (UTF-8 for \ud83e\udd5c)</li> <li>Coin type' = Always <code>0'</code></li> <li>Keyset id' = Keyset ID represented as an integer (<code>keyset_k_int</code>)</li> <li>Coin counter' = <code>counter'</code> (this value is incremented)</li> <li><code>secret</code> or <code>r</code> = <code>0</code> or <code>1</code></li> </ul> <p><code>m / 129372' / 0' / keyset_k_int' / counter' / secret||r</code></p> <p>This results in the following derivation paths:</p> <pre><code>secret_derivation_path = `m/129372'/0'/{keyset_k_int}'/{counter_k}'/0`\nr_derivation_path = `m/129372'/0'/{keyset_id_k_int}'/{counter_k}'/1`\n</code></pre> <p>Here, <code>{keyset_k_int}</code> and <code>{counter_k}</code> are the only variables that can change. <code>keyset_id_k_int</code> is an integer representation (see below) of the keyset ID the token is generated with. This means that the derivation path is unique for each keyset. Note that the coin type is always <code>0'</code>, independent of the unit of the ecash.</p> <p>Note: For examples, see the test vectors.</p>"},{"location":"13/#counter","title":"Counter","text":"<p>The wallet starts with <code>counter_k := 0</code> upon encountering a new keyset and increments it by <code>1</code> every time it has successfully minted new ecash with this keyset. The wallet stores the latest <code>counter_k</code> in its database for all keysets it uses. Note that we have a <code>counter</code> (and therefore a derivation path) for each keyset <code>k</code>. We omit the keyset index <code>k</code> in the following of this document.</p>"},{"location":"13/#keyset-id","title":"Keyset ID","text":"<p>The integer representation <code>keyset_id_int</code> of a keyset is calculated from its hexadecimal ID which has a length of 8 bytes or 16 hex characters. First, we convert the hex string to a big-endian sequence of bytes. This value is then modulo reduced by <code>2^31 - 1</code> to arrive at an integer that is a unique identifier <code>keyset_id_int</code>.</p> <p>Example in Python:</p> <pre><code>keyset_id_int = int.from_bytes(bytes.fromhex(keyset_id_hex), \"big\") % (2**31 - 1)\n</code></pre> <p>Example in JavaScript:</p> <pre><code>keysetIdInt = BigInt(`0x${keysetIdHex}`) % BigInt(2 ** 31 - 1);\n</code></pre>"},{"location":"13/#restore-from-seed-phrase","title":"Restore from seed phrase","text":"<p>Using deterministic secret derivation, a user's wallet can regenerate the same <code>BlindedMessages</code> in case of loss of a previous wallet state. To also restore the corresponding <code>BlindSignatures</code> to fully recover the ecash, the wallet can either requests the mint to re-issue past <code>BlindSignatures</code> on the regenerated <code>BlindedMessages</code> (see NUT-09) or by downloading the entire database of the mint (TBD).</p> <p>The wallet takes the following steps during recovery:</p> <ol> <li>Generate <code>secret</code> and <code>r</code> from <code>counter</code> and <code>keyset</code></li> <li>Generate <code>BlindedMessage</code> from <code>secret</code></li> <li>Obtain <code>BlindSignature</code> for <code>secret</code> from the mint</li> <li>Unblind <code>BlindSignature</code> to <code>C</code> using <code>r</code></li> <li>Restore <code>Proof = (secret, C)</code></li> <li>Check if <code>Proof</code> is already spent</li> </ol>"},{"location":"13/#generate-blindedmessages","title":"Generate <code>BlindedMessages</code>","text":"<p>To generate the <code>BlindedMessages</code>, the wallet starts with a <code>counter := 0</code> and , for each increment of the <code>counter</code>, generates a <code>secret</code> using the BIP32 private key derived from <code>secret_derivation_path</code> and converts it to a hex string.</p> <pre><code>secret = bip32.get_privkey_from_path(secret_derivation_path).hex()\n</code></pre> <p>The wallet similarly generates a blinding factor <code>r</code> from the <code>r_derivation_path</code>:</p> <pre><code>r = self.bip32.get_privkey_from_path(r_derivation_path)\n</code></pre> <p>Note: For examples, see the test vectors.</p> <p>Using the <code>secret</code> string and the private key <code>r</code>, the wallet generates a <code>BlindedMessage</code>. The wallet then increases the <code>counter</code> by <code>1</code> and repeats the same process for a given batch size. It is recommended to use a batch size of 100.</p> <p>The user's wallet can now request the corresponding <code>BlindSignatures</code> for theses <code>BlindedMessages</code> from the mint using the NUT-09 restore endpoint or by downloading the entire mint's database.</p>"},{"location":"13/#generate-proofs","title":"Generate <code>Proofs</code>","text":"<p>Using the restored <code>BlindSignatures</code> and the <code>r</code> generated in the previous step, the wallet can unblind the signature to <code>C</code>. The triple <code>(secret, C, amount)</code> is a restored <code>Proof</code>.</p>"},{"location":"13/#check-proofs-states","title":"Check <code>Proofs</code> states","text":"<p>If the wallet used the restore endpoint NUT-09 for regenerating the <code>Proofs</code>, it additionally needs to check for the <code>Proofs</code> spent state using NUT-07. The wallet deletes all <code>Proofs</code> which are already spent and keeps the unspent ones in its database.</p>"},{"location":"13/#restoring-batches","title":"Restoring batches","text":"<p>Generally, the user won't remember the last state of <code>counter</code> when starting the recovery process. Therefore, wallets need to know how far they need to increment the <code>counter</code> during the restore process to be confident to have reached the most recent state.</p> <p>In short, following approach is recommended:</p> <ul> <li>Restore <code>Proofs</code> in batches of 100 and increment <code>counter</code></li> <li>Repeat until three consecutive batches are returned empty</li> <li>Reset <code>counter</code> to the value at the last successful restore + 1</li> </ul> <p>Wallets restore <code>Proofs</code> in batches of 100. The wallet starts with a <code>counter=0</code> and increments it for every <code>Proof</code> it generated during one batch. When the wallet begins restoring the first <code>Proofs</code>, it is likely that the first few batches will only contain spent <code>Proofs</code>. Eventually, the wallet will reach a <code>counter</code> that will result in unspent <code>Proofs</code> which it stores in its database. The wallet then continues to restore until three successive batches are returned empty by the mint. This is to be confident that the restore process did not miss any <code>Proofs</code> that might have been generated with larger gaps in the <code>counter</code> by the previous wallet that we are restoring.</p>"},{"location":"14/","title":"NUT-14: Hashed Timelock Contracts (HTLCs)","text":"<p><code>optional</code> <code>depends on: NUT-10</code></p> <p>This NUT describes the use of Hashed Timelock Contracts (HTLCs) which defines a spending condition based on NUT-10's well-known <code>Secret</code> format. Using HTLCs, ecash tokens can be locked to the hash of a preimage or a timelock. This enables use cases such as atomic swaps of ecash between users, and atomic coupling of an ecash spending condition to a Lightning HTLC.</p> <p><code>HTLC</code> spending conditions can be thought of as an extension of <code>P2PK</code> locks NUT-11 but with a hash lock in <code>Secret.data</code> and a new <code>Proof.witness.preimage</code> witness in the locked inputs to be spent. The <code>preimage</code> that was used to spend a locked token can be retrieved using NUT-07. Caution: applications that rely on being able to retrieve the witness independent from the spender must check via the mint's info endpoint that NUT-07 is supported.</p> <p>Caution: If the mint does not support this type of spending condition, proofs may be treated as a regular anyone-can-spend tokens. Applications need to make sure to check whether the mint supports a specific kind of spending condition by checking the mint's info endpoint.</p>"},{"location":"14/#htlc","title":"HTLC","text":"<p>NUT-10 Secret <code>kind: HTLC</code></p> <p>If for a <code>Proof</code>, <code>Proof.secret</code> is a <code>Secret</code> of kind <code>HTLC</code>, the hash of the lock is in <code>Proof.secret.data</code>. The preimage for unlocking the HTLC is in the witness <code>Proof.witness.preimage</code>. All additional tags from <code>P2PK</code> locks are used here as well, allowing us to add a locktime, signature flag, and use multisig (see NUT-11).</p> <p>Here is a concrete example of a <code>Secret</code> of kind <code>HTLC</code>:</p> <pre><code>[\n  \"HTLC\",\n  {\n    \"nonce\": \"da62796403af76c80cd6ce9153ed3746\",\n    \"data\": \"023192200a0cfd3867e48eb63b03ff599c7e46c8f4e41146b2d281173ca6c50c54\",\n    \"tags\": [\n      [\n        \"pubkeys\",\n        \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\"\n      ],\n      [\"locktime\", \"1689418329\"],\n      [\n        \"refund\",\n        \"033281c37677ea273eb7183b783067f5244933ef78d8c3f15b1a77cb246099c26e\"\n      ]\n    ]\n  }\n]\n</code></pre> <p>A <code>Proof</code> with this <code>Secret</code> can be spent in two ways. To spend the hash lock, the witness in <code>Proof.witness</code> includes the preimage to <code>Secret.data</code> and a signature from the key in <code>Secret.tag.pubkeys</code>. Additionally, if the current system time is later than <code>Secret.tag.locktime</code>, the <code>Proof</code> can be spent if <code>Proof.witness</code> includes a signature from the key in <code>Secret.tags.refund</code>.</p> <p>The hash lock in <code>Secret.data</code> and the preimage in <code>Proof.witness.preimage</code> is treated as 32 byte data encoded as 64 character hex strings.</p> <p>See NUT-11 for a description of the signature scheme, the additional use of signature flags, and how to require signature from multiple public keys (multisig).</p>"},{"location":"14/#witness-format","title":"Witness format","text":"<p><code>HTLCWitness</code> is a serialized JSON string of the form</p> <pre><code>{\n  \"preimage\": &lt;hex_str&gt;,\n  \"signatures\": &lt;Array[&lt;hex_str&gt;]&gt;\n}\n</code></pre>"},{"location":"15/","title":"NUT-15: Partial multi-path payments","text":"<p><code>optional</code> <code>depends on: NUT-05</code></p> <p>In this document, we describe how wallets can instruct multiple mints to each pay a partial amount of a bolt11 Lightning invoice. The full payment is composed of partial payments (MPP) from multiple multi-path payments from different Lightning nodes. This way, wallets can pay a larger Lightning invoice combined from multiple smaller balances on different mints. Due to the atomic nature of MPP, either all payments will be successful or all of them will fail.</p> <p>The Lightning backend of the mint must support paying a partial amount of an Invoice and multi-path payments (MPP, see BOLT 4). For example, the mint's Lightning node must be able to pay 50 sats of a 100 sat bolt11 invoice. The receiving Lightning node must support receiving multi-path payments as well.</p>"},{"location":"15/#multimint-payment-execution","title":"Multimint payment execution","text":"<p><code>Alice</code>'s wallet coordinates multiple MPPs on different mints that support the feature (see below for the indicated setting). For a given Lightning invoice of <code>amount_total</code>, <code>Alice</code> splits the total amount into several partial amounts <code>amount_total = amount_1 + amount_2 + ...</code> that each must be covered by her individual balances on the mints she wants to use for the payment. She constructs multiple <code>PostMeltQuoteBolt11Request</code>'s that each include the corresponding partial amount in the payment option (see below) that she sends to all mints she wants to use for the payment. The mints then respond with a normal <code>PostMeltQuoteBolt11Response</code> (see NUT-05). <code>Alice</code> proceeds to pay the melt requests at each mint simultaneously. When all mints have sent out the partial Lightning payment, she receives a successful response from all mints individually.</p>"},{"location":"15/#melt-quote","title":"Melt quote","text":"<p>To request a melt quote with a partial <code>amount</code>, the wallet of <code>Alice</code> makes a <code>POST /v1/melt/quote/bolt11</code> similar to NUT-05.</p> <pre><code>POST https://mint.host:3338/v1/melt/quote/bolt11\n</code></pre> <p>The wallet <code>Alice</code> includes the following <code>PostMeltQuoteBolt11Request</code> data in its request which includes an additional (and optional) <code>options</code> object compared to the standard request in NUT-05:</p> <pre><code>{\n  \"request\": &lt;str&gt;,\n  \"unit\": &lt;str_enum[\"sat\"]&gt;,\n  \"options\": {\n    \"mpp\": {\n      \"amount\": &lt;int&gt;\n    }\n  }\n}\n</code></pre> <p>Here, <code>request</code> is the bolt11 Lightning invoice to be paid, <code>unit</code> is the unit the wallet would like to pay with, and <code>amount</code> is the amount for the requested payment. The wallet then pays the returned melt quote the same way as in NUT-05.</p>"},{"location":"15/#settings","title":"Settings","text":"<p>The settings returned in the info endpoint (NUT-06) indicate that a mint supports this NUT. The mint MUST indicate each <code>method</code> and <code>unit</code> that supports <code>mpp</code>. It can indicate this in an array of objects for multiple <code>method</code> and <code>unit</code> pairs and the boolean flag <code>mpp</code> set to <code>true</code>.</p> <p><code>MultipathPaymentSetting</code> is of the form:</p> <pre><code>{\n  [\n    {\n      \"method\": &lt;str&gt;,\n      \"unit\": &lt;str&gt;,\n      \"mpp\": &lt;bool&gt;\n    },\n    ...\n  ]\n}\n</code></pre> <p>Example <code>MultipathPaymentSetting</code>:</p> <pre><code>{\n  \"15\": {\n    [\n      {\n        \"method\": \"bolt11\",\n        \"unit\": \"sat\",\n        \"mpp\": true\n      },\n      {\n        \"method\": \"bolt11\",\n        \"unit\": \"usd\",\n        \"mpp\": true\n      },\n    ]\n  }\n}\n</code></pre>"},{"location":"16/","title":"NUT-16: Animated QR codes","text":"<p><code>optional</code></p> <p>This document outlines how tokens should be displayed as QR codes for sending them between two wallets.</p>"},{"location":"16/#introduction","title":"Introduction","text":"<p>QR codes are a great way to send and receive Cashu tokens. Before a token can be shared as a QR code, it needs to be serialized (see NUT-00).</p>"},{"location":"16/#static-qr-codes","title":"Static QR codes","text":"<p>If the serialized token is not too large (i.e. includes less than or equal to 2 proofs) it can usually be shared as a static QR code. This might not be the case if the secret includes long scripts or the token has a long memo or mint URL.</p>"},{"location":"16/#animated-qr-codes","title":"Animated QR codes","text":"<p>If a token is too large to be displayed as a single QR code, we use animated QR codes are based on the UR protocol. The sender produces an animated QR code from a serialized Cashu token. The receiver scans the animated QR code until the UR decoder is able to decode the token.</p>"},{"location":"16/#resources","title":"Resources","text":"<ul> <li>Blockchain commons UR</li> <li>Typescript library bc-ur</li> </ul>"},{"location":"17/","title":"NUT-17: WebSockets","text":"<p><code>optional</code>, <code>depends on: NUT-07</code></p> <p>This NUT defines a websocket protocol that enables bidirectional communication between apps and mints using the JSON-RPC format.</p>"},{"location":"17/#subscriptions","title":"Subscriptions","text":"<p>The websocket enables real-time subscriptions that wallets can use to receive notifications for a state change of a <code>MintQuoteResponse</code> (NUT-04), <code>MeltQuoteResponse</code> (NUT-05), <code>CheckStateResponse</code> (NUT-07).</p> <p>A summary of the subscription flow is the following:</p> <ol> <li>A wallet connects to the websocket endpoint and sends a <code>WsRequest</code> with the <code>subscribe</code> command.</li> <li>The mint responds with a <code>WsResponse</code> containing an ok or an error.</li> <li>If the subscription was accepted, the mint sends a <code>WsNotification</code> of the current state of the subscribed objects and whenever there is an update for the wallet's subscriptions.</li> <li>To close a subscription, the wallet sends <code>WsRequest</code> with the <code>unsubscribe</code> command.</li> </ol>"},{"location":"17/#specifications","title":"Specifications","text":"<p>The websocket is reachable via the mint's URL path <code>/v1/ws</code>:</p> <pre><code>https://mint.com/v1/ws\n</code></pre> <p><code>NUT-17</code> uses the JSON-RPC format for all messages. There are three types of messages defined in this NUT.</p>"},{"location":"17/#requests","title":"Requests","text":"<p>All requests from the wallet to the mint are of the form of a <code>WsRequest</code>:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": &lt;str_enum[WsRequestMethod]&gt;,\n  \"params\": &lt;str_WsRequestParams&gt;,\n  \"id\": &lt;int&gt;\n}\n</code></pre> <p><code>WsRequestMethod</code> is a enum of strings with the supported commands <code>\"subscribe\"</code> and <code>\"unsubscribe\"</code>:</p> <pre><code>enum WsRequestMethod {\n  sub = \"subscribe\",\n  unsub = \"unsubscribe\",\n}\n</code></pre> <p><code>WsRequestParams</code> is a serialized JSON with the parameters of the corresponding command.</p>"},{"location":"17/#command-subscribe","title":"Command: Subscribe","text":"<p>To subscribe to updates, the wallet sends a <code>\"subscribe\"</code> command with the following <code>params</code> parameters:</p> <pre><code>{\n  \"kind\": &lt;str_enum[SubscriptionKind]&gt;,\n  \"subId\": &lt;string&gt;,\n  \"filters\": &lt;string[]&gt;\n}\n</code></pre> <p>Here, <code>subId</code> is a unique uuid generated by the wallet and allows the client to map its requests to the mint's responses.</p> <p><code>SubscriptionKind</code> is an enum with the following possible values:</p> <pre><code>enum SubscriptionKind {\n  bolt11_melt_quote = \"bolt11_melt_quote\",\n  bolt11_mint_quote = \"bolt11_mint_quote\",\n  proof_state = \"proof_state\",\n}\n</code></pre> <p>The <code>filters</code> are an array of mint quote IDs (NUT-04), or melt quote IDs (NUT-05), or <code>Y</code>'s (NUT-07) of the corresponding object to receive updates from.</p> <p>As an example, <code>filters</code> would be of the following form to subscribe for updates of three different mint quote IDs:</p> <pre><code>[\"20385fc7245...\", \"d06667cda9b...\", \"e14d8ca96f...\"]\n</code></pre> <p>Note that <code>id</code> and <code>subId</code> are unrelated. The <code>subId</code> is the ID for each subscription, whereas <code>id</code> is part of the JSON-RPC spec and is an integer counter that must be incremented for every request sent over the websocket.</p> <p>Important: If the subscription is accepted by the mint, the mint MUST first respond with the current state of the subscribed object and continue sending any further updates to it.</p> <p>For example, if the wallet subscribes to a <code>Proof.Y</code> of a <code>Proof</code> that has not been spent yet, the mint will first respond with a <code>ProofState</code> with <code>state == \"UNSPENT\"</code>. If the wallet then spends this <code>Proof</code>, the mint would send a <code>ProofState</code> with <code>state == \"PENDING\"</code> and then one with <code>state == \"SPENT\"</code>. In total, the mint would send three notifications to the wallet.</p>"},{"location":"17/#command-unsubscribe","title":"Command: Unsubscribe","text":"<p>The wallet should always unsubscribe any subscriptions that is isn't interested in anymore. The parameters for the <code>\"unsubscribe\"</code> command is only the subscription ID:</p> <pre><code>{\n  \"subId\": &lt;string&gt;\n}\n</code></pre>"},{"location":"17/#responses","title":"Responses","text":"<p>A <code>WsResponse</code> is returned by the mint to both the <code>\"subscribe\"</code> and <code>\"unsubscribe\"</code> commands and indicates whether the request was successful:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"status\": \"OK\",\n    \"subId\": &lt;str&gt;\n  },\n  \"id\": &lt;int&gt;\n}\n</code></pre> <p>Here, the <code>id</code> corresponds to the <code>id</code> in the request (as part of the JSON-RPC spec) and <code>subId</code> corresponds to the subscription ID.</p>"},{"location":"17/#notifications","title":"Notifications","text":"<p><code>WsNotification</code>'s are sent from the mint to the wallet and contain subscription data in the following format</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subscribe\",\n  \"params\": {\n    \"subId\": &lt;str&gt;,\n    \"payload\": NotificationPayload\n  }\n}\n</code></pre> <p><code>subId</code> is the subscription ID (previously generated by the wallet) this notification corresponds to. <code>NotificationPayload</code> carries the subscription data which is a <code>MintQuoteResponse</code> (NUT-04), a <code>MeltQuoteResponse</code> (NUT-05), or a <code>CheckStateResponse</code> (NUT-07), depending on what the corresponding <code>SubscriptionKind</code> was.</p>"},{"location":"17/#errors","title":"Errors","text":"<p><code>WsErrors</code> for a given <code>WsRequest</code> are returned in the following format</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32601,\n    \"message\": \"Human readable error message\"\n  },\n  \"id\": \"1\"\n}\n</code></pre>"},{"location":"17/#example-proofstate-subscription","title":"Example: <code>ProofState</code> subscription","text":"<p>To subscribe to the <code>ProofState</code> of a <code>Proof</code>, the wallet establishes a websocket connection to <code>https://mint.com/v1/ws</code> and sends a <code>WsRequest</code> with a <code>filters</code> chosen to be the a <code>Proof.Y</code> value of the <code>Proof</code> (see NUT-00). Note that <code>filters</code> is an array meaning multiple subscriptions of the same <code>kind</code> can be made in the same request.</p> <p>Wallet:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 0,\n  \"method\": \"subscribe\",\n  \"params\": {\n    \"kind\": \"proof_state\",\n    \"filters\": [\n      \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\"\n    ],\n    \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\"\n  }\n}\n</code></pre> <p>The mint first responds with a <code>WsResponse</code> confirming that the subscription has been added.</p> <p>Mint:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"status\": \"OK\",\n    \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\"\n  },\n  \"id\": 0\n}\n</code></pre> <p>The mint immediately sends the current <code>ProofState</code> of the subscription as a <code>WsNotification</code>.</p> <p>Mint:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"subscribe\",\n  \"params\": {\n    \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\",\n    \"payload\": {\n      \"Y\": \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\",\n      \"state\": \"UNSPENT\",\n      \"witness\": null\n    }\n  }\n}\n</code></pre> <p>While leaving the websocket connection open, the wallet then spends the ecash. The mint sends <code>WsNotification</code> updating the wallet about state changes of the <code>ProofState</code> accordingly:</p> <p>Mint:</p> <pre><code>{\"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": {\"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\", \"payload\": {\"Y\": \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\", \"state\": \"PENDING\"}}}\n\n{\"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": {\"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\", \"payload\": {\"Y\": \"02e208f9a78cd523444aadf854a4e91281d20f67a923d345239c37f14e137c7c3d\", \"state\": \"SPENT\"}}}\n</code></pre> <p>The wallet then unsubscribes.</p> <p>Wallet:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"unsubscribe\",\n  \"params\": { \"subId\": \"Ua_IYvRHoCoF_wsZFlJ1m4gBDB--O0_6_n0zHg2T\" }\n}\n</code></pre>"},{"location":"17/#signaling-support-via-nut-06","title":"Signaling Support via NUT-06","text":"<p>Mints signal websocket support via NUT-06 using the following setting:</p> <pre><code>\"nuts\": {\n    \"17\": {\n      \"supported\": [\n        {\n          \"method\": &lt;str&gt;,\n          \"unit\": &lt;str&gt;,\n          \"commands\": &lt;str[]&gt;\n        },\n        ...\n      ]\n    }\n}\n</code></pre> <p>Here, <code>commands</code> is an array of the commands that the mint supports. A mint that supports all commands would return <code>[\"bolt11_mint_quote\", \"bolt11_melt_quote\", \"proof_state\"]</code>. Supported commands are given for each method-unit pair.</p> <p>Example:</p> <pre><code>\"nuts\": {\n    \"17\": {\n      \"supported\": [\n        {\n          \"method\": \"bolt11\",\n          \"unit\": \"sat\",\n          \"commands\": [\n            \"bolt11_mint_quote\",\n            \"bolt11_melt_quote\",\n            \"proof_state\"\n            ]\n        },\n      ]\n    }\n}\n</code></pre>"},{"location":"error_codes/","title":"NUT Errors","text":"Code Description Relevant nuts 10002 Blinded message of output already signed NUT-03, NUT-04, NUT-05 10003 Token could not be verified NUT-03, NUT-05 11001 Token is already spent NUT-03, NUT-05 11002 Transaction is not balanced (inputs != outputs) NUT-02, NUT-03, NUT-05 11005 Unit in request is not supported NUT-04, NUT-05 11006 Amount outside of limit range NUT-04, NUT-05 12001 Keyset is not known NUT-02, NUT-04 12002 Keyset is inactive, cannot sign messages NUT-02, NUT-03, NUT-04 20001 Quote request is not paid NUT-04 20002 Tokens have already been issued for quote NUT-04 20003 Minting is disabled NUT-04 20005 Quote is pending NUT-04, NUT-05 20006 Invoice already paid NUT-05 20007 Quote is expired NUT-04, NUT-05"},{"location":"tests/","title":"Test Vectors","text":"<p>The files in this directory contain test vectors for NUTs that warrant them.</p>"},{"location":"tests/00-tests/","title":"NUT-00 Test Vectors","text":""},{"location":"tests/00-tests/#hash-to-curve-function","title":"Hash-to-curve function","text":"<p>The hash to curve function takes a message of any length and outputs a valid point on the secp256k1 curve. Note that unless you are using complex spend conditions (NUT-10), standardized secrets (random 32-bytes-long byte arrays) should be used in order to prevent wallet fingerprinting.</p> <pre><code># Test 1 (hex encoded)\nMessage: 0000000000000000000000000000000000000000000000000000000000000000\nPoint:   024cce997d3b518f739663b757deaec95bcd9473c30a14ac2fd04023a739d1a725\n\n# Test 2 (hex encoded)\nMessage: 0000000000000000000000000000000000000000000000000000000000000001\nPoint:   022e7158e11c9506f1aa4248bf531298daa7febd6194f003edcd9b93ade6253acf\n\n# Test 3 (hex encoded)\n# Note that this message will take a few iterations of the loop before finding a valid point\nMessage: 0000000000000000000000000000000000000000000000000000000000000002\nPoint:   026cdbe15362df59cd1dd3c9c11de8aedac2106eca69236ecd9fbe117af897be4f\n</code></pre>"},{"location":"tests/00-tests/#blinded-messages","title":"Blinded messages","text":"<p>These are test vectors for the the blinded secret (public key) <code>B_</code> Alice sends to the mint Bob given a secret <code>x</code> and a random blinding factor <code>r</code>.</p> <pre><code># Test 1\nx:  d341ee4871f1f889041e63cf0d3823c713eea6aff01e80f1719f08f9e5be98f6   # hex encoded byte array\nr:  99fce58439fc37412ab3468b73db0569322588f62fb3a49182d67e23d877824a   # hex encoded private key\nB_: 033b1a9737a40cc3fd9b6af4b723632b76a67a36782596304612a6c2bfb5197e6d # hex encoded public key\n\n# Test 2\nx:  f1aaf16c2239746f369572c0784d9dd3d032d952c2d992175873fb58fae31a60   # hex encoded byte array\nr:  f78476ea7cc9ade20f9e05e58a804cf19533f03ea805ece5fee88c8e2874ba50   # hex encoded private key\nB_: 029bdf2d716ee366eddf599ba252786c1033f47e230248a4612a5670ab931f1763 # hex encoded public key\n</code></pre>"},{"location":"tests/00-tests/#blinded-signatures","title":"Blinded signatures","text":"<p>These are test vectors for the blinded key <code>C_</code> given the mint's private key <code>k</code> and Alice's blinded message containing <code>B_</code>.</p> <pre><code># Test 1\nmint private key: 0000000000000000000000000000000000000000000000000000000000000001\nB_: 02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\nC_: 02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\n\n# Test 2\nmint private key: 7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\nB_: 02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\nC_: 0398bc70ce8184d27ba89834d19f5199c84443c31131e48d3c1214db24247d005d\n</code></pre>"},{"location":"tests/00-tests/#serialization-of-tokenv3","title":"Serialization of TokenV3","text":"<p>The following are JSON-formatted v3 tokens and their serialized counterparts.</p> <pre><code>{\n  \"token\": [\n    {\n      \"mint\": \"https://8333.space:3338\",\n      \"proofs\": [\n        {\n          \"amount\": 2,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"407915bc212be61a77e3e6d2aeb4c727980bda51cd06a6afc29e2861768a7837\",\n          \"C\": \"02bc9097997d81afb2cc7346b5e4345a9346bd2a506eb7958598a72f0cf85163ea\"\n        },\n        {\n          \"amount\": 8,\n          \"id\": \"009a1f293253e41e\",\n          \"secret\": \"fe15109314e61d7756b0f8ee0f23a624acaa3f4e042f61433c728c7057b931be\",\n          \"C\": \"029e8e5050b890a7d6c0968db16bc1d5d5fa040ea1de284f6ec69d61299f671059\"\n        }\n      ]\n    }\n  ],\n  \"unit\": \"sat\",\n  \"memo\": \"Thank you.\"\n}\n</code></pre> <p>Serialized:</p> <pre><code>cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre>"},{"location":"tests/00-tests/#deserialization-of-tokenv3","title":"Deserialization of TokenV3","text":"<p>The following are incorrectly formatted serialized v3 tokens.</p> <pre><code># Incorrect prefix (casshuA)\ncasshuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n\n# No prefix\neyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre> <p>The following is a correctly serialized v3 token.</p> <pre><code>cashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91LiJ9\n</code></pre> <p>Both of the following v3 tokens are valid, one includes padding characters at the end and the other does not.</p> <pre><code># Clients should be able to deserialize both\ncashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91IHZlcnkgbXVjaC4ifQ==\ncashuAeyJ0b2tlbiI6W3sibWludCI6Imh0dHBzOi8vODMzMy5zcGFjZTozMzM4IiwicHJvb2ZzIjpbeyJhbW91bnQiOjIsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6IjQwNzkxNWJjMjEyYmU2MWE3N2UzZTZkMmFlYjRjNzI3OTgwYmRhNTFjZDA2YTZhZmMyOWUyODYxNzY4YTc4MzciLCJDIjoiMDJiYzkwOTc5OTdkODFhZmIyY2M3MzQ2YjVlNDM0NWE5MzQ2YmQyYTUwNmViNzk1ODU5OGE3MmYwY2Y4NTE2M2VhIn0seyJhbW91bnQiOjgsImlkIjoiMDA5YTFmMjkzMjUzZTQxZSIsInNlY3JldCI6ImZlMTUxMDkzMTRlNjFkNzc1NmIwZjhlZTBmMjNhNjI0YWNhYTNmNGUwNDJmNjE0MzNjNzI4YzcwNTdiOTMxYmUiLCJDIjoiMDI5ZThlNTA1MGI4OTBhN2Q2YzA5NjhkYjE2YmMxZDVkNWZhMDQwZWExZGUyODRmNmVjNjlkNjEyOTlmNjcxMDU5In1dfV0sInVuaXQiOiJzYXQiLCJtZW1vIjoiVGhhbmsgeW91IHZlcnkgbXVjaC4ifQ\n</code></pre>"},{"location":"tests/00-tests/#serialization-of-tokenv4","title":"Serialization of TokenV4","text":"<p>The following are JSON-formatted v4 tokens and their serialized counterparts. The <code>h''</code> values are <code>bytes</code> but displayed as hex strings here.</p>"},{"location":"tests/00-tests/#single-keyset","title":"Single keyset","text":"<p>Token from a single keyset and including a memo.</p> <pre><code>{\n    \"t\": [\n        {\n            \"i\": h'00ad268c4d1f5826',\n            \"p\": [\n                {\n                    \"a\": 1,\n                    \"s\": \"9a6dbb847bd232ba76db0df197216b29d3b8cc14553cd27827fc1cc942fedb4e\",\n                    \"c\": h'038618543ffb6b8695df4ad4babcde92a34a96bdcd97dcee0d7ccf98d472126792',\n                },\n            ],\n        },\n    ],\n    \"d\": \"Thank you\",\n    \"m\": \"http://localhost:3338\",\n    \"u\": \"sat\",\n}\n</code></pre> <p>Encoded:</p> <pre><code>cashuBpGF0gaJhaUgArSaMTR9YJmFwgaNhYQFhc3hAOWE2ZGJiODQ3YmQyMzJiYTc2ZGIwZGYxOTcyMTZiMjlkM2I4Y2MxNDU1M2NkMjc4MjdmYzFjYzk0MmZlZGI0ZWFjWCEDhhhUP_trhpXfStS6vN6So0qWvc2X3O4NfM-Y1HISZ5JhZGlUaGFuayB5b3VhbXVodHRwOi8vbG9jYWxob3N0OjMzMzhhdWNzYXQ=\n</code></pre>"},{"location":"tests/00-tests/#multiple-keysets","title":"Multiple keysets","text":"<p>The token below includes proofs from two different keysets.</p> <pre><code>{\n    \"t\": [\n        {\n            \"i\": h'00ffd48b8f5ecf80',\n            \"p\": [\n                {\n                    \"a\": 1,\n                    \"s\": \"acc12435e7b8484c3cf1850149218af90f716a52bf4a5ed347e48ecc13f77388\",\n                    \"c\": h'0244538319de485d55bed3b29a642bee5879375ab9e7a620e11e48ba482421f3cf',\n                },\n            ],\n        },\n        {\n            \"i\": h'00ad268c4d1f5826',\n            \"p\": [\n                {\n                    \"a\": 2,\n                    \"s\": \"1323d3d4707a58ad2e23ada4e9f1f49f5a5b4ac7b708eb0d61f738f48307e8ee\",\n                    \"c\": h'023456aa110d84b4ac747aebd82c3b005aca50bf457ebd5737a4414fac3ae7d94d',\n                },\n                {\n                    \"a\": 1,\n                    \"s\": \"56bcbcbb7cc6406b3fa5d57d2174f4eff8b4402b176926d3a57d3c3dcbb59d57\",\n                    \"c\": h'0273129c5719e599379a974a626363c333c56cafc0e6d01abe46d5808280789c63',\n                },\n            ],\n        },\n    ],\n    \"m\": \"http://localhost:3338\",\n    \"u\": \"sat\",\n}\n</code></pre> <p>Serialized:</p> <pre><code>cashuBo2F0gqJhaUgA_9SLj17PgGFwgaNhYQFhc3hAYWNjMTI0MzVlN2I4NDg0YzNjZjE4NTAxNDkyMThhZjkwZjcxNmE1MmJmNGE1ZWQzNDdlNDhlY2MxM2Y3NzM4OGFjWCECRFODGd5IXVW-07KaZCvuWHk3WrnnpiDhHki6SCQh88-iYWlIAK0mjE0fWCZhcIKjYWECYXN4QDEzMjNkM2Q0NzA3YTU4YWQyZTIzYWRhNGU5ZjFmNDlmNWE1YjRhYzdiNzA4ZWIwZDYxZjczOGY0ODMwN2U4ZWVhY1ghAjRWqhENhLSsdHrr2Cw7AFrKUL9Ffr1XN6RBT6w659lNo2FhAWFzeEA1NmJjYmNiYjdjYzY0MDZiM2ZhNWQ1N2QyMTc0ZjRlZmY4YjQ0MDJiMTc2OTI2ZDNhNTdkM2MzZGNiYjU5ZDU3YWNYIQJzEpxXGeWZN5qXSmJjY8MzxWyvwObQGr5G1YCCgHicY2FtdWh0dHA6Ly9sb2NhbGhvc3Q6MzMzOGF1Y3NhdA\n</code></pre>"},{"location":"tests/01-tests/","title":"NUT-01 Test Vectors","text":"<p>The following are incorrect keysets that should be rejected by wallets implementing the NUT-01 specification.</p> <p>Key 1 is missing a byte</p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38\",\n  \"2\": \"03fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <p>Key 2 is a valid key but is not in the compressed format.</p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38bc\",\n  \"2\": \"04fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de3625246cb2c27dac965cb7200a5986467eee92eb7d496bbf1453b074e223e481\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <p>The following are correct keysets that should be accepted by wallets implementing the NUT-01 specification. Note that the second (bigger) keyset's biggest amount is <code>9223372036854775808</code>, one unit over what can fit into a 64-bit signed integer (often known as a <code>Long</code>). To handle this you'll need to use either an unsigned 64-bit integer or a 128-bit signed integer (sometimes known as a <code>BigInteger</code>).</p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38bc\",\n  \"2\": \"03fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <pre><code>{\n  \"1\": \"03ba786a2c0745f8c30e490288acd7a72dd53d65afd292ddefa326a4a3fa14c566\",\n  \"2\": \"03361cd8bd1329fea797a6add1cf1990ffcf2270ceb9fc81eeee0e8e9c1bd0cdf5\",\n  \"4\": \"036e378bcf78738ddf68859293c69778035740e41138ab183c94f8fee7572214c7\",\n  \"8\": \"03909d73beaf28edfb283dbeb8da321afd40651e8902fcf5454ecc7d69788626c0\",\n  \"16\": \"028a36f0e6638ea7466665fe174d958212723019ec08f9ce6898d897f88e68aa5d\",\n  \"32\": \"03a97a40e146adee2687ac60c2ba2586a90f970de92a9d0e6cae5a4b9965f54612\",\n  \"64\": \"03ce86f0c197aab181ddba0cfc5c5576e11dfd5164d9f3d4a3fc3ffbbf2e069664\",\n  \"128\": \"0284f2c06d938a6f78794814c687560a0aabab19fe5e6f30ede38e113b132a3cb9\",\n  \"256\": \"03b99f475b68e5b4c0ba809cdecaae64eade2d9787aa123206f91cd61f76c01459\",\n  \"512\": \"03d4db82ea19a44d35274de51f78af0a710925fe7d9e03620b84e3e9976e3ac2eb\",\n  \"1024\": \"031fbd4ba801870871d46cf62228a1b748905ebc07d3b210daf48de229e683f2dc\",\n  \"2048\": \"0276cedb9a3b160db6a158ad4e468d2437f021293204b3cd4bf6247970d8aff54b\",\n  \"4096\": \"02fc6b89b403ee9eb8a7ed457cd3973638080d6e04ca8af7307c965c166b555ea2\",\n  \"8192\": \"0320265583e916d3a305f0d2687fcf2cd4e3cd03a16ea8261fda309c3ec5721e21\",\n  \"16384\": \"036e41de58fdff3cb1d8d713f48c63bc61fa3b3e1631495a444d178363c0d2ed50\",\n  \"32768\": \"0365438f613f19696264300b069d1dad93f0c60a37536b72a8ab7c7366a5ee6c04\",\n  \"65536\": \"02408426cfb6fc86341bac79624ba8708a4376b2d92debdf4134813f866eb57a8d\",\n  \"131072\": \"031063e9f11c94dc778c473e968966eac0e70b7145213fbaff5f7a007e71c65f41\",\n  \"262144\": \"02f2a3e808f9cd168ec71b7f328258d0c1dda250659c1aced14c7f5cf05aab4328\",\n  \"524288\": \"038ac10de9f1ff9395903bb73077e94dbf91e9ef98fd77d9a2debc5f74c575bc86\",\n  \"1048576\": \"0203eaee4db749b0fc7c49870d082024b2c31d889f9bc3b32473d4f1dfa3625788\",\n  \"2097152\": \"033cdb9d36e1e82ae652b7b6a08e0204569ec7ff9ebf85d80a02786dc7fe00b04c\",\n  \"4194304\": \"02c8b73f4e3a470ae05e5f2fe39984d41e9f6ae7be9f3b09c9ac31292e403ac512\",\n  \"8388608\": \"025bbe0cfce8a1f4fbd7f3a0d4a09cb6badd73ef61829dc827aa8a98c270bc25b0\",\n  \"16777216\": \"037eec3d1651a30a90182d9287a5c51386fe35d4a96839cf7969c6e2a03db1fc21\",\n  \"33554432\": \"03280576b81a04e6abd7197f305506476f5751356b7643988495ca5c3e14e5c262\",\n  \"67108864\": \"03268bfb05be1dbb33ab6e7e00e438373ca2c9b9abc018fdb452d0e1a0935e10d3\",\n  \"134217728\": \"02573b68784ceba9617bbcc7c9487836d296aa7c628c3199173a841e7a19798020\",\n  \"268435456\": \"0234076b6e70f7fbf755d2227ecc8d8169d662518ee3a1401f729e2a12ccb2b276\",\n  \"536870912\": \"03015bd88961e2a466a2163bd4248d1d2b42c7c58a157e594785e7eb34d880efc9\",\n  \"1073741824\": \"02c9b076d08f9020ebee49ac8ba2610b404d4e553a4f800150ceb539e9421aaeee\",\n  \"2147483648\": \"034d592f4c366afddc919a509600af81b489a03caf4f7517c2b3f4f2b558f9a41a\",\n  \"4294967296\": \"037c09ecb66da082981e4cbdb1ac65c0eb631fc75d85bed13efb2c6364148879b5\",\n  \"8589934592\": \"02b4ebb0dda3b9ad83b39e2e31024b777cc0ac205a96b9a6cfab3edea2912ed1b3\",\n  \"17179869184\": \"026cc4dacdced45e63f6e4f62edbc5779ccd802e7fabb82d5123db879b636176e9\",\n  \"34359738368\": \"02b2cee01b7d8e90180254459b8f09bbea9aad34c3a2fd98c85517ecfc9805af75\",\n  \"68719476736\": \"037a0c0d564540fc574b8bfa0253cca987b75466e44b295ed59f6f8bd41aace754\",\n  \"137438953472\": \"021df6585cae9b9ca431318a713fd73dbb76b3ef5667957e8633bca8aaa7214fb6\",\n  \"274877906944\": \"02b8f53dde126f8c85fa5bb6061c0be5aca90984ce9b902966941caf963648d53a\",\n  \"549755813888\": \"029cc8af2840d59f1d8761779b2496623c82c64be8e15f9ab577c657c6dd453785\",\n  \"1099511627776\": \"03e446fdb84fad492ff3a25fc1046fb9a93a5b262ebcd0151caa442ea28959a38a\",\n  \"2199023255552\": \"02d6b25bd4ab599dd0818c55f75702fde603c93f259222001246569018842d3258\",\n  \"4398046511104\": \"03397b522bb4e156ec3952d3f048e5a986c20a00718e5e52cd5718466bf494156a\",\n  \"8796093022208\": \"02d1fb9e78262b5d7d74028073075b80bb5ab281edcfc3191061962c1346340f1e\",\n  \"17592186044416\": \"030d3f2ad7a4ca115712ff7f140434f802b19a4c9b2dd1c76f3e8e80c05c6a9310\",\n  \"35184372088832\": \"03e325b691f292e1dfb151c3fb7cad440b225795583c32e24e10635a80e4221c06\",\n  \"70368744177664\": \"03bee8f64d88de3dee21d61f89efa32933da51152ddbd67466bef815e9f93f8fd1\",\n  \"140737488355328\": \"0327244c9019a4892e1f04ba3bf95fe43b327479e2d57c25979446cc508cd379ed\",\n  \"281474976710656\": \"02fb58522cd662f2f8b042f8161caae6e45de98283f74d4e99f19b0ea85e08a56d\",\n  \"562949953421312\": \"02adde4b466a9d7e59386b6a701a39717c53f30c4810613c1b55e6b6da43b7bc9a\",\n  \"1125899906842624\": \"038eeda11f78ce05c774f30e393cda075192b890d68590813ff46362548528dca9\",\n  \"2251799813685248\": \"02ec13e0058b196db80f7079d329333b330dc30c000dbdd7397cbbc5a37a664c4f\",\n  \"4503599627370496\": \"02d2d162db63675bd04f7d56df04508840f41e2ad87312a3c93041b494efe80a73\",\n  \"9007199254740992\": \"0356969d6aef2bb40121dbd07c68b6102339f4ea8e674a9008bb69506795998f49\",\n  \"18014398509481984\": \"02f4e667567ebb9f4e6e180a4113bb071c48855f657766bb5e9c776a880335d1d6\",\n  \"36028797018963968\": \"0385b4fe35e41703d7a657d957c67bb536629de57b7e6ee6fe2130728ef0fc90b0\",\n  \"72057594037927936\": \"02b2bc1968a6fddbcc78fb9903940524824b5f5bed329c6ad48a19b56068c144fd\",\n  \"144115188075855872\": \"02e0dbb24f1d288a693e8a49bc14264d1276be16972131520cf9e055ae92fba19a\",\n  \"288230376151711744\": \"03efe75c106f931a525dc2d653ebedddc413a2c7d8cb9da410893ae7d2fa7d19cc\",\n  \"576460752303423488\": \"02c7ec2bd9508a7fc03f73c7565dc600b30fd86f3d305f8f139c45c404a52d958a\",\n  \"1152921504606846976\": \"035a6679c6b25e68ff4e29d1c7ef87f21e0a8fc574f6a08c1aa45ff352c1d59f06\",\n  \"2305843009213693952\": \"033cdc225962c052d485f7cfbf55a5b2367d200fe1fe4373a347deb4cc99e9a099\",\n  \"4611686018427387904\": \"024a4b806cf413d14b294719090a9da36ba75209c7657135ad09bc65328fba9e6f\",\n  \"9223372036854775808\": \"0377a6fe114e291a8d8e991627c38001c8305b23b9e98b1c7b1893f5cd0dda6cad\"\n}\n</code></pre>"},{"location":"tests/02-tests/","title":"NUT-02 Test Vectors","text":"<p>The following keysets and corresponding keyset IDs are correct: Keyset id: <code>00456a94ab4e1c46</code></p> <pre><code>{\n  \"1\": \"03a40f20667ed53513075dc51e715ff2046cad64eb68960632269ba7f0210e38bc\",\n  \"2\": \"03fd4ce5a16b65576145949e6f99f445f8249fee17c606b688b504a849cdc452de\",\n  \"4\": \"02648eccfa4c026960966276fa5a4cae46ce0fd432211a4f449bf84f13aa5f8303\",\n  \"8\": \"02fdfd6796bfeac490cbee12f778f867f0a2c68f6508d17c649759ea0dc3547528\"\n}\n</code></pre> <p>Keyset id: <code>000f01df73ea149a</code></p> <pre><code>{\n  \"1\": \"03ba786a2c0745f8c30e490288acd7a72dd53d65afd292ddefa326a4a3fa14c566\",\n  \"2\": \"03361cd8bd1329fea797a6add1cf1990ffcf2270ceb9fc81eeee0e8e9c1bd0cdf5\",\n  \"4\": \"036e378bcf78738ddf68859293c69778035740e41138ab183c94f8fee7572214c7\",\n  \"8\": \"03909d73beaf28edfb283dbeb8da321afd40651e8902fcf5454ecc7d69788626c0\",\n  \"16\": \"028a36f0e6638ea7466665fe174d958212723019ec08f9ce6898d897f88e68aa5d\",\n  \"32\": \"03a97a40e146adee2687ac60c2ba2586a90f970de92a9d0e6cae5a4b9965f54612\",\n  \"64\": \"03ce86f0c197aab181ddba0cfc5c5576e11dfd5164d9f3d4a3fc3ffbbf2e069664\",\n  \"128\": \"0284f2c06d938a6f78794814c687560a0aabab19fe5e6f30ede38e113b132a3cb9\",\n  \"256\": \"03b99f475b68e5b4c0ba809cdecaae64eade2d9787aa123206f91cd61f76c01459\",\n  \"512\": \"03d4db82ea19a44d35274de51f78af0a710925fe7d9e03620b84e3e9976e3ac2eb\",\n  \"1024\": \"031fbd4ba801870871d46cf62228a1b748905ebc07d3b210daf48de229e683f2dc\",\n  \"2048\": \"0276cedb9a3b160db6a158ad4e468d2437f021293204b3cd4bf6247970d8aff54b\",\n  \"4096\": \"02fc6b89b403ee9eb8a7ed457cd3973638080d6e04ca8af7307c965c166b555ea2\",\n  \"8192\": \"0320265583e916d3a305f0d2687fcf2cd4e3cd03a16ea8261fda309c3ec5721e21\",\n  \"16384\": \"036e41de58fdff3cb1d8d713f48c63bc61fa3b3e1631495a444d178363c0d2ed50\",\n  \"32768\": \"0365438f613f19696264300b069d1dad93f0c60a37536b72a8ab7c7366a5ee6c04\",\n  \"65536\": \"02408426cfb6fc86341bac79624ba8708a4376b2d92debdf4134813f866eb57a8d\",\n  \"131072\": \"031063e9f11c94dc778c473e968966eac0e70b7145213fbaff5f7a007e71c65f41\",\n  \"262144\": \"02f2a3e808f9cd168ec71b7f328258d0c1dda250659c1aced14c7f5cf05aab4328\",\n  \"524288\": \"038ac10de9f1ff9395903bb73077e94dbf91e9ef98fd77d9a2debc5f74c575bc86\",\n  \"1048576\": \"0203eaee4db749b0fc7c49870d082024b2c31d889f9bc3b32473d4f1dfa3625788\",\n  \"2097152\": \"033cdb9d36e1e82ae652b7b6a08e0204569ec7ff9ebf85d80a02786dc7fe00b04c\",\n  \"4194304\": \"02c8b73f4e3a470ae05e5f2fe39984d41e9f6ae7be9f3b09c9ac31292e403ac512\",\n  \"8388608\": \"025bbe0cfce8a1f4fbd7f3a0d4a09cb6badd73ef61829dc827aa8a98c270bc25b0\",\n  \"16777216\": \"037eec3d1651a30a90182d9287a5c51386fe35d4a96839cf7969c6e2a03db1fc21\",\n  \"33554432\": \"03280576b81a04e6abd7197f305506476f5751356b7643988495ca5c3e14e5c262\",\n  \"67108864\": \"03268bfb05be1dbb33ab6e7e00e438373ca2c9b9abc018fdb452d0e1a0935e10d3\",\n  \"134217728\": \"02573b68784ceba9617bbcc7c9487836d296aa7c628c3199173a841e7a19798020\",\n  \"268435456\": \"0234076b6e70f7fbf755d2227ecc8d8169d662518ee3a1401f729e2a12ccb2b276\",\n  \"536870912\": \"03015bd88961e2a466a2163bd4248d1d2b42c7c58a157e594785e7eb34d880efc9\",\n  \"1073741824\": \"02c9b076d08f9020ebee49ac8ba2610b404d4e553a4f800150ceb539e9421aaeee\",\n  \"2147483648\": \"034d592f4c366afddc919a509600af81b489a03caf4f7517c2b3f4f2b558f9a41a\",\n  \"4294967296\": \"037c09ecb66da082981e4cbdb1ac65c0eb631fc75d85bed13efb2c6364148879b5\",\n  \"8589934592\": \"02b4ebb0dda3b9ad83b39e2e31024b777cc0ac205a96b9a6cfab3edea2912ed1b3\",\n  \"17179869184\": \"026cc4dacdced45e63f6e4f62edbc5779ccd802e7fabb82d5123db879b636176e9\",\n  \"34359738368\": \"02b2cee01b7d8e90180254459b8f09bbea9aad34c3a2fd98c85517ecfc9805af75\",\n  \"68719476736\": \"037a0c0d564540fc574b8bfa0253cca987b75466e44b295ed59f6f8bd41aace754\",\n  \"137438953472\": \"021df6585cae9b9ca431318a713fd73dbb76b3ef5667957e8633bca8aaa7214fb6\",\n  \"274877906944\": \"02b8f53dde126f8c85fa5bb6061c0be5aca90984ce9b902966941caf963648d53a\",\n  \"549755813888\": \"029cc8af2840d59f1d8761779b2496623c82c64be8e15f9ab577c657c6dd453785\",\n  \"1099511627776\": \"03e446fdb84fad492ff3a25fc1046fb9a93a5b262ebcd0151caa442ea28959a38a\",\n  \"2199023255552\": \"02d6b25bd4ab599dd0818c55f75702fde603c93f259222001246569018842d3258\",\n  \"4398046511104\": \"03397b522bb4e156ec3952d3f048e5a986c20a00718e5e52cd5718466bf494156a\",\n  \"8796093022208\": \"02d1fb9e78262b5d7d74028073075b80bb5ab281edcfc3191061962c1346340f1e\",\n  \"17592186044416\": \"030d3f2ad7a4ca115712ff7f140434f802b19a4c9b2dd1c76f3e8e80c05c6a9310\",\n  \"35184372088832\": \"03e325b691f292e1dfb151c3fb7cad440b225795583c32e24e10635a80e4221c06\",\n  \"70368744177664\": \"03bee8f64d88de3dee21d61f89efa32933da51152ddbd67466bef815e9f93f8fd1\",\n  \"140737488355328\": \"0327244c9019a4892e1f04ba3bf95fe43b327479e2d57c25979446cc508cd379ed\",\n  \"281474976710656\": \"02fb58522cd662f2f8b042f8161caae6e45de98283f74d4e99f19b0ea85e08a56d\",\n  \"562949953421312\": \"02adde4b466a9d7e59386b6a701a39717c53f30c4810613c1b55e6b6da43b7bc9a\",\n  \"1125899906842624\": \"038eeda11f78ce05c774f30e393cda075192b890d68590813ff46362548528dca9\",\n  \"2251799813685248\": \"02ec13e0058b196db80f7079d329333b330dc30c000dbdd7397cbbc5a37a664c4f\",\n  \"4503599627370496\": \"02d2d162db63675bd04f7d56df04508840f41e2ad87312a3c93041b494efe80a73\",\n  \"9007199254740992\": \"0356969d6aef2bb40121dbd07c68b6102339f4ea8e674a9008bb69506795998f49\",\n  \"18014398509481984\": \"02f4e667567ebb9f4e6e180a4113bb071c48855f657766bb5e9c776a880335d1d6\",\n  \"36028797018963968\": \"0385b4fe35e41703d7a657d957c67bb536629de57b7e6ee6fe2130728ef0fc90b0\",\n  \"72057594037927936\": \"02b2bc1968a6fddbcc78fb9903940524824b5f5bed329c6ad48a19b56068c144fd\",\n  \"144115188075855872\": \"02e0dbb24f1d288a693e8a49bc14264d1276be16972131520cf9e055ae92fba19a\",\n  \"288230376151711744\": \"03efe75c106f931a525dc2d653ebedddc413a2c7d8cb9da410893ae7d2fa7d19cc\",\n  \"576460752303423488\": \"02c7ec2bd9508a7fc03f73c7565dc600b30fd86f3d305f8f139c45c404a52d958a\",\n  \"1152921504606846976\": \"035a6679c6b25e68ff4e29d1c7ef87f21e0a8fc574f6a08c1aa45ff352c1d59f06\",\n  \"2305843009213693952\": \"033cdc225962c052d485f7cfbf55a5b2367d200fe1fe4373a347deb4cc99e9a099\",\n  \"4611686018427387904\": \"024a4b806cf413d14b294719090a9da36ba75209c7657135ad09bc65328fba9e6f\",\n  \"9223372036854775808\": \"0377a6fe114e291a8d8e991627c38001c8305b23b9e98b1c7b1893f5cd0dda6cad\"\n}\n</code></pre>"},{"location":"tests/11-test/","title":"NUT-11 Test Vectors","text":"<p>The following is a <code>Proof</code> with a valid signature.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"859d4935c4907062a6297cf4e663e2835d90d97ecdd510745d32f6816323a41f\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"60f3c9b766770b46caac1d27e1ae6b77c8866ebaeba0b9489fe6a15a837eaa6fcd6eaa825499c72ac342983983fd3ba3a8a41f56677cc99ffd73da68b59e1383\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with an invalid signature as it is on a different secret.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"0ed3fcb22c649dd7bbbdcca36e0c52d4f0187dd3b6a19efcc2bfbebb5f85b2a1\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"02142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"83564aca48c668f50d022a426ce0ed19d3a9bdcffeeaee0dc1e7ea7e98e9eff1840fcc821724f623468c94f72a8b0a7280fa9ef5a54a1b130ef3055217f467b3\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with 2 signatures required to meet the multi-signature spend condition.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"0ed3fcb22c649dd7bbbdcca36e0c52d4f0187dd3b6a19efcc2bfbebb5f85b2a1\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"02142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"83564aca48c668f50d022a426ce0ed19d3a9bdcffeeaee0dc1e7ea7e98e9eff1840fcc821724f623468c94f72a8b0a7280fa9ef5a54a1b130ef3055217f467b3\\\",\\\"9a72ca2d4d5075be5b511ee48dbc5e45f259bcf4a4e8bf18587f433098a9cd61ff9737dc6e8022de57c76560214c4568377792d4c2c6432886cc7050487a1f22\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with one one signature failing the multi-signature spend condition.</p> <pre><code>{\n  \"amount\": 1,\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"0ed3fcb22c649dd7bbbdcca36e0c52d4f0187dd3b6a19efcc2bfbebb5f85b2a1\\\",\\\"data\\\":\\\"0249098aa8b9d2fbec49ff8598feb17b592b986e62319a4fa488a3dc36387157a7\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"02142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"id\": \"009a1f293253e41e\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"83564aca48c668f50d022a426ce0ed19d3a9bdcffeeaee0dc1e7ea7e98e9eff1840fcc821724f623468c94f72a8b0a7280fa9ef5a54a1b130ef3055217f467b3\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with a signature from the refund key that is spendable because the locktime is in the past.</p> <pre><code>{\n  \"amount\": 1,\n  \"id\": \"009a1f293253e41e\",\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"902685f492ef3bb2ca35a47ddbba484a3365d143b9776d453947dcbf1ddf9689\\\",\\\"data\\\":\\\"026f6a2b1d709dbca78124a9f30a742985f7eddd894e72f637f7085bf69b997b9a\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"03142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"locktime\\\",\\\"21\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"refund\\\",\\\"026f6a2b1d709dbca78124a9f30a742985f7eddd894e72f637f7085bf69b997b9a\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"710507b4bc202355c91ea3c147c0d0189c75e179d995e566336afd759cb342bcad9a593345f559d9b9e108ac2c9b5bd9f0b4b6a295028a98606a0a2e95eb54f7\\\"]}\"\n}\n</code></pre> <p>The following is a <code>Proof</code> with a signature from the refund key that is not spendable because the locktime is in the future.</p> <pre><code>{\n  \"amount\": 1,\n  \"id\": \"009a1f293253e41e\",\n  \"secret\": \"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"64c46e5d30df27286166814b71b5d69801704f23a7ad626b05688fbdb48dcc98\\\",\\\"data\\\":\\\"026f6a2b1d709dbca78124a9f30a742985f7eddd894e72f637f7085bf69b997b9a\\\",\\\"tags\\\":[[\\\"pubkeys\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\",\\\"03142715675faf8da1ecc4d51e0b9e539fa0d52fdd96ed60dbe99adb15d6b05ad9\\\"],[\\\"locktime\\\",\\\"21\\\"],[\\\"n_sigs\\\",\\\"2\\\"],[\\\"refund\\\",\\\"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\\\"],[\\\"sigflag\\\",\\\"SIG_INPUTS\\\"]]}]\",\n  \"C\": \"02698c4e2b5f9534cd0687d87513c759790cf829aa5739184a3e3735471fbda904\",\n  \"witness\": \"{\\\"signatures\\\":[\\\"f661d3dc046d636d47cb3d06586da42c498f0300373d1c2a4f417a44252cdf3809bce207c8888f934dba0d2b1671f1b8622d526840f2d5883e571b462630c1ff\\\"]}\"\n}\n</code></pre>"},{"location":"tests/12-tests/","title":"NUT-12 Test vectors","text":""},{"location":"tests/12-tests/#hash_e-function","title":"<code>hash_e</code> function","text":"<pre><code>R1: \"020000000000000000000000000000000000000000000000000000000000000001\"\nR2: \"020000000000000000000000000000000000000000000000000000000000000001\"\nK: \"020000000000000000000000000000000000000000000000000000000000000001\"\nC_: \"02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\"\n</code></pre> <pre><code>hash(R1, R2, K, C_): \"a4dc034b74338c28c6bc3ea49731f2a24440fc7c4affc08b31a93fc9fbe6401e\"\n</code></pre>"},{"location":"tests/12-tests/#dleq-verification-on-blindsignature","title":"DLEQ verification on <code>BlindSignature</code>","text":"<p>The following is a <code>BlindSignature</code> with a valid DLEQ proof.</p> <pre><code>A: \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"\nB_: \"02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\"\n</code></pre> <pre><code>{\n  \"amount\": 8,\n  \"id\": \"00882760bfa2eb41\",\n  \"C_\": \"02a9acc1e48c25eeeb9289b5031cc57da9fe72f3fe2861d264bdc074209b107ba2\",\n  \"dleq\": {\n    \"e\": \"9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73d9\",\n    \"s\": \"9818e061ee51d5c8edc3342369a554998ff7b4381c8652d724cdf46429be73da\"\n  }\n}\n</code></pre>"},{"location":"tests/12-tests/#dleq-verification-on-proof","title":"DLEQ verification on <code>Proof</code>","text":"<p>The following is a <code>Prood</code> with a valid DLEQ proof.</p> <pre><code>A: \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"\n</code></pre> <pre><code>{\n  \"amount\": 1,\n  \"id\": \"00882760bfa2eb41\",\n  \"secret\": \"daf4dd00a2b68a0858a80450f52c8a7d2ccf87d375e43e216e0c571f089f63e9\",\n  \"C\": \"024369d2d22a80ecf78f3937da9d5f30c1b9f74f0c32684d583cca0fa6a61cdcfc\",\n  \"dleq\": {\n    \"e\": \"b31e58ac6527f34975ffab13e70a48b6d2b0d35abc4b03f0151f09ee1a9763d4\",\n    \"s\": \"8fbae004c59e754d71df67e392b6ae4e29293113ddc2ec86592a0431d16306d8\",\n    \"r\": \"a6d13fcd7a18442e6076f5e1e7c887ad5de40a019824bdfa9fe740d302e8d861\"\n  }\n}\n</code></pre>"},{"location":"tests/13-tests/","title":"NUT-13 Test vectors","text":""},{"location":"tests/13-tests/#keyset-id-integer-representation","title":"Keyset ID integer representation","text":"<p>The integer representation of a keyset with an ID <code>009a1f293253e41e</code> and its corresponding derivation path for a counter of value <code>{counter}</code> are</p> <pre><code>{\n  \"keyset_id\": \"009a1f293253e41e\",\n  \"keyest_id_int\": 864559728,\n  \"derivation_path\": \"m/129372'/0'/864559728'/{counter}'\"\n}\n</code></pre>"},{"location":"tests/13-tests/#secret-derivatoin","title":"Secret derivatoin","text":"<p>We derive values starting from the following BIP39 mnemonic.</p> <pre><code>{\n  \"mnemonic\": \"half depart obvious quality work element tank gorilla view sugar picture humble\"\n}\n</code></pre> <p>The secrets derived for the first five counters from <code>counter=0</code> to <code>counter=4</code> are</p> <pre><code>{\n  \"secret_0\": \"485875df74771877439ac06339e284c3acfcd9be7abf3bc20b516faeadfe77ae\",\n  \"secret_1\": \"8f2b39e8e594a4056eb1e6dbb4b0c38ef13b1b2c751f64f810ec04ee35b77270\",\n  \"secret_2\": \"bc628c79accd2364fd31511216a0fab62afd4a18ff77a20deded7b858c9860c8\",\n  \"secret_3\": \"59284fd1650ea9fa17db2b3acf59ecd0f2d52ec3261dd4152785813ff27a33bf\",\n  \"secret_4\": \"576c23393a8b31cc8da6688d9c9a96394ec74b40fdaf1f693a6bb84284334ea0\"\n}\n</code></pre> <p>The corresponding blinding factors <code>r</code> are</p> <pre><code>{\n  \"r_0\": \"ad00d431add9c673e843d4c2bf9a778a5f402b985b8da2d5550bf39cda41d679\",\n  \"r_1\": \"967d5232515e10b81ff226ecf5a9e2e2aff92d66ebc3edf0987eb56357fd6248\",\n  \"r_2\": \"b20f47bb6ae083659f3aa986bfa0435c55c6d93f687d51a01f26862d9b9a4899\",\n  \"r_3\": \"fb5fca398eb0b1deb955a2988b5ac77d32956155f1c002a373535211a2dfdc29\",\n  \"r_4\": \"5f09bfbfe27c439a597719321e061e2e40aad4a36768bb2bcc3de547c9644bf9\"\n}\n</code></pre> <p>The corresponding derivation paths are</p> <pre><code>{\n  \"derivation_path_0\": \"m/129372'/0'/864559728'/0'\",\n  \"derivation_path_1\": \"m/129372'/0'/864559728'/1'\",\n  \"derivation_path_2\": \"m/129372'/0'/864559728'/2'\",\n  \"derivation_path_3\": \"m/129372'/0'/864559728'/3'\",\n  \"derivation_path_4\": \"m/129372'/0'/864559728'/4'\"\n}\n</code></pre>"}]}