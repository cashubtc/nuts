# NUT-23: Golomb-Coded Set Filters

`optional`

`depends on: NUT-06`

---

This NUT describes a structure for compact filters on ecash notes and other information, for client-side use. The filter construction proposed
is an alternative to Bloom filters that minimizes size by using Golomb-Rice coding for compression.

Clients can query and use this filter to test for set membership, which comes in particularly handy for checking the spent state of ecash notes.

## Specification

### Filter

For each keyset, compact filters are derived containing sets of items associated with the keyset (spent `Y`s or blind signatures `B_`).
A set of such data objects is compressed into a probabilistic structure called a Golomb-Coded set (GCS), which matches all items in the set with
probability $1$, and matches other items with probability $\frac{1}{M}$. The encoding is also parameterized by `P`, the bit length of the remainder code.
Each filter defined specifies values for `P` and `M`, as well as the cardinality of the set it encodes `N`.

At a high level, a GCS is constructed from a set of $N$ items by:

1. hashing all items to 64-bit integers in the range $[0, N\cdot M)$
2. sorting the hashed values in ascending order
3. computing the differences between each value and the previous one
4. writing the differences sequentially, compressed with Golomb-Rice coding

The following sections describe each step in greater detail.

### Hashing Data Objects

The first step in the filter construction is hashing the variable-sized raw items in the set to the range $[0, F)$, where $F = N \cdot
M$. Analysis has shown that `M` and `P` are necessarily bound by $M = 1.497137 \cdot 2^P$. Practically, $M$ can be set to $2^P$ or $2^{P+1}$.
Set membership queries against the hash outputs will have a false positive rate of $\frac{1}{M}$.

To avoid integer overflow, the number of items `N` **MUST** be <2^32 and `M` **MUST** be <2^32.

The items are first passed through the pseudorandom function MurmurHash128, which takes a variable-sized byte vector and produces a uniformly random 128-bit output.

The bottom 64-bit of the MurmurHash output is then mapped uniformly over the desired range by multiplying with `F` and taking the top 64 bits of the 128-bit result. This algorithm is a faster alternative to modulo reduction, as it avoids the expensive division operation while still retaining a fair mapping property.

> [!NOTE] > $\biggl\lfloor\frac{F \cdot \text{Hash}(x)}{2^{64}}\biggr\rfloor \neq \text{Hash}(x) \bmod F$.
> Make sure your implementation does this right!

```python
def hash_to_range(item: bytes, f: int) -> int:
    """
    Hashes an item to a range using Murmurhash.

    Args:
        item (bytes): The item to hash.
        f (int): The maximum range value.

    Returns:
        int: The hashed value within the specified range.
    """
    h = mmh3.hash128(item) & (2**64 - 1)
    return (f * h) >> 64
```

### Golomb-Rice Coding

Instead of writing the items in the hashed set directly to the filter, greater compression is achieved by only writing the differences between successive items in sorted order. Since the items are distributed uniformly, it can be shown that the differences follow a geometric distribution.

Golomb-Rice Coding is a technique that optimally compresses geometrically distributed values.

With Golomb-Rice, a value is split into a quotient and remainder modulo $2^P$, which are encoded separately. The quotient $q$ is encoded as unary, with a string of $q$ 1's followed by one 0. The remainder $r$ is represented in big-endian by $P$ bits.

```python
def golomb_encode(stream: bitarray, x: int, P: int) -> None:
    """
    Golomb-encodes a value into a bitarray stream.

    Args:
        stream (bitarray): The bitarray to encode into.
        x (int): The value to encode.
        P (int): The number of bits for the remainder.
    """

    q = x >> P
    r = x & (2**P - 1)

    while q > 0:
        stream.append(1)
        q -= 1
    stream.append(0)

    for i in range(P):
        stream.append((r >> (P-1-i)) & 1)

def golomb_decode(stream: bitarray, offset: int, P: int) -> Tuple[int, int]:
    """
    Decodes a Golomb-encoded value from a bitarray stream.

    Args:
        stream (bitarray): The bitarray to decode from.
        offset (int): The starting offset in the bitarray.
        P (int): The number of bits for the remainder.

    Returns:
        Tuple[int, int]: The decoded value and the new offset.
    """
    q = 0
    while stream[offset] == 1:
        q += 1
        offset += 1

    offset += 1

    r = 0
    for i in range(P):
        r = (r << 1) | stream[offset + i]

    x = (q << P) | r
    return x, offset + P
```

### Set Construction

A GCS is constructed from four parameters:

- `L`, a vector of `N` raw items
- `P`, the bit parameter of the Golomb-Rice coding
- `M`, the inverse of the target false positive rate

The result is a byte vector with a minimum size of $N \cdot (P + 1)$ bits.

The raw items in $L$ are first hashed to 64-bit unsigned integers as specified above and sorted. The differences between consecutive values, hereafter referred to as deltas, are encoded sequentially to a bit stream with Golomb-Rice coding. Finally, the bit stream is padded with 0's to the nearest byte boundary and serialized to the output byte vector.

```python
def create(
    items: List[bytes],
    p: int = 19,
    m: int = 784931,
) -> bytes:
    """
    Turns a list of entries into a Golomb-Coded Set of hashes.

    Args:
        items (List[bytes]): The list of items to encode.
        p (int): The number of bits for the remainder.
        m (int): The inverse of the false positive rate.

    Returns:
        bytes: The Golomb-Coded Set as a byte array.
    """
    if m.bit_length() > 32:
        raise Exception("GCS Error: m parameter must be smaller than 2^32")
    if len(items).bit_length() > 32:
        raise Exception("GCS Error: number of elements must be smaller than 2^32")

    set_items = create_hashed_set(items, m)

    # Sort in non-descending order
    sorted_set_items = sorted(set_items)

    output_stream = bitarray()

    last_value = 0
    for item in sorted_set_items:
        delta = item - last_value
        golomb_encode(output_stream, delta, p)
        last_value = item

    # Padded to the next byte boundary
    return output_stream.tobytes()
```

### Set Querying/Decompression

To check membership of an item in a compressed GCS, one must reconstruct the hashed set members from the encoded deltas. The procedure to do so is the reverse of the compression: deltas are decoded one by one and added to a cumulative sum. Each intermediate sum represents a hashed value in the original set. The queried item is hashed in the same way as the set members and compared against the reconstructed values.

> [!Note]
> Querying does not require the entire decompressed set be held in memory at once.

```python
def match_many(
        compressed_set: bytes,
        targets: List[bytes],
        n: int,
        p: int = 19,
        m: int = 784931,
    ) -> Dict[bytes, bool]:
        """
        Matches multiple target items against a Golomb-Coded Set.

        Args:
            compressed_set (bytes): The Golomb-Coded Set as a byte array.
            targets (List[bytes]): The list of target items to match.
            n (int): The number of items in the set.
            p (int): The number of bits for the remainder.
            m (int): The inverse of the false positive rate.

        Returns:
            Dict[bytes, bool]: A dictionary indicating which targets are in the set.
        """
        if m.bit_length() > 32:
            raise Exception("GCS Error: m parameter must be smaller than 2^32")
        if n.bit_length() > 32:
            raise Exception("GCS Error: number of elements must be smaller than 2^32")

        # Compute the range
        f = n * m

        if len(set(targets)) != len(targets):
            raise Exception("GCS Error: match targets are not unique entries")

        # Map targets to the same range as the set hashes.
        target_hashes: Dict[int, Tuple[bytes, bool]] = {hash_to_range(target, f): (target, False) for target in targets}

        input_stream = bitarray()
        input_stream.frombytes(compressed_set)

        value = 0
        offset = 0
        for i in range(n):
            delta, offset = golomb_decode(input_stream, offset, p)
            value += delta

            if value in target_hashes:
                target, _ = target_hashes[value]
                target_hashes[value] = (target, True)

        return {target: truth_value for target, truth_value in target_hashes.values()}
```

## Querying for Spent Ecash Notes

Wallets **MAY** query `GET v1/filter/spent/{keyset_id}` to get the GCS filter that encodes the `Y` values of all the spent ecash from `keyset_id`.

The Mint **MUST** respond with a `GetFilterResponse`, which has the following structure.

```json
{
    n: <int>,
    p: <int | null>,
    m: <int | null>,
    content: [<base64_str>],
    timestamp: <int>,
}
```

Where:

- `n` is the number of items in the filter
- `p` is the bit parameter of the Golomb-Rice coding. If `null`, then the client assumes `p = 19`.
- `m` is the inverse of the false positive rate. If `null`, then the client assume `m = 784931`.

`content` is a base-64 string encoding the bytes of the filter. It is typically computed as:

```python
content = b64encode(filter_bytes).decode()
# And vice-versa
filter_bytes = b64decode(content)
```

`timestamp` is the Unix epoch (in seconds) when the filter was created. The Mint might choose not to re-compute the filter upon every request, and instead serve one from cache memory and computed an updated version after arbitrary amount of time.

### False Positive Rate (FPR) For Bulk Tests

Each invidivual look-up has $1 - \frac{1}{M}$ chance of being a _true positive_. We can consider a bulk test as $x$ independent look-ups, so the chance that at _all_ of them are true positives is $(1 - \frac{1}{M})^x$.

Therefore, the chance of any one of them being a _false positive_ (or equivalently, **not** all of them being _true positives_) is $1 - (1 - \frac{1}{M})^x$.

For $M = 784931$, this turns out to be:

| $x$  | $M$    | $P_M(x)$    |
| ---- | ------ | ----------- |
| 1    | 784931 | 0.999998726 |
| 10   | 784931 | 0.99998726  |
| 300  | 784931 | 0.999617874 |
| 5000 | 784931 | 0.993650255 |

## Mint Info Settings

Mints that support this NUT **MUST** announce it in their [NUT-06](06.md) `GetInfoResponse`. They can do so by updating the response to signal support for NUT-23.

```json
{
    ...,
    "nuts": {
        ...,
        "23": {"supported": true}
    }
}
```
