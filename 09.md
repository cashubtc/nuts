NUT-09: Deterministic Secrets
==========================

`optional`

---

A Cashu `Proof` consists of a `secret` (generated by the wallet) and a signature `C` (of the mint). In this document, we describe how wallets can generate `secrets` and blinding factors `r` necessary to generate `C` deterministically. This allows wallets to back up a familiar 12 word seed phrase (mnemonic) which can be used to restore the wallet's ecash with the help of the mint's database of blind signatures it previously issued.

## Wallet



### Overwiew

Using a `private_key`, wallets can generate deterministic values for `secret` and the blinding factor `r`. The `private_key` is derived from a 12-word [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) `mnemonic` seed phrase. The wallet keeps track of a `counter_k` for each `keyset_k` it uses. This `counter_k` is used to create a [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) derivation path which is ultimately used to derive `secret` and `r`.
  
### Deterministic secret derivation

A standard derivation path is used to generate `BlindedMessages` deterministically. The derivation path depends on the keyset, and the `counter_k` of `keyset_k`.

- Purpose' = `129372'` (UTF-8 for ðŸ¥œ)
- Coin type' = Bitcoin `0'`
- Keyset id' = Keyset ID represented as an integer
- Coin counter' = `counter'` (this value is incremented)
- Secret (`secret`) or blinding factor (`r`) can be `0` or `1`

```
secret_derivation_path = `m/129372'/0'/{keyset_k_int}'/{counter_k}'/0`
r_derivation_path = `m/129372'/0'/{keyset_id_k_int}'/{counter_k}'/1`
```

Here, `{keyset_k_int}` and `{counter_k}` are the only variables that can change. `keyset_id_k_int` is an integer representation of the [keyset ID][02] the coin is generated with. This means that the derivation path is unique for each keyset (independent of its unit).

#### Counter

The wallet starts with `counter_k := 0` when it encounters a new keyset and increments it by `1` every time it has successfully minted new ecash with this keyset. 

#### Keyset ID

The integer representation of a keyset is calculated from its hexadecimal ID with a length of 8 bytes or 16 hex characters.

Python:
```python
keyest_id_int = int.from_bytes(bytes.fromhex(keyset_id_hex), "big") % (2**31 - 1)
```

JavaScript:
```javascript
keysetIdInt = BigInt(`0x${keysetIdHex}`) % BigInt(2 ** 31 - 1);
```

Note that we have a counter (and therefore a derivation path) for each keyset `k`. We will omit the keyset index `k` in the following of this document.

### Restore from seed phrase

Using deterministic secret derivation, a user's wallet can regenerate the same `BlindedMessages` in case of loss of a previous wallet state. To also restore the corresponding `BlindSignatures` to fully recover the ecash, the wallet requests the mint to re-issue past `BlindSignatures` on the regenerated `BlindedMessages`.   

The wallet takes the following steps during recovery:

1) Generate `secret` and `r` from `counter` and `keyset`
2) Generate `BlindedMessage` from `secret`
3) Obtain `BlindSignature` for `secret` from the mint
4) Unblind `BlindSignature` to `C` using `r`
5) Restore `Proof = (secret, C)`
6) Check if `Proof` is already spent

To generate the `BlindMessages`, the wallet starts with a `counter := 0` and , for each increment of the `counter`, generates a `secret` using the BIP32 private key derived from `secret_derivation_path` and converts it to a hex string.

```python
secret = bip32.get_privkey_from_path(secret_derivation_path).hex()
```

The 



Generally, the user won't remember the state of their last `counter` before the recovery process. The wallet therefore needs to ask the mint to reissue signatures multiple times until the `counter` reaches the last value before the backup and the mint can not find any signatures in its database anymore.  It is recommended to regenerate the derived values in batches of size 100 during the restoral process.

1. The restore process starts by the wallet prompting the user for the `mnemonic`.
2. The wallet also needs to prompt the user for the `mints` where the user wants to restore ecash.
3. Next, the wallet needs to reproduce the creation of the `BlindedMessages`. This process is exactly the same as outlined in "create restorable ecash". The only difference is, that instead of creating 1 `BlindedMessage` the wallet creates `n` for each `keysetID`
4. The wallet then needs to match with the mint if any `BlindedMessages` that were produced were signed by the mint. The wallet can request the `BlindSignatures` by calling the mints `/restore` endpoint (there are 2 main ways of matching, `quick-but-doxxing`, `slow-but-private`. more about this later)
5. If there are `BlindSignatures` found up until `counter` = `n` we can repeat the process by creating `BlindedMessages` for `counters` = `n` to `2n` and so on, searching the next batch for `BlindSignatures`
6. After not finding any more matches, `BlindSignatures` must be matched with the corresponding `BlindedMessages`, and consequently unblinded to fully restore the ecash as `Proofs`
7. The restored `Proofs` must then finally be checked if they have already been spent. This can be done by calling `/check` on the mint.

## Mint

To enable `restore` on the mint (`quick-but-doxxing`), the mint must implement the follwing:

- Store all `BlindedMessages` and corresponding `BlindSignatures`
- Expose `BlindSignatures` at `/restore` endpoint
- disallow `splitting` into already created `BlindSignatures` (must be unique)

the `/restore` endpoint consumes:

```json
{
  "outputs": <Array[BlindedMessages]>
}
```

and provides (lists in same order):

```json
{
  "outputs": <Array[BlindedMessages]>
  "promises": <Array[BlindSignatures]>
}
```

This scheme will let the mint know about all BlindedMessages created by the wallet. This is quite a big information leak and definitely comes with privacy drawbacks.


[concept]
Alternatively, the mint can enable a database dump of all `BlindedMessages` and corresponding `BlindSignatures` (`slow-but-private`). This will allow the wallet to match the signatures locally without leaking information, but it will take longer since the mints entire database must be downloaded first.


[02]: 02.md