Cashu client protocol
====================

`author: calle`

---

## 0 - Notation
- `Alice`: wallet
- `Bob`: mint
- `Carol`: wallet

We describe how the wallet of `Alice` can mint ecash tokens by paying a Lightning invoice generated by the mint `Bob`. Then, we describe how `Alice` sends tokens to to another user wallet `Carol`.

## 1 - Request public keys from mint ([NUT-01][01])

- `Alice` receives public keys from mint `Bob` via `GET /keys` and stores them in a key-value store like a dictionary. Keys are received as a JSON of the form `{<amount_1> : <mint_pubkey_1>, <amount_2> : ...}` for each `<amount_i>` of the amounts the mint `Bob` supports. 
- These amounts are later referred to as *subamounts*. The mint can only sign tokens of these amounts, that means any operation of an arbitrary amount needs to be executed as a sum of these amounts.
- `Alice` computes the keyset id using all public keys of the mint like a fingerprint. She stores this keyset id in her database together with other meta information about the mint like its URL. She can use this keyset id to identify tokens from this mint later when she encounters them.

## 2 - Mint tokens

Here we describe how `Alice` and `Bob` mint new tokens.

### Step 1: `Alice` requests mint ([NUT-03][03])
`Alice` asks the mint `Bob` to generate
- `Alice` requests the minting of tokens of value `amount : int` via `GET /mint?amount=<amount>` 
- `Bob` responds with a JSON `{"pr": <payment_request>, "hash": <hash>}` where `payment_request` is the bolt11 Lightning invoice that `Alice` needs to pay and `hash` is a hash to refer to the invoice which `Alice` needs to remember to request minting of tokens later. `Alice` stores `hash`.
- `Alice` pays bolt11 invoice `payment_request` using a Bitcoin Lightning wallet.

### Step 2: `Alice` generates secrets ([NUT-00][00])
`Alice` generates `N` secrets for each deterministic split into subamounts that sum up to the total requested amount.

- To request tokens of value `amount : int`, `Alice` decomposes `amount` into a sum of values of `2^n`, e.g. `13` is `amounts : List[int] = [1, 4, 8]`. This can be easily done by representing `amount` as binary and using each binary digit that is `1` as part of the sum, e.g. `13` would be `1101` wich is `2^0 + 2^2 + 2^3`. In this example, `Alice` will request `N = len(amounts) = 3` tokens.
- `Alice` generates `N` random secret strings `x` by generating `128` random bits and encoding them `base64` for each requested token.
- `Alice` remembers `x` for the construction of the proof in Step 5.

### Step 3: `Alice` generates outputs ([NUT-00][00])
`Alice` generates `N` outputs (i.e., blinded messages, or blinded secrets). The following steps are executed for each of the `N` tokens that `Alice` requests.

- `Alice` generates a point `Y` on the elliptic curve from the secret `x` using the deterministic function `Y = hash_to_curve(hash(x : string)) : Point`. 
- `h = hash(x : string) : string` can be the `SHA256` hash function.
- `Y = hash_to_curve(h :  string) : Point` verifies that `Y` is an element of the elliptic curve.
- `Alice` generates a random blinding factor (nonce) `r : int` that is a private key and computes the public key from it using `r*G`.
- `Alice` generates the blinded message `B_ = Y + r*G`
- `Alice` remembers `r` for the construction of the proof in Step 5.

### Step 4: Mint tokens ([NUT-04][04])
`Alice` sends outputs to `Bob` and receives promises.

- `Alice` constructs JSON of `BlindedMessage`'s, i.e. `{"outputs" : [{"amount" : <amount>, "B_" : <blinded_message>}, ...]}`.
- `Alice` requests tokens via `POST /mint?hash=<hash>` with body being the JSON with the `BlindedMessage`'s.
- `Alice` receives from `Bob` blinded signatures, i.e. `{"promises" : [{"amount" : <amount>, "C_" : <blinded_signature>}, ...]}`

### Step 5: Construct proofs ([NUT-00][00])
Here, `Alice` construct proofs for each token using the tuple `(<blinded_signature>, r, x)`. `x` is the random secret generated in Step 2. `r` is the random random blinding factor generated in Step 3. Again, all steps are repeated for each token separately but we show it here for only one token.
- `Alice` unblinds `<blinded_signature>` `C_` by subtracting `r*<mint_pubkey>` from it and thus generates the unblinded signature `C`, i.e. `C = C_ - rK`. Also note that `<mint_pubkey>` must be the correct one for the `<amount>` of the token.
- `Alice` constructs a spendable token as a tuple `(<amount>, C, x)` and stores it in her database. We refer to this object as a proof.
- `Alice` can store additional information in this object, such as the keyset id `id` from which the token originated (see [NUT-01](01))
- The stored JSON should look like this `{"amount" : <amount>, "C": <C>, "secret" : <x> , "id": <id>}`.

## 3 - Send tokens
Here we describe how `Alice` sends tokens to `Carol`.

### 3.1 â€“ Split tokens to desired total amount ([NUT-06][06])
`Alice` wants to send tokens of total value `<total>` to `Carol` but doesn't necessarily have a set of individual tokens of amount `<amount>` that sum to `<total>`. 

Say, `Alice` has tokens of the amount `<alice_balance>` which is greater than `<total>` in here database. Note that `<alice_balance>` does not need to include all of `Alice`'s tokens but only at least tokens of a total amount of `<total>`. Therefore, `Alice` sends tokens of amount `<alice_balance>` to `Bob` asks `Bob` to issue two new sets of tokens that sum up to the value `<total>` and `<alice_balance>-<total>` each.

- `Alice` splits the values `<total>` and `<alice_balance>-<total>` separately as described in in Step 2.2.
- `Alice` constructs two new sets of outputs like in Step 2.3, one for each of the two sets of amounts `<total>` and `<alice_balance>-<total>`.
- `Alice` now has two sets of outputs one of which she can keep and one which she can send to `Carol` later. To get signatures on the, `Alice` needs to send an equal amount of proofs that sum up to `<alice_balance>` to `Bob`.
- `Alice` constructs a JSON out of outputs and proofs. She generates the outputs like in Step 2.3 and loads a list of proofs from her database. Both these sets sum to `<alice_balance>`.
- `Alice` requests a split at the amount `<total>` via `POST /split` and sends a JSON of the form `{"amount" : <amount>, "proofs" : [{"amount" : <amount>, "secret" : s, "C" : Z}, ...], "outputs" : ["amount" : <amount>, "B_" : <blinded_message>]}`.
- `Bob` responds with a JSON of promises of the form `{"fst" : <promises_to_keep>, "snd" : <promises_to_send>}`. `<promises_to_send>` sum up to `<total>` and  `<promises_to_keep>` sum up to `<alice_balance>-<total>`.
- Alice generates proofs from these promises as Step 2.5.
- `Alice` stores the proofs `<promises_to_keep>` and `<promises_to_send>` in her database and flags `<promises_to_send>` as `pending` (for example in a separate column in her database).
- `Alice` may also give the set of `<promises_to_send>` a unique ID `send_id` so that she can group pending tokens to a specific initiated transaction.

**Comment on split.** The split operation is the most important operation for an ecash wallet to engage in with a mint. Like described above, the split operation initiates a transaction between `Alice` and `Carol`. It can be used to split a `Alices`'s tokens to the specific amount she wants to send.

However, the split operation is also used to finalize the transaction. When `Carol` receives tokens from `Alice`, `Carol` needs to ask the mint to swap the tokens against new ones in order to prevent `Alice` from double spending them. In that case, the split amount `<total>` can simply be chosen as the total amount of the proofs supplied.

### 3.3 - Serialize tokens for sending ([NUT-00][00])
Here we describe how `Alice` serializes the proofs from the set `<send_proofs>` for sending to `Carol`.

**Token formats.** There are two token formats. The old `V1` format is simply a list of proofs. The new `V2` format includes meta data about the mint that the token originates from and can be sent to users that have not interacted with a mint before. Clients should support both and are encouraged to only use the `V2` format but for some applications the simpler `V1` format may be preferrable.

- `Alice` constructs a JSON according to the token format specified in [NUT-00][00]` and encodes it as a Base64 string using url-safe Base64 encoder.
- `Alice` sends the resulting string `eyJwcm9vZnMiOiBbeyJpZCI6...` to `Carol`.

## 4 - Receive new tokens
Here we describe how `Carol` can redeem new tokens from `Bob` that she previously received from `Alice`. `Carol` receives tokens as a url-safe base64-encoded string that, when decoded, is a JSON with one or more tokens. To redeem these tokens, `Carol` sends them to `Bob` and receives new ones of the same total value.

`Carol` essentially performs the same procedure to receive tokens as `Alice` did earlier when she prepared her tokens for sending: She constructs new outputs and sends them together with the proofs she received in order to receive a new set of promises. This settles the transaction between `Alice` and `Carol`.

Note that the following steps can also be performed by `Alice` herself if she wants to cancel the pending token transfer and reclaim them for herself if `Carol` didn't already do so.

## 5 - Burn sent tokens
Here we describe how `Alice` checks with the mint whether the tokens she sent `Carol` have been redeemed so she can safely delete them from her database. This step is optional but highly recommended so `Alice` can properly account for the tokens and adjust her balance accordingly.
- `Alice` loads all `<send_proofs>` with `pending=True` from her database and might group them by the `send_id`.
- `Alice` constructs a JSON of the form `{"proofs" : [{"amount" : <amount>, "secret" : s, "C" : Z}, ...]}` from these (grouped) tokens (`CheckStateRequest`).
- `Alice` sends them to the mint `Bob` via the endpoint `POST /check` with the JSON as the body of the request.
- `Alice` receives a JSON of the form `{"spendable" : [true, false, ...], "pending": [false, false, ....]}` where each boolean value corresponds to the proof she sent to the mint before in the same order. The value is `True` if the token has not been claimed yet and `False` if it has already been claimed.
- If `<spendable>` is `False`, `Alice` removes the proof from her list of spendable proofs.

## 6 - Pay a Lightning invoice
Here we describe how `Alice` can request from `Bob` to make a Lightning payment for her and burn an appropriate amount of tokens in return. `Alice` wants to pay a bolt11 invoice with the amount `<invoice_amount>`. She has to add a fee to the request to account for the possible Lightning fees which results in a request with tokens with the total amount of `<total>`. 

- `Alice` wants to pay the bolt11 invoice `<invoice>`.
- `Alice` asks `Bob` for the Lightning fee via `POST /checkfee` with the body `CheckFeeRequest` being the json `{pr : <invoice>}`
- `Alice` receives the `CheckFeeResponse` in the form of the json `{"fee" : <fee>}` resulting in `<total> = <invoice_amount> + <fee>`.
- `Alice` now performs the same set of instructions as in Step 3.1 and 3.2 and splits her spendable tokens into a set `<keep_proofs>` that she keeps and and a set `<send_proofs>` with a sum of at least `<total>` that she can send for making the Lightning payment.
- `Alice` constructs the JSON `PostMeltRequest` of the form `{"proofs" : [Proof, ...], "invoice" : <invoice>}`
- `Alice` requests a payment from `Bob` via the endpoint `POST /melt` with the JSON as the body of the request.
- `Alice` receives a JSON of the form `{"paid" :  <status:bool>}` with `<status>` being a boolean that is `True` if the payment was successful and `False` otherwise.
- If `<status> == True`, `Alice` removes `<send_proofs>` from her database of spendable tokens [*NOTE: called it tokens again*]






# Todo:
- Call subsections 1. and 1.2 etc so they can be referenced
- Define objets like `BlindedMessages` and `PostSplitRequests` once when they appear and reuse them.
- Clarify whether a `TOKEN` is a single Proof or a list of Proofs

[00]: 00.md
[01]: 01.md
[02]: 02.md
[03]: 03.md
[04]: 04.md
[05]: 05.md
[06]: 06.md
[07]: 07.md
[08]: 08.md
[09]: 09.md
[10]: 10.md
[11]: 11.md
[12]: 12.md
[13]: 13.md
[14]: 14.md
[15]: 15.md
[16]: 16.md
[17]: 17.md
[18]: 18.md
[19]: 19.md
[20]: 20.md