# NUT-26: Payment Request Bech32m Encoding

`optional` `depends on: NUT-18`

---

This specification defines an alternative encoding format for Payment Requests using Bech32m encoding with TLV (Tag-Length-Value) serialization. This format provides better QR code compatibility and typically 30-60% size reduction compared to the CBOR+base64 encoding defined in NUT-18.

## Motivation

This encoding format addresses several limitations of the legacy `creqA` format:

- **QR Code Efficiency**: Bech32m encoded as uppercase is alphanumeric-mode compatible, resulting in denser QR codes
- **Human Readability**: The `creqb1` prefix clearly identifies the format
- **Error Detection**: Bech32m includes built-in checksums for data integrity
- **Standards Alignment**: Uses the same encoding family as Bitcoin addresses and Lightning invoices

## Encoded Request Format

Payment requests are serialized using TLV encoding, then encoded with Bech32m:

`"creqb" + "1" + bech32m(TLV(PaymentRequest))`

The human-readable part (HRP) is `"creqb"` and the version separator is `"1"`. The data payload is TLV-encoded as described below, then encoded with Bech32m (not standard Bech32).

> [!NOTE] > **Case Sensitivity and QR Code Optimization**
>
> The encoding SHOULD be output in uppercase for optimal QR code compatibility. QR codes support three encoding modes, and uppercase alphanumeric characters can be encoded in "alphanumeric mode" which is more space-efficient than "byte mode" required for mixed-case strings.
>
> **Encoder Requirements:**
>
> - Implementations SHOULD emit uppercase Bech32m strings (e.g., `CREQB1...`)
> - This typically results in 30-40% smaller QR codes compared to lowercase
> - The HRP `creqb` becomes `CREQB` when uppercased
>
> **Decoder Requirements:**
>
> - Implementations MUST accept both uppercase and lowercase variants
> - Implementations MUST accept mixed-case input
> - The Bech32m checksum validation is case-insensitive
> - Case conversion should be performed before checksum validation
>
> **Example:**
>
> - Uppercase (recommended): `CREQB1QQQSYQQQPJHZP24NGU3...`
> - Lowercase (valid): `creqb1qqqsyqqqpjhzp24ngu3...`
> - Mixed-case (valid but not recommended): `CreqB1QqqSyQqqPjhzp24ngu3...`

## TLV Structure

The payment request is encoded as a sequence of TLV fields. Each TLV entry consists of:

- **Type** (1 byte): Field identifier
- **Length** (2 bytes, big-endian): Length of value in bytes
- **Value** (variable): Field data

### Top-Level TLV Tags

| Tag  | Field       | Type      | Description                                                          |
| ---- | ----------- | --------- | -------------------------------------------------------------------- |
| 0x01 | id          | string    | Payment identifier (corresponds to `i` in JSON)                      |
| 0x02 | amount      | u64       | Amount in base units (corresponds to `a` in JSON)                    |
| 0x03 | unit        | u8/string | Currency unit (corresponds to `u` in JSON)                           |
| 0x04 | single_use  | u8        | Single-use flag: 0=false, 1=true (corresponds to `s` in JSON)        |
| 0x05 | mint        | string    | Mint URL (repeatable for multiple mints, corresponds to `m` in JSON) |
| 0x06 | description | string    | Human-readable description (corresponds to `d` in JSON)              |
| 0x07 | transport   | sub-TLV   | Transport configuration (repeatable, corresponds to `t` in JSON)     |
| 0x08 | nut10       | sub-TLV   | NUT-10 spending conditions (corresponds to `nut10` in JSON)          |

All fields are optional. Unknown tags MUST be ignored to maintain forward compatibility.

#### NUT-18 Field Name Mapping

The TLV encoding uses numeric tags while the JSON format (NUT-18) uses single-character field names. The following table provides the complete mapping:

| TLV Tag | Field Name  | JSON Key | Example Value                    |
| ------- | ----------- | -------- | -------------------------------- |
| 0x01    | id          | `i`      | `"demo123"`                      |
| 0x02    | amount      | `a`      | `1000`                           |
| 0x03    | unit        | `u`      | `"sat"` or `"msat"`              |
| 0x04    | single_use  | `s`      | `true` or `false`                |
| 0x05    | mint        | `m`      | `["https://mint.example.com"]`   |
| 0x06    | description | `d`      | `"Coffee payment"`               |
| 0x07    | transport   | `t`      | Array of transport objects       |
| 0x08    | nut10       | `nut10`  | NUT-10 spending condition object |

**Example JSON to TLV Mapping:**

```json
{
  "i": "req123",
  "a": 500,
  "u": "sat",
  "d": "Test payment"
}
```

Maps to TLV tags: `0x01` (id), `0x02` (amount), `0x03` (unit), `0x06` (description).

### Unit Encoding (Tag 0x03)

The unit field uses a compact encoding:

- **Value 0x00**: Represents `sat` (Bitcoin satoshis)
- **String value**: Any other unit is encoded as a UTF-8 string (e.g., `"msat"`, `"usd"`, `"eur"`)

If an amount (tag 0x02) is present but unit (tag 0x03) is absent, decoders SHOULD default to `sat`.

### Transport Sub-TLV (Tag 0x07)

Transport configurations are encoded as nested TLV structures. Each transport has the following sub-tags:

| Sub-Tag | Field     | Type        | Description                                              |
| ------- | --------- | ----------- | -------------------------------------------------------- |
| 0x01    | kind      | u8          | Transport type: 0=in-band, 1=nostr, 2=http_post          |
| 0x02    | target    | bytes       | Transport target (interpretation depends on kind)        |
| 0x03    | nips      | u16[]       | Nostr NIPs (sequence of big-endian u16, only for kind=1) |
| 0x04    | relay     | string      | Nostr relay URL (repeatable, only for kind=1)            |
| 0x05    | tag_tuple | sub-sub-TLV | Generic tag tuple (repeatable)                           |

#### Transport Type Mapping

The kind field (sub-tag 0x01) identifies the transport method. The following transport types are defined:

| Kind Value | Transport Type | Description                            | Target Format                         |
| ---------- | -------------- | -------------------------------------- | ------------------------------------- |
| 0x00       | in-band        | Response included directly in token    | Empty or omitted                      |
| 0x01       | nostr          | Nostr-based transport using NIP-04 DMs | 32-byte X-only public key (raw bytes) |
| 0x02       | http_post      | HTTP POST to specified URL             | UTF-8 encoded URL string              |

**JSON Representation:**

In the NUT-18 JSON format, transports are represented with a `type` field:

```json
{
  "t": [
    { "type": "nostr", "target": "npub1...", "tags": [["n", "17"]] },
    { "type": "http_post", "target": "https://callback.example.com/pay" }
  ]
}
```

When encoding to TLV, the `type` string is converted to the corresponding numeric kind value.

#### Transport Target Encoding (Sub-Tag 0x02)

The target field is interpreted based on the transport kind:

- **kind=0 (in-band)**: Empty or omitted
- **kind=1 (nostr)**: 32-byte X-only public key (raw bytes, not bech32-encoded)
- **kind=2 (http_post)**: UTF-8 encoded URL string

#### Nostr Transport Details

For Nostr transports (`kind=1`), the implementation:

1. Stores the raw 32-byte X-only public key in the target field
2. Encodes supported NIPs as a sequence of u16 values in big-endian order
3. Stores relay URLs as separate TLV entries (one per relay)
4. When decoding back to the JSON format:
   - If no relays are present: encode public key as `npub`
   - If relays are present: encode as `nprofile` using NIP-19 format

#### Tag Tuple Encoding (Sub-Tag 0x05)

Generic tag tuples are encoded as:

1. Key length (1 byte)
2. Key string (UTF-8)
3. For each value:
   - Value length (1 byte)
   - Value string (UTF-8)

This allows encoding arbitrary key-value pairs for extensibility.

### NUT-10 Sub-TLV (Tag 0x08)

NUT-10 spending conditions are encoded as nested TLV structures:

| Sub-Tag | Field     | Type        | Description                                                  |
| ------- | --------- | ----------- | ------------------------------------------------------------ |
| 0x01    | kind      | u8         | Secret kind (0=P2PK, 1=HTLC, etc.)                           |
| 0x02    | data      | bytes       | Kind-specific data (UTF-8 encoded)                           |
| 0x03    | tag_tuple | sub-sub-TLV | Tag tuple (repeatable, uses same encoding as transport tags) |

#### NUT-10 Kind Enumeration

The following kind values are defined for NUT-10 spending conditions:

| Kind Value | Name | Description                                                      |
| ---------- | ---- | ---------------------------------------------------------------- |
| 0x0000     | P2PK | Pay to Public Key - requires signature from specified public key |
| 0x0001     | HTLC | Hash Time Locked Contract - requires preimage of hash            |

Additional kind values may be defined in future NUT specifications. Unknown kind values SHOULD be preserved when re-encoding but MAY be ignored during validation.

## Example

This is an example payment request expressed as JSON:

```json
{
  "i": "demo123",
  "a": 1000,
  "u": "sat",
  "s": true,
  "m": ["https://mint.example.com"],
  "d": "Coffee payment"
}
```

This payment request encodes to the NUT-26 format as:

```
CREQB1QYQQWER9D4HNZV3NQGQQSQQQQQQQQQQRAQPSQQGQQSQQZQG9QQVXSAR5WPEN5TE0D45KUAPWV4UXZMTSD3JJUCM0D5RQQRJRDANXVET9YPCXZ7TDV4H8GXHR3TQ
```

## Parsing Considerations

### Format Detection

When parsing a `creq` parameter, implementations SHOULD support both formats:

1. If the parameter starts with `creqA` (case-insensitive), parse as legacy CBOR+base64 format
2. If the parameter is valid Bech32m with HRP `creqb`, parse as NUT-26 format
3. Otherwise, return an error

### Unknown Tags

Unknown TLV tags at any level MUST be ignored. This ensures forward compatibility when new fields are added to the specification.

### Validation

Decoders SHOULD validate:

- Bech32m checksum is correct
- TLV length fields do not exceed buffer boundaries
- Required sub-fields are present (e.g., transport kind when transport is present)
- UTF-8 strings are valid
- Numeric values are within expected ranges

Decoders MUST NOT fail on unknown tags or optional missing fields.

## References

- [NUT-00][00]: Basic Cashu protocol
- [NUT-10][10]: Spending conditions
- [NUT-18][18]: Payment Requests (main specification)
- [BIP-173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki): Bech32 encoding
- [BIP-350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki): Bech32m encoding
- [NIP-19](https://github.com/nostr-protocol/nips/blob/master/19.md): Nostr bech32-encoded entities

[00]: 00.md
[10]: 10.md
[18]: 18.md
