# NUT-28: Conditional Token

`optional`

`depends on: NUT-02, NUT-06`

---

This NUT defines conditional tokens and conditional keysets for oracle-attested events.

A **conditional token** is a regular Cashu token ([NUT-00][00]) signed under a conditional keyset. It can be transferred and swapped like any other Cashu token, with one additional ability: it can be redeemed back to regular ecash via the dedicated `POST /v1/redeem_outcome` endpoint by providing a DLC oracle's attestation signature as a witness.

A **conditional keyset** is a per-outcome-collection signing keyset ([NUT-02][02]) that the mint creates for a specific outcome collection. Each outcome collection gets a unique keyset with different signing keys. The keyset is what distinguishes conditional tokens from regular tokens — the tokens themselves are standard Cashu proofs.

The oracle signature scheme is compatible with the [DLC (Discreet Log Contracts) specification](https://github.com/discreetlogcontracts/dlcspecs/blob/master/Oracle.md), allowing Cashu mints to leverage existing DLC oracle infrastructure. See [Oracle Communication](#oracle-communication) for details.

Caution: Applications that rely on oracle resolution must verify that the oracle is trustworthy and check via the mint's [info][06] endpoint that NUT-28 is supported.

## Terminology

- **Condition**: A question with defined outcomes, resolved by an oracle. Identified by a `condition_id` computed from oracle parameters. Equivalent to "condition" in the [Gnosis Conditional Token Framework](https://docs.gnosis.io/conditionaltokens/).
- **Outcome**: A single atomic result that an oracle attests to (e.g., `"YES"`, `"ALICE"`). The oracle signs an outcome string using the [DLC signing algorithm](https://github.com/discreetlogcontracts/dlcspecs/blob/master/Oracle.md#signing-algorithm).
- **Outcome collection**: A subset of a condition's outcomes, defined by a partition element (e.g., `"YES"`, `"ALICE|BOB"`). Each outcome collection gets its own conditional keyset. An outcome collection is redeemable if the oracle attests to ANY outcome contained in it. Equivalent to "index set" in the Gnosis CTF.
- **Partition**: A division of all outcomes into disjoint, complete outcome collections.
- **Condition ID** (`condition_id`): A 32-byte tagged hash uniquely identifying a condition, computed from oracle announcements and partition. See [Condition ID](#condition-id).
- **Outcome collection ID** (`outcome_collection_id`): A 32-byte tagged hash uniquely identifying a specific outcome collection within a condition. See [Outcome Collection ID](#outcome-collection-id).
- **Conditional keyset**: A per-outcome-collection signing keyset created by the mint during condition registration. Each outcome collection gets its own keyset with unique signing keys.
- **Conditional token**: A Cashu token signed under a conditional keyset. Conditional tokens can be traded freely and redeemed after oracle attestation.

## Outcome Collections

Outcome collections allow tokens to represent one or more outcomes. An outcome collection is either a single outcome or an OR-combination of outcomes joined by `|`. This enables positions like "not Trump" (covering all other candidates) without requiring users to hold separate tokens for each alternative outcome.

### Outcome Collection Notation

Outcome collections use pipe-separated outcome names:

- `"ALICE"` - Single outcome (standard)
- `"ALICE|BOB"` - Outcome collection covering outcomes ALICE or BOB
- `"ALICE|BOB|CAROL"` - Outcome collection covering three outcomes

If an outcome name contains the `|` character, it MUST be escaped as `\|`.

### Outcome Collection Keysets

Each outcome collection gets its own conditional keyset. The keyset maps to the set of outcomes it covers. For a 3-outcome condition `["ALICE", "BOB", "CAROL"]` with partition `{"ALICE|BOB": [...], "CAROL": [...]}`, the mint creates:

- `ALICE|BOB` → keyset ID `00aabb11cc22dd33`
- `CAROL` → keyset ID `00ccdd44ee55ff66`

Each outcome collection also has an `outcome_collection_id`:

```
outcome_collection_id = tagged_hash("Cashu_outcome_collection_id", outcome_collection_string || condition_id)
```

### Partition Rules

When registering a condition, the partition keys must form a valid **partition** of all outcomes:

1. **Disjoint**: No outcome can appear in multiple outcome collections
2. **Complete**: Every outcome in the event descriptor must appear in exactly one outcome collection

Valid partitions for a 3-outcome condition `["ALICE", "BOB", "CAROL"]`:

- `{"ALICE": [...], "BOB": [...], "CAROL": [...]}` (individual outcomes)
- `{"ALICE|BOB": [...], "CAROL": [...]}` (one outcome collection + one individual)
- `{"ALICE|BOB|CAROL": [...]}` (single outcome collection covering all - essentially a no-op)

Invalid partitions:

- `{"ALICE|BOB": [...], "BOB|CAROL": [...]}` - Overlapping (BOB appears twice)
- `{"ALICE|BOB": [...]}` - Incomplete (CAROL missing)

### Redemption with Outcome Collections

A conditional keyset is redeemable if the oracle attests to ANY outcome covered by the outcome collection:

```python
def can_redeem(outcome_collection_outcomes: list[str], oracle_attested: str) -> bool:
    return oracle_attested in outcome_collection_outcomes
```

The oracle signing algorithm remains unchanged - the oracle signs the single winning outcome. The mint checks if that outcome is in the keyset's outcome collection.

## Conditional Keysets

Each outcome collection is represented by a **unique keyset** created by the mint during [condition registration](#condition-registry). These conditional keysets use the same mechanism as regular keysets ([NUT-02][02]) -- the only difference is that they are associated with a specific outcome collection.

### Keyset Properties

- **Signing keys**: Each conditional keyset has unique signing keys derived by the mint from condition parameters
- **Unit**: Matches the collateral unit (e.g., `"sat"`)
- **Discovery**: Conditional keysets are served via the dedicated `GET /v1/conditional_keysets` endpoint with `condition_id`, `outcome_collection`, and `outcome_collection_id` fields (see [Conditional Keyset Discovery](#conditional-keyset-discovery))
- **Active flag**: Set to `true` during condition lifetime, `false` after resolution + vesting period
- **Expiry**: Conditional keysets MAY use a `final_expiry` timestamp corresponding to the vesting period end

### Why Conditional Keysets?

In Cashu's blind signature scheme, the mint cannot inspect or verify output spending conditions because outputs are blinded. The **only** attribute the mint controls about outputs is the **signing key** (keyset). Therefore, conditional keysets are the natural mechanism to distinguish token types -- exactly the same pattern Cashu uses to distinguish USD from BTC tokens.

This design means:

- **Proof secrets are regular random strings** -- no special secret structure required
- **Standard [NUT-03][03] swap** works for trading within the same conditional keyset
- **Dedicated redemption endpoint** (`POST /v1/redeem_outcome`) handles conditional-to-regular keyset conversion

## Token Lifecycle

```
Issuance:   Mint issues conditional tokens (via condition registration + keyset-specific minting)
Trading:    Conditional keyset -> same conditional keyset (NUT-03 swap, no witness)
Redemption: Conditional keyset -> regular keyset          (POST /v1/redeem_outcome + oracle witness)
```

- **Issuance**: The mint creates conditional keysets during [condition registration](#condition-registry). Users obtain conditional tokens through the [NUT-29][29] split operation (the most natural way to create complete sets of conditional tokens), or through any other minting mechanism the mint supports (e.g., AMM-based single-outcome-collection issuance).
- **Trading**: Conditional tokens are transferred and swapped using standard [NUT-03][03] swap within the same conditional keyset. No oracle witness is required.
- **Redemption**: After oracle attestation, winners submit conditional keyset tokens to `POST /v1/redeem_outcome` with oracle signatures in `Proof.witness`, receiving regular keyset tokens in return.

> **Note:** [NUT-29][29] provides additional structured split/merge operations for the CTF pattern, allowing users to atomically split collateral into complete sets of conditional tokens and merge them back.

## Condition ID

A condition is uniquely identified by a `condition_id` computed from the condition parameters using a BIP-340 tagged hash. This uses SHA256 tagged hashing instead of keccak256 for Bitcoin ecosystem consistency.

### Condition ID Calculation

```
condition_id = tagged_hash("Cashu_condition_id", sorted_oracle_pubkeys || sorted_event_id || outcome_count || sorted_partition_keys)
```

Where:

- `tagged_hash(tag, msg) = SHA256(SHA256(tag) || SHA256(tag) || msg)` — [BIP-340 tagged hash](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) convention
- `sorted_oracle_pubkeys`: One or more 32-byte x-only public keys of the oracles (same format as NUT-28), sorted lexicographically (byte-wise) and concatenated. For multi-oracle conditions with threshold `t` of `n` oracles, all `n` oracle pubkeys are included. Derived from `announcements[].oracle_public_key`.
- `sorted_event_id`: UTF-8 encoded event identifier string (called "question_id" in the original Gnosis CTF context). For combinatorial markets involving multiple conditions, condition identifiers MUST be sorted lexicographically (byte-wise) and concatenated with a null byte (0x00) separator before encoding. Derived from `announcements[].oracle_event.event_id`.
- `outcome_count`: 1-byte unsigned integer representing the number of outcomes. Derived from `len(announcements[0].oracle_event.event_descriptor.outcomes)`.
- `sorted_partition_keys`: Partition keys sorted lexicographically, UTF-8 encoded, joined with a null byte (0x00) separator. For the default partition (individual outcomes), these are the sorted outcome names from the event descriptor. For custom partitions using outcome collections, these are the sorted pipe-separated keys (e.g., `"ALICE|BOB"`, `"CAROL"`).

The `condition_id` is a 32-byte value encoded as a 64-character hexadecimal string. Since all components are derived from the announcements and the partition, the `condition_id` can be computed by either the wallet or the mint. The `condition_id` does NOT include any parent collection reference — it identifies only the question/condition to be resolved by an oracle.

**Rationale for sorting:** Sorting ensures that two equivalent conditions always produce the same `condition_id`. Different partitions of the same event (e.g., `{A,B},{C}` vs `{A},{B,C}`) intentionally produce different condition_ids, preventing keyset collisions.

> **Note:** [NUT-30][30] extends this formula with additional market-specific parameters for numeric conditions. Enum conditions (this NUT) use only the base formula above.

## Oracle Announcement Format

Oracle announcements MUST use the TLV format defined in the [DLC specification](https://github.com/discreetlogcontracts/dlcspecs/blob/master/Messaging.md#the-oracle_announcement-type) (`oracle_announcement`, TLV type 55332). In API request and response bodies, announcements are hex-encoded TLV byte strings.

## Oracle Communication

Oracle announcements and attestations use the [DLC specification](https://github.com/discreetlogcontracts/dlcspecs/blob/master/Oracle.md) format. This includes:

- **Signing algorithm**: BIP 340 Schnorr signatures with DLC tagged hashing (`"DLC/oracle/attestation/v0"`)
- **Announcement format**: [DLC oracle announcement](https://github.com/discreetlogcontracts/dlcspecs/blob/master/Messaging.md#the-oracle_announcement-type) (TLV type 55332)
- **Event descriptors**: Enum event descriptors defining possible outcomes as UTF-8 strings with NFC normalization

The communication transport for oracle announcements and attestations is unspecified by this NUT. [NIP-88](https://github.com/nostr-protocol/nips/pull/1681) (DLC oracle event kinds over Nostr) is one option for gossip-based oracle discovery and attestation distribution.

> **Note on adaptor signatures:** This specification does NOT use adaptor signatures. In Cashu's custodial model, the mint directly verifies the oracle's BIP 340 signature -- no adaptor encryption/decryption is needed.

> **Note on oracle attestation optionality:** Oracle attestation is optional in principle. When the mint operator serves as the oracle (e.g., resolving disputes manually), no external attestation is needed. However, oracle attestation is useful for two reasons: (1) It provides a standardized way for mints to verify redemption claims, and (2) When combined with DLEQ Proof ([NUT-12][12]) and [Proof of Liabilities](https://gist.github.com/callebtc/ed5228d1d8cbaade0104db5d1cf63939), it can serve as a fraud proof if the mint fails to honor valid redemptions.

## Condition Registry

Conditions are registered via `POST /v1/conditions` before any operations on conditional tokens. The mint maintains a registry of conditions with their parameters and creates conditional keysets during registration.

### Condition Info

```json
{
  "condition_id": <hex_str>,
  "collateral": <str>,
  "parent_collection_id": <hex_str>,
  "depth": <int>,
  "threshold": <int>,
  "description": <str>,
  "announcements": <Array[hex_str]>,
  "keysets": {
    "<outcome_collection>": <str>,
    ...
  },
  "attestation": {
    "status": <str>,
    "winning_outcome": <str>,
    "attested_at": <int>
  }
}
```

- `condition_id`: Computed condition identifier (derived from announcements, see [Condition ID Calculation](#condition-id-calculation))
- `collateral`: For root conditions (depth 1): a [NUT-00][00] unit string (e.g., `"sat"`, `"usd"`). For nested conditions (depth > 1): an `outcome_collection_id` (hex string) identifying the parent outcome collection whose tokens serve as collateral.
- `parent_collection_id`: 32-byte x-only public key (64 hex chars) representing the parent outcome collection. `"0000000000000000000000000000000000000000000000000000000000000000"` for root conditions. Used in [NUT-29][29] combinatorial markets.
- `depth`: 1 for root conditions, 2+ for nested conditions
- `threshold`: Minimum number of oracles required for attestation (default: 1)
- `description`: Human-readable condition description
- `announcements`: Array of hex-encoded oracle announcement TLV bytes (see [Oracle Announcement Format](#oracle-announcement-format))
- `keysets`: Object mapping each outcome collection to its keyset ID
- `attestation` (optional): Attestation state for this condition. Omitted if the mint does not yet have an attestation.
  - `status`: One of `"pending"` (no attestation yet), `"attested"` (oracle has attested, redemption active), `"expired"` (vesting period ended), `"violation"` (observed more than 1 attestation for this condition)
  - `winning_outcome`: The attested winning outcome string. `null` if `status` is `"pending"`.
  - `attested_at`: Unix timestamp of when the attestation was recorded. `null` if `status` is `"pending"`.

The `oracle_pubkeys`, `event_id`, `outcomes`, and `maturity` fields can be derived by parsing the announcement TLV and are not included separately in the Condition Info.

### Get Conditions

```
GET /v1/conditions
```

Returns an array of available conditions:

```json
{
  "conditions": <Array[ConditionInfo]>
}
```

### Get Condition

```
GET /v1/conditions/{condition_id}
```

Returns details for a specific condition:

```json
{
  "condition": <ConditionInfo>
}
```

### Register Condition

```
POST /v1/conditions
```

Registers a new condition and creates conditional keysets. This allows wallets to discover conditional keyset IDs before performing any operations with conditional tokens. This is analogous to the `prepareCondition` operation in the Gnosis CTF.

#### Request Body

```json
{
  "collateral": <str>,
  "threshold": <int>,
  "description": <str>,
  "announcements": <Array[hex_str]>,
  "partition": <Array[str]>,
  "parent_collection_id": <hex_str>
}
```

- `collateral`: For root conditions: a [NUT-00][00] unit string (e.g., `"sat"`, `"usd"`). For nested conditions: an `outcome_collection_id` (hex string) identifying the parent outcome collection whose tokens serve as collateral. The mint creates conditional keysets with the appropriate collateral reference.
- `threshold`: Minimum number of oracles required for attestation (default: 1)
- `description`: Human-readable condition description
- `announcements`: Array of hex-encoded oracle announcement TLV bytes (see [Oracle Announcement Format](#oracle-announcement-format))
- `partition` (optional): Array of partition keys defining the outcome collection grouping. Each key is a single outcome name or a pipe-separated outcome collection (e.g., `["ALICE|BOB", "CAROL"]`). When omitted, defaults to individual outcomes from the event descriptor. The partition MUST satisfy the [Partition Rules](#partition-rules).
- `parent_collection_id` (optional): A 32-byte x-only public key (64 hex chars) representing the parent outcome collection. Defaults to 32 zero bytes (`"0000000000000000000000000000000000000000000000000000000000000000"`) for root conditions. Used in [NUT-29][29] combinatorial markets.

#### Response Body

```json
{
  "condition_id": <hex_str>,
  "keysets": {
    "<outcome_collection_1>": <str>,
    "<outcome_collection_2>": <str>,
    ...
  }
}
```

- `condition_id`: The 32-byte condition identifier computed from the announcements and partition (64 hex characters)
- `keysets`: Object mapping each outcome collection to its keyset ID (one keyset per outcome collection)

#### Mint Behavior

1. Determines the partition: uses `partition` if provided, otherwise defaults to individual outcomes from the event descriptor
2. Validates the partition satisfies the [Partition Rules](#partition-rules) (error 13037 if overlapping, error 13038 if incomplete)
3. Computes `condition_id` from the provided announcements and partition
4. If `parent_collection_id` is non-zero: the mint **MUST** verify that the referenced collection ID corresponds to an active outcome collection from a previously registered condition. If not found, return error 13021 (Condition not found).
5. If condition already exists with matching configuration: returns existing `condition_id` and `keysets` (idempotent)
6. If condition already exists with different configuration: returns error 13028
7. If condition is new: verifies announcement signatures, creates conditional keysets (one per partition key), stores configuration, returns `condition_id` and `keysets`

Mints MAY protect the `POST /v1/conditions` endpoint against abuse by requiring authentication via [NUT-21][21] or [NUT-22][22]. When blind authentication ([NUT-22][22]) is required, each condition registration costs a blind auth token, providing economic DoS prevention without IP-based rate limiting.

#### Errors

- 13011: Oracle announcement verification failed
- 13021: Condition not found (also returned when `parent_collection_id` references a non-existent collection)
- 13028: Condition already exists (with different configuration)

## Outcome Collection ID

Each outcome collection has a unique `outcome_collection_id` computed from the outcome collection string and condition ID using a BIP-340 tagged hash:

```
outcome_collection_id = tagged_hash("Cashu_outcome_collection_id", outcome_collection_string || condition_id)
```

Where:

- `tagged_hash(tag, msg) = SHA256(SHA256(tag) || SHA256(tag) || msg)` — [BIP-340 tagged hash](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) convention
- `outcome_collection_string`: UTF-8 encoded outcome collection (e.g., `"YES"` or `"ALICE|BOB"`)
- `condition_id`: 32-byte condition identifier (see [Condition ID](#condition-id))

The `outcome_collection_id` is a 32-byte value (64-character hex string). It serves as a globally unique identifier for a specific outcome collection within a specific condition and is used as collateral reference in combinatorial markets ([NUT-29][29]).

## Conditional Keyset Discovery

Conditional keysets are served on a dedicated endpoint, separate from the standard `GET /v1/keysets` endpoint ([NUT-02][02]). This separation ensures backward compatibility — wallets that do not support NUT-28 will not see conditional keysets in the regular keyset list, avoiding confusion with unknown fields or keyset types. It also prevents conditional keysets from inflating the regular keyset listing.

### Endpoint

```
GET /v1/conditional_keysets
```

### Response

The response is structurally identical to the `GET /v1/keysets` response ([NUT-02][02]), with three additional fields that are always present on every entry:

```json
{
  "keysets": [
    {
      "id": <hex_str>,
      "unit": <str>,
      "active": <bool>,
      "input_fee_ppk": <int|null>,
      "final_expiry": <int|null>,
      "condition_id": <hex_str>,
      "outcome_collection": <str>,
      "outcome_collection_id": <hex_str>
    },
    ...
  ]
}
```

- `condition_id`: 32-byte condition identifier (64-character hex string). Corresponds to the `condition_id` from [condition registration](#condition-registry).
- `outcome_collection`: The outcome collection string this keyset represents (e.g., `"YES"`, `"ALICE|BOB"` for outcome collections).
- `outcome_collection_id`: 32-byte outcome collection identifier (64-character hex string). Computed as `tagged_hash("Cashu_outcome_collection_id", outcome_collection_string || condition_id)`.

All three fields (`condition_id`, `outcome_collection`, `outcome_collection_id`) MUST be present for every keyset entry in this response.

> **Note:** The standard `GET /v1/keys/{keyset_id}` endpoint ([NUT-02][02]) still works for fetching the public keys of a specific conditional keyset by its ID.

### Example

```json
{
  "keysets": [
    {
      "id": "00abc123def456",
      "unit": "sat",
      "active": true,
      "input_fee_ppk": 0,
      "final_expiry": 1753920000,
      "condition_id": "a1b2c3d4e5f6789012345678901234567890123456789012345678901234abcd",
      "outcome_collection": "YES",
      "outcome_collection_id": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    },
    {
      "id": "00def789abc012",
      "unit": "sat",
      "active": true,
      "input_fee_ppk": 0,
      "final_expiry": 1753920000,
      "condition_id": "a1b2c3d4e5f6789012345678901234567890123456789012345678901234abcd",
      "outcome_collection": "NO",
      "outcome_collection_id": "f4a1b55298fc2c259bfcf5d9aa7fc8a3538bf52f575ac045ba5a6a02c8963c966"
    }
  ]
}
```

## Redemption Witness

When redeeming conditional keyset tokens via `POST /v1/redeem_outcome`, each input `Proof` must include a `witness` field containing the oracle's attestation. The `witness` is a serialized JSON string:

```json
{
  "oracle_sigs": [
    {
      "oracle_pubkey": <hex_str>,
      "oracle_sig": <hex_str>
    }
  ]
}
```

- `oracle_sigs`: Array of oracle attestation objects. Must contain at least `threshold` entries from distinct oracles.
  - `oracle_pubkey`: The oracle's 32-byte x-only public key (64-character hex string) identifying which oracle produced this attestation
  - `oracle_sig`: The oracle's 64-byte Schnorr signature (128-character hex string) on the winning outcome string

Always use the array format, even for single-oracle markets (threshold=1). This avoids two code paths for implementers.

### Example Witness

Single oracle (threshold=1):

```json
{
  "oracle_sigs": [
    {
      "oracle_pubkey": "9be6fa256a022aafc98f24a71f0e37ab2ac6fe5b208a77a3d429b4b5c59f7ce0",
      "oracle_sig": "a1b2c3d4...64_bytes...f1e2d3a4"
    }
  ]
}
```

Multi-oracle (threshold=2):

```json
{
  "oracle_sigs": [
    {
      "oracle_pubkey": "9be6fa256a022aafc98f24a71f0e37ab2ac6fe5b208a77a3d429b4b5c59f7ce0",
      "oracle_sig": "a1b2c3d4...64_bytes...f1e2d3a4"
    },
    {
      "oracle_pubkey": "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "oracle_sig": "b2c3d4e5...64_bytes...e2f3a4b5"
    }
  ]
}
```

### Relationship to Existing Witness Types

The Redemption Witness extends the established Cashu pattern where `Proof.witness` carries condition-specific unlock data:

| NUT                      | Witness Type       | Format                                     | Trigger                             |
| ------------------------ | ------------------ | ------------------------------------------ | ----------------------------------- |
| [NUT-11][11] (P2PK)      | Signature          | `{"signatures": [...]}`                    | Secret is P2PK kind ([NUT-10][10])  |
| [NUT-14][14] (HTLC)      | Preimage + sig     | `{"preimage": "...", "signatures": [...]}` | Secret is HTLC kind ([NUT-10][10])  |
| **NUT-28** (Conditional) | Oracle attestation | `{"oracle_sigs": [...]}`                   | Dedicated `redeem_outcome` endpoint |

Key difference: [NUT-11][11] and [NUT-14][14] witnesses are triggered by the **secret structure** ([NUT-10][10] well-known format). NUT-28 witnesses are triggered by the **endpoint** — the dedicated `POST /v1/redeem_outcome` endpoint requires oracle attestation. Proof secrets remain plain random strings.

## Redemption Endpoint

Redemption uses a dedicated endpoint rather than overloading the standard [swap][03] operation. This makes the redemption intent unambiguous and avoids complex cross-keyset detection logic in [NUT-03][03].

### Endpoint

```
POST /v1/redeem_outcome
```

### Request Body

```json
{
  "inputs": <Array[Proof]>,
  "outputs": <Array[BlindedMessage]>
}
```

- `inputs`: Array of `Proof` objects from a **single conditional keyset**, each with `witness` containing oracle attestation (see [Redemption Witness](#redemption-witness))
- `outputs`: Array of `BlindedMessage` objects using a **regular keyset** (same unit as the conditional keyset)

Wallets MAY omit the `oracle_sigs` from the witness if the mint has already received a valid attestation for the same outcome collection. If the mint has previously verified and recorded the winning attestation, it MAY skip `oracle_sigs` verification and perform the redemption based on its stored attestation state. Wallets can check the attestation state via `GET /v1/conditions/{condition_id}` to determine whether the mint has already recorded an attestation.

### Response Body

```json
{
  "signatures": <Array[BlindSignature]>
}
```

Each `BlindSignature` corresponds to a `BlindedMessage` in the request, creating regular (non-conditional) proofs.

### Consequence for NUT-03

Mints implementing NUT-28 **MUST** enforce that [NUT-03][03] swap requests reject cross-keyset operations — all inputs and all outputs in a swap **MUST** use the same keyset ID. This prevents redemption of conditional tokens without oracle attestation.

Within [NUT-03][03]:

- Swaps within the same conditional keyset (trading) work as normal
- Swaps within a regular keyset work as normal
- Any swap where input keyset IDs differ from output keyset IDs **MUST** be rejected

All conditional-to-regular keyset conversions go through `POST /v1/redeem_outcome`.

## Redemption Verification

When the mint receives a `POST /v1/redeem_outcome` request, it MUST perform the following verification:

1. All inputs MUST use the same conditional keyset
2. All outputs MUST use a regular keyset (same unit as the input conditional keyset)
3. If the mint has already recorded a valid attestation for this outcome collection, it MAY skip steps 4-5 and proceed directly to step 6
4. Each input MUST include a valid `witness` with `oracle_sigs`
5. Verify `oracle_sigs` contains at least `threshold` entries from distinct oracles (identified by `oracle_pubkey`). For each entry, verify `oracle_sig` against the `oracle_pubkey` using the [DLC signing algorithm](https://github.com/discreetlogcontracts/dlcspecs/blob/master/Oracle.md#signing-algorithm) with tagged hash `"DLC/oracle/attestation/v0"` and the UTF-8 NFC-normalized outcome string
6. The mint MUST verify that this outcome collection is the attested winner (see [Attestation Handling](#attestation-handling))

### Attestation Handling

When an oracle attests to a winning outcome, the mint **MUST** persistently record the first valid attestation (winning outcome and timestamp) for each condition. This record **MUST** survive mint restarts.

The mint **MUST NOT** process redemptions for non-winning conditional keysets, even if a valid signature for those outcomes were somehow produced (e.g., through oracle key compromise).

Mints **MUST** reject redemption attempts for other conditional keysets after the first valid attestation is processed.

If the mint receives a valid oracle signature for a different outcome of the same condition (a DLC protocol violation), the mint **MUST** reject it and **MUST** log the conflict. Mints SHOULD expose detected DLC violations to users via the condition info endpoint.

## Vesting Period

The mint MAY deactivate conditional keysets and stop honoring redemptions after a vesting period following event maturity. This vesting period allows users adequate time to redeem their winning conditional tokens after oracle attestation.

**Recommendation**: The vesting period SHOULD be at least 30 days after `event_maturity_epoch`. Mints MUST clearly communicate their vesting period via the [Mint Info Setting](#mint-info-setting).

After the vesting period expires:

- The mint sets conditional keyset `active` to `false`
- The mint MAY refuse to process redemptions for expired conditional keysets
- The mint MAY delete all event-related data
- Users SHOULD be aware of the vesting period and redeem before expiry

> **Wallet warning**: Wallets SHOULD prominently display the vesting period deadline to users holding winning conditional tokens. Funds that are not redeemed before the vesting period expires may be permanently lost. Wallets SHOULD alert users as the deadline approaches.

### Oracle Non-Attestation

If the oracle does not publish a valid attestation within the expected time, the mint MAY refund conditional tokens back to regular ecash at a price of its choosing. This allows the mint to unwind markets where the oracle has become unresponsive or failed to attest, preventing user funds from being locked indefinitely.

## Error Codes

| Code  | Description                                        |
| ----- | -------------------------------------------------- |
| 13010 | Invalid oracle signature                           |
| 13011 | Oracle announcement verification failed            |
| 13014 | Conditional keyset requires oracle witness         |
| 13015 | Oracle has not attested to this outcome collection |
| 13016 | Inputs must use the same conditional keyset        |
| 13017 | Outputs must use a regular keyset                  |
| 13020 | Invalid condition ID                               |
| 13021 | Condition not found                                |
| 13027 | Oracle threshold not met                           |
| 13028 | Condition already exists                           |
| 13037 | Overlapping outcome collections                    |
| 13038 | Incomplete partition                               |

## Mint Info Setting

The [NUT-06][06] `MintMethodSetting` indicates support for this feature:

```json
{
  "28": {
    "supported": true,
    "dlc_version": <string>,
    "vesting_period": <int>
  }
}
```

- `supported`: Boolean indicating NUT-28 support
- `vesting_period`: (optional) Number of seconds after `event_maturity_epoch` during which the mint will honor redemptions. If not specified, implementations SHOULD assume a minimum of 30 days (2592000 seconds). A value of `0` indicates no expiry.
- `dlc_version` ... The latest version of the DLC protocol that it supports. As the time of writing `"0"` is the only DLC protocol version.

[00]: 00.md
[01]: 01.md
[02]: 02.md
[03]: 03.md
[04]: 04.md
[05]: 05.md
[06]: 06.md
[07]: 07.md
[08]: 08.md
[09]: 09.md
[10]: 10.md
[11]: 11.md
[12]: 12.md
[14]: 14.md
[21]: 21.md
[22]: 22.md
[29]: 29.md
[30]: 30.md
