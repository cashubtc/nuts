# NUT-AC-00: Introduction & General Scheme Overview

`mandatory`

---

This document details the notation and models used throughout the specification and lays the groundwork for understanding the basic cryptography used in the Cashu AC (Anonymous Credentials) protocol extension.

- Sending user: `Alice`
- Receiving user: `Carol`
- Mint: `Bob`

# Keyed-Verification Anonymous Credentials (KVAC)

## `hash_to_curve(x: bytes) -> curve point Y`

Deterministically maps a message to a public key point on the secp256k1 curve, utilizing a domain separator to ensure uniqueness.

`Y = PublicKey('02' || SHA256(msg_hash || counter))` where `msg_hash` is `SHA256(DOMAIN_SEPARATOR || x)`

- `Y` derived public key
- `DOMAIN_SEPARATOR` constant byte string `b"Secp256k1_HashToCurve_Cashu_"`
- `x` message to hash
- `counter` uint32 counter(byte order little endian) incremented from 0 until a point is found that lies on the curve

## Generators

Generators are points on the `secp256k1` curve can be used as a basis from which it's possible to compute any other point on the curve through repetitive adding.

Each generator is derived using NUMS (Nothing Up My Sleeve) as `hash_to_curve(<generator_name_or_subscript>)`.

For example, $G_w$ is obtained by inputting the subscript `w` into `hash_to_curve`:
```
G_w = hash_to_curve("w")
```
This ensures that the discrete logarithm relation between any pair of them remains unknown.

The term "generator" here is used loosely. While NUMS points might not necessarily generate the entire group of points on the curve, they can still be considered generators in the sense that they can be used to derive a large number of other points through repeated point addition:

- $G_w, G_{w'}, G_{x_0}, G_{x_1}$: Used for computation of the algebraic MAC (on the Mint's side) and later in credential presentation.
- $G_\text{zmac}, G_\text{zamount}, G_\text{zscript}$: Used in credential presentation.
- $G_\text{amount}, G_\text{script}$: Used for encoding amounts and scripts (spending conditions).
- $G_\text{blind}$: Used for the blinding terms.

## Mint Keys
`MintPrivateKey` is a single tuple of six secret values (for all amounts):
```math
sk = (w, w', x_0, x_1, y_a, y_s)
```

* $y_a$: key for signing amount commitments.
* $y_s$: key for signing script commitments.
* $w, w', x_0, x_1$: additional secret values needed for the algebraic MAC as presented in [[1]](1)

`MintPublicKey` is a tuple $(I, C_w)$, calculated as:
```math
\displaylines{
I = G_\text{zmac} - (x_0G_{x_0} + x_1G_{x_1} + y_aG_\text{zamount} + y_sG_\text{zscript})\\
C_w = wG_w + w'G_{w'}
}
```


## Pedersen Commitments

A Pedersen Commitment is a cryptographic primitive used to commit to a chosen value while keeping it hidden.

Given two generators $G$ and $H$ such that the discrete logarithm relation between them is unknown, a Pedersen Commitment that hides a secret value $a$ with blinding factor $r$ is computed as:
```math
    M = a\cdot G + r\cdot H
```

This commitment has certain properties that make it particularly useful:

* **Hiding**: The commitment doesn't reveal the value. This means that given the commitment, one cannot infer the original value $a$.

* **Binding**: Once committed to a value, one cannot change it. This ensures that one can't claim the commitment represents some other value.

* **Homomorphism**: Pedersen Commitments have a mathematical property where commitments can be combined.


## Attributes

A `AmountAttribute` is tuple $(a, r)$ where $a$ is a scalar value encoding an amount in Big-Endian format and $r_a$ is a scalar chosen uniformly at random.

If you know `AmountAttribute` you can derive its commitment value:

```math
M_a = a \cdot G_\text{amount} + r_a \cdot G_\text{blind}
```

A `ScriptAttribute` is a tuple $(s, r)$ where $s$ is a scalar value encoding the SHA-256 hash of a particular script or spending condition, and $r_s$ is a scalar chosen uniformly at random.

Likewise, if you know `ScriptAttribute` you can derive its commitment value:

```math
M_s = s \cdot G_\text{script} + r_s \cdot G_\text{blind}
```

## MAC (Message Authentication Code)

A `MAC` is a pair $(t, V)$ of a scalar $t$ and a curve point $V$ issued by `Bob` on a pair of attribute commitments $(M_a, M_s)$ and represents the "approval stamp" or "signature" that `Bob` is willing to attribute to said commitments.

$t$ -also referred to as "tag"- is chosen uniformly at random by `Alice`, while $V$ is computed by `Bob` as follows:

```math
\displaylines{
U = \text{hash_to_curve}(t)\\
V = w\cdot G_w + x_0\cdot U + x_1tU + y_a\cdot M_a + y_s\cdot M_s
}
```

## Coin
A `Coin` is a collection of the following:
* `MAC`
* `AmountAttribute`
* `ScriptAttribute`.

`Alice` can put together a `Coin` after receiving the `MAC` from `Bob`.

## Protocol

This section describes the protocol, which is composed by 3 phases:

1) **Bootstrap**: Una-tantum phase in which `Alice` asks `Bob` for a `MAC` on commitments encoding $0$. Since every request in the protocol expects inputs and outputs, this step is crucial for getting initial inputs.

2) **Issuance**: `Alice` pays `Bob` and asks to issue a `MAC` on commitments that encode value

3) **Redemption**: `Alice` presents `Bob` with valid coins and requests a payout.

> [!NOTE]
> Phases 2 and 3 always happen simultaneously: `Alice` presents valid credentials and asks for new ones in **EVERY** request.

We use $\pi_\text{<subscript>}$ to refer to Zero-Knowledge proofs. They are thoroughly described in a later section.

### Bootstrap

0. `Bob` publicly announces `MintPublicKey`
1. `Alice` produces an `AmountAttribute` commitment $M_a$ that encodes $0$ and a `ScriptAttribute` commitment $M_s$ that encodes $s = H("")$.
2. `Alice` generates $\pi_\text{bootstrap}$, to show that $M_a$ encodes $0$ without revealing the blinding factor $r_a$.
3. `Alice` sends $(t, M_a, M_s, \pi_\text{bootstrap})$ to `Bob`, where $t$ is a scalar chosen uniformly at random.
4. `Bob` verifies $\pi_\text{bootstrap}$ and issues a `MAC` on $(M_a, M_s)$.
5. `Bob` generates $\pi_\text{issuance}$, to prove that `MAC` was issued with `MintPrivateKey`.
6. `Alice` receives $(t, V, \pi_\text{issuance})$ and verifies $\pi_\text{issuance}$.
7. `Alice` saves `Coin(AmountAttribute, ScriptAttribute, MAC)`

### Issuance & Redemption

1. `Alice` creates request <u>outputs</u>: **new** `AmountAttribute` and `ScriptAttribute` pairs that encode respectively the final wallet balance (minus any fees) and, optionally, the hash of the script describing the spending conditions.

2. `Alice` creates request <u>inputs</u> by taking a previously received `Coin` and randomizing it into a `RandomizedCoin`, which is what breaks the link to its issuance. The process works as follows:
    * `(AmountAttribute, ScriptAttribute, MAC) = Coin`
    * $U = \text{HashToCurve}(t)$, where $t$ is the `MAC` scalar value
    * $C_a = r_a\cdot G_\text{zamount} + M_a$, where $r_a$ is the blinding value for `AmountAttribute`.
    * $C_s = r_a\cdot G_\text{zscript} + M_s$
    * $C_{x_0} = r_a\cdot G_{x_0} + U$
    * $C_{x_1} = r_a\cdot G_{x_1} + t\cdot U$
    * $C_v = r_a\cdot G_\text{zmac} + V$, where $V$ is the `MAC` public point value
    * `RandomizedCoin`: $(C_a, C_s, C_{x_0}, C_{x_1}, C_v)$

> [!NOTE]
> Slight deviation from the original KVAC scheme, where the value is picked as a random $z$.
> We choose to use $r_a$ because we eliminate 1 witness value from $\pi_\text{MAC}$ and simplify it a bit.

3. `Alice` generates the following Zero-Knowledge Proofs:
    - $\pi_\text{balance}$: Proves that the balance difference $\Delta_a$ between inputs and outputs is consistent with the request's claim.
    - $\pi_\text{range}$: For each new `AmountAttribute` in the outputs, proves the committed value is within the range $[0, L-1]$, where $L$ is some agreed upon bound.
    - $\pi_\text{MAC}$: For each `RandomizedCoin` shows that it indeed is the valid randomized version of <u>some</u> existing `Coin`.


---

[1]: https://signal.org/blog/pdfs/signal_private_group_system.pdf