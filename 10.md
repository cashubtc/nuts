NUT-10: Animated QR-codes
==========================

`optional` `author: gandlaf21`

---

NUT-10 outlines how tokens that are too large to be displayed in a single QR-code shall be broken up and animated.

## Notation

`!<job-id>:<nonce>:<chunk-index>:<total-chunks>:<data><padding>`

Example:

`!1a4ef:0:1:5:<data>=====`

Fields:

* `!` : indicates that this QR-code is a chunk.
* `job-id` : The first characters of the `sha256` hash of the entire Cashu token, to distinguish different scan jobs from each other. It can also be used to verify the payload after scanning completion, although this is not strictly necessary since QR-codes have error correction built in.
* `nonce` : increasing counter after each "display" round. This is needed because some QR-codes are harder to scan than others. Changing a byte in the QR-code will change the entire image, reducing probability of being stuck on hard to scan codes. If the nonce is not dynamic, the scheme will still work, but scanning might be less consistent.
* `chunk-index` : the index of the current chunk. This is used on the scanner side to see which chunks have already been scanned
* `total-chunks` : the total amount of chunks for a scan job. This is used for recognizing completion, once the scanned chunks match the total chunks.
* `data` : Chunk data of the token that is being sent
* `padding` : optional padding, to unify the size of the QR-codes. Only used on the last frame. can use `=` as base64 padding.

Constants:

* `FPS` : frames per second. works best with maximum `5 fps` , or `200ms` frame show time
* `CHUNK_SIZE` : The size of the chunk. The trade-off here is while smaller chunks are easier to scan, larger chunks lead to a smaller amount of total chunks. Chunk size is in bytes an contains all the data, including all fields. The buffer field is used if there is not enough data left to construct a full chunk. 
* `MAX_NONCE` : after which number the nonce should be reset to 0. This scheme doesn't require many nonces, just enough to catch hard to scan QR-codes. `8` is recommended, so we can use a simple counter for the nonce and keep the chunk overhead small    
* `ID_LENGTH` : The length of the job-id. It's not critical that there are no collisions, so a length of `5` would suffice.


example implementation (typescript):

```typescript
import { sha256 } from "@noble/hashes/sha256";
import { bytesToHex } from "@noble/hashes/utils";
export const getChunks = (data: string, nonce = 0, chunkSize = 200): Array<string> => {
        const CHUNK_SIZE = 200
        const chunks = data.match(new RegExp('.{1,' + CHUNK_SIZE + '}', 'g'))??[];
        const constructedChunks  = chunks.map((c,i) => `!${bytesToHex(sha256(data)).substring(0,4)}:${nonce}:${i}:${chunks.length-1}:${c}`)
        const longest = Math.max(...constructedChunks.map(c=> c.length))
        for (let i = 0; i < constructedChunks.length; i++) {
            constructedChunks[i] = constructedChunks[i].padEnd(longest, "=")
        }
        return constructedChunks
}


export const assembleChunks = (chunks: Array<string>): string => {
    const tokenChunks = chunks.map(c => parseChunk(c))
    tokenChunks.sort((a,b)=> a.chunkIndex - b.chunkIndex)
    return tokenChunks.map(c=> c.data).join('')
}

const parseChunk = (chunk: string): Chunk => {
    const split = chunk.split(':')
    return {
        jobId: split[0],
        nonce: parseInt(split[1]),
        chunkIndex: parseInt(split[2]),
        totalChunks: parseInt(split[3]),
        data: split[4]
    }
}

type Chunk = {
    jobId: string
    nonce: number
    chunkIndex: number
    totalChunks: number
    data: string
}
```

Inspired by:

https://github.com/gre/qrloop