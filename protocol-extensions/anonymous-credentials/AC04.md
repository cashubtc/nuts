# AC-04: Mint Transaction

`mandatory`

---

Status: Stable draft
Scope: Quoting and executing mint to obtain signatures on new Outputs after external payment
Dependencies: AC-00, AC-01, AC-02, AC-03, NUT-20, NUT-23, NUT-25

Minting is a two-step process: (1) request a quote for the chosen payment method, (2) after payment, submit a mint request to obtain MACs over client-provided Outputs. This document mirrors the AC-06 structure for clarity and interop.

## 1. Supported methods

Method-specific NUTs describe payment handling:
- [NUT-23][23] — bolt11 Lightning invoices
- [NUT-25][25] — bolt12 Offers

## 2. Endpoints

- POST `/v1/mint/quote/{method}` — request a mint quote
- GET `/v1/mint/quote/{method}/{quote_id}` — check quote status
- POST `/v1/kvac/mint/{method}` — execute mint after payment

Content-Type: application/json

## 3. Request/Response: Mint Quote

### 3.1 Request (quote)

```http
POST https://mint.host:3338/v1/mint/quote/{method}
```

Body (baseline, method-specific fields may apply):
```json
{
  "unit": "<str_enum[UNIT]>"
}
```

### 3.2 Response (quote)

```json
{
  "quote": "<str>",
  "request": "<str>",
  "unit":  "<str_enum[UNIT]>"
  // method-specific fields may be included
}
```

Notes:
- `quote` is a unique, random identifier used to look up payment state. It MUST NOT be derivable from the payment request.
- Keep `quote` secret; use [NUT-20][20] locks to mitigate front‑running.

### 3.3 Check quote status

```http
GET https://mint.host:3338/v1/mint/quote/{method}/{quote_id}
```

Response: same structure as initial quote response; method-specific fields may indicate status.

## 4. Request: Execute Mint

After paying the quote, the wallet submits:

```http
POST https://mint.host:3338/v1/kvac/mint/{method}
```

Body `MintRequest` (baseline):
```json
{
  "quote": "<string>",
  "inputs": [<Input>, ...],
  "outputs": [<Output>, ...],
  "balance_proof": "<cashu_kvac::models::ZKP>",
  "mac_proofs": ["<cashu_kvac::models::ZKP>", ...],
  "range_proof": "<cashu_kvac::models::RangeZKP>"
  // method-specific fields may be included
}
```

Constraints:
- inputs.len() == 2 (exactly two inputs required)
- outputs.len() == 2 (exactly two outputs required)
- mac_proofs.len() == 2
- All Inputs/Outputs MUST share the same `unit` (see AC-00).
- Each `outputs[i].id` MUST correspond to an active keyset (AC-01/AC-02).
- `quote` MUST be known, paid, and unexpired.
- Transcript ordering for proofs MUST match the Mint (see §5).

Decoy shaping rules:
- If the wallet has fewer than two Inputs, it SHOULD obtain zero-amount Notes from [AC-06] and include them as decoy Inputs.
- If the wallet has fewer than two Outputs, it SHOULD include a decoy Output encoding amount 0. The decoy Output MUST be covered by the RangeProof like any other Output.
Balance constraint (delta):
- Let `fees = sum(input_fees)` per AC-02 for the given keysets present in `inputs`.
- The BalanceProof MUST verify with `delta = fees - quote_amount` so that `inputs - outputs == fees - quote_amount`.
  - If there are no inputs or no keyset fees, this reduces to `inputs - outputs == -quote_amount` (i.e., outputs encode exactly `quote_amount` more than inputs).

## 5. Mint Verification

Upon receiving `MintRequest`, the Mint performs:

1) Quote checks
- Verify `quote` exists, is paid, and not expired. Reject otherwise.

2) Unit/keyset checks
- Verify single-unit consistency across Inputs/Outputs.
- Ensure each Output’s keyset id is active.

3) Script verification
- For each Input, verify `script`/`witness` per [NUT-11] or [NUT-14]. Reject on policy failure.

4) Nullifier checks
- Derive nullifier from `input.randomized_commitments.Cv` and reject if already seen.

5) Initialize transcript
```rust
let mut transcript = cashu_kvac::transcript::CashuTranscript::new();
```

6) Verify MacProofs (one per Input)
```rust
cashu_kvac::kvac::MacProof::verify(
    &mint_privkeys[input.id],
    &input.randomized_commitments,
    &input.script,
    mac_proof,
    &mut transcript,
);
```

7) Verify RangeProof for Outputs
```rust
let amount_commitments: Vec<GroupElement> = outputs.iter().map(|o| o.commitments.0).collect();
cashu_kvac::kvac::RangeProof::verify(&mut transcript, &amount_commitments, range_proof);
```

8) Verify BalanceProof
```rust
cashu_kvac::kvac::BalanceProof::verify(
    &inputs_randomized_commitments,
    &outputs_amount_commitments,
    (fees as i64) - (quote_amount as i64),
    balance_proof,
    &mut transcript,
);
```

9) Issue MACs and IssuanceProofs
```rust
let mac = cashu_kvac::models::MAC::generate(
    &mint_privkeys[output.id],
    &output.commitments.0,
    Some(&output.commitments.1),
    Some(output.tag),
);
let issuance_proof = cashu_kvac::kvac::IssuanceProof::create(
    &mint_privkeys[output.id],
    output.tag,
    mac,
    output.commitments.0,
    Some(output.commitments.1),
);
```

## 6. Response

`MintResponse` (identical structure to `SwapResponse` in AC-03):

```json
{
  "outputs": [<Output>, ...],
  "issued_macs": ["<hex-pubkey>", ...],
  "issuance_proofs": ["<cashu_kvac::models::ZKP>", ...]
}
```

## 7. Client Verification and Note Assembly

As in AC-03/AC-06: verify `IssuanceProof` per Output and assemble `Note`s if verification succeeds.

## 8. Errors

- 400 Bad Request
  - Empty `outputs`
  - Length mismatch (`inputs` vs `mac_proofs`)
  - Malformed proof encoding
  - Missing/invalid `quote` format
- 404 Not Found
  - Unknown `quote`
- 409 Conflict
  - Quote unpaid or expired
  - Nullifier already seen (double-spend)
- 422 Unprocessable Entity
  - Inactive/unknown keyset id
  - Invalid MacProof, RangeProof, or BalanceProof
- 5xx Internal Server Error

## 9. Settings

The Mint advertises supported method-unit pairs in [NUT-06][06] under key `AC4`:

```json
{
  "AC4": {
    "methods": [
      <MintMethodSetting>,
      ...
    ],
    "disabled": <bool>
  }
}
```

`MintMethodSetting`:
```json
{
  "method": "<str>",
  "unit": "<str>",
  "min_amount": "<int|null>",
  "max_amount": "<int|null>",
  "options": "<Object|null>"
}
```

## 10. Security and Policy Notes

- Keep `quote` secret; use [NUT-20][20] to bind minting to an authenticated key.
- Transcript ordering MUST match between client and Mint.
- Outputs MUST reference active keysets; clients SHOULD refresh keysets (AC-01/AC-02) before minting.
- Tags SHOULD be unique within the request to avoid ambiguity/replay.

[AC-00]: AC00.md
[AC-01]: AC01.md
[AC-02]: AC02.md
[AC-03]: AC03.md
[06]: 06.md
[20]: 20.md
[23]: 23.md
[25]: 25.md
