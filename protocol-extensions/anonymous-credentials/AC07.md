# AC-07: Deterministic Derivation of Tag and Blinding Factors

`optional`

---

Status: Draft proposal
Scope: Deterministic derivation for KVAC attributes and tag to enable wallet recovery
Dependencies: AC-00, AC-01, AC-02, AC-03, AC-06; NUT-09, NUT-13

This document defines a deterministic derivation scheme for three per-note secrets used by KVAC-based Anonymous Credentials:
- tag (UnsignedNote.tag)
- amount attribute blinding factor (for AmountAttribute)
- script attribute blinding factor (for ScriptAttribute)

It mirrors the approach of [NUT-13][13] and extends it from two secrets to three. The goal is to allow wallets to regenerate these values for recovery (e.g., via a future AC restore endpoint akin to [NUT-09][09]).

## 1. Overview

- Wallets derive secrets from a user-held BIP39 mnemonic â†’ BIP32 root.
- Derivations are scoped per keyset to avoid collisions across rotations (keyset-specific counters).
- For each note (i.e., for each Output/UnsignedNote the wallet constructs), the wallet increments a per-keyset counter and derives exactly three values: tag, amount_blind, script_blind.
- The same derivation MUST be used during recovery to reconstruct notes/outputs and request reissuance.

## 2. Derivation Path

We adopt the NUT-13 style path with a separate â€œcoin typeâ€ for KVAC to avoid collisions with classic Cashu secrets:

- Purpose' = 129372' (UTFâ€‘8 for ðŸ¥œ)
- Coin type' = 1' (reserved for AC/KVAC; NUTâ€‘13 uses 0')
- Keyset id' = keyset_id_int' (integer form of the keyset id; see Â§3)
- Counter'  = counter' (perâ€‘keyset, incrementing)
- Component = c âˆˆ {0,1,2}
  - c=0 â†’ tag
  - c=1 â†’ amount attribute blinding factor
  - c=2 â†’ script attribute blinding factor

Derivation:

```
m / 129372' / 1' / keyset_id_int' / counter' / c
```

Rationale:
- Using 1' separates AC/KVAC derivations from NUTâ€‘13â€™s base cashu derivations (0').
- Using hardened components ensures derived private keys are valid and non-leaking.

## 3. Keyset ID to Integer

As in [NUT-13][13], convert the 16-hex-character keyset id (8 bytes) to a bigâ€‘endian integer and reduce mod 2^31âˆ’1 to fit a hardened BIP32 child index:

Python:
```python
keyset_id_int = int.from_bytes(bytes.fromhex(keyset_id_hex), "big") % (2**31 - 1)
```
JavaScript:
```javascript
keysetIdInt = BigInt(`0x${keysetIdHex}`) % BigInt(2 ** 31 - 1);
```

## 4. Counters

- Maintain a perâ€‘keyset counter starting at 0 when the keyset is first used.
- Increment the counter by 1 for each UnsignedNote you generate for that keyset (including decoy zeroâ€‘amount Outputs used to satisfy 2â€‘output policy in ACâ€‘03/04/05).
- Store the latest counter in the wallet database; counters are independent per keyset.

## 5. Deriving Values

For each (keyset_id, counter):
- Derive private key material K_c from the path in Â§2 for each c âˆˆ {0,1,2}.
- Interpret K_c as a 32â€‘byte bigâ€‘endian scalar modulo the Secp256k1 curve order n. BIP32 hardened derivations ensure K_c âˆˆ [1, nâˆ’1].

Mapping to KVAC fields:
- tag := SerializeScalar(K_0) as 32â€‘byte hex (lowercase, no 0x). This becomes UnsignedNote.tag (64â€‘hex).
- amount_blind := SerializeScalar(K_1) as 32â€‘byte hex; pass as the optional blinding factor when constructing AmountAttribute.
- script_blind := SerializeScalar(K_2) as 32â€‘byte hex; pass as the optional blinding factor when constructing ScriptAttribute.

Rust sketch:
```rust
fn derive_scalar_hex(path: &str) -> String { /* BIP32 hardened derivation â†’ 32B â†’ hex */ }
let tag_hex = derive_scalar_hex(&format!("m/129372'/1'/{keyset}'/{counter}'/0"));
let amount_bf_hex = derive_scalar_hex(&format!("m/129372'/1'/{keyset}'/{counter}'/1"));
let script_bf_hex = derive_scalar_hex(&format!("m/129372'/1'/{keyset}'/{counter}'/2"));
```

Constructing attributes (example):
```rust
let amount_attr = cashu_kvac::models::AmountAttribute::new(amount, Some(&amount_bf_hex));
let script_attr = cashu_kvac::models::ScriptAttribute::new(script_bytes, Some(&script_bf_hex));
let tag = tag_hex; // 64-hex
```

## 6. Recovery Behavior

- Given mnemonic and the keyset id, wallets iterate counters in batches (e.g., 100 at a time) to regenerate candidate (tag, amount_blind, script_blind) tuples and corresponding Outputs.
- A future AC restore endpoint (akin to [NUTâ€‘09][09]) can accept these reconstructed Outputs to reissue signatures or to return spent states. Until defined, wallets may use mintâ€‘specific tooling or database dumps.

## 7. Constraints and Interop Rules

- Deterministic derivation is OPTIONAL; when used, it MUST follow this path to remain interoperable across wallets.
- Wallets MUST NOT reuse the same (keyset_id, counter) across multiple Outputs; reuse leads to tag reuse and linkability.
- For multiâ€‘Output requests (ACâ€‘03/04/05 require 2 outputs), allocate two consecutive counters and derive two separate tripleâ€‘sets.
- Decoy zeroâ€‘amount Outputs/Inputs MUST consume counters like normal Outputs.
- All hex encodings are lowercase, no 0x prefix.

## 8. Security Considerations

- Seed compromise endangers privacy of deterministic tags; protect mnemonic with best practices (hardware secure elements where possible).
- Keeping derivations keysetâ€‘scoped avoids crossâ€‘mint/keyset correlation; wallets MUST derive `keyset_id_int` per ACâ€‘01/02.
- Deterministic tags are never sent to third parties except the Mint; however, Mints can observe tag uniqueness. Prefer not to embed sensitive metadata in scripts.

## 9. Test Vectors (TBD)

Add crossâ€‘wallet test vectors once a reference implementation exists.

[09]: ../09.md
[13]: ../13.md
[AC-00]: AC00.md
[AC-01]: AC01.md
[AC-02]: AC02.md
[AC-03]: AC03.md
[AC-06]: AC06.md
