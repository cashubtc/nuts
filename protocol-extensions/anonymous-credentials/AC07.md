# AC-07: Deterministic Derivation of Tag and Blinding Factors

`mandatory`

---

Status: Draft proposal
Scope: Deterministic derivation for KVAC attributes and tag to enable wallet recovery
Dependencies: AC-00, AC-01, AC-02, AC-03, AC-06; NUT-09, NUT-13

This document defines a deterministic derivation scheme for three per-note secrets used by KVAC-based Anonymous Credentials:
- tag (UnsignedNote.tag)
- amount attribute blinding factor (for AmountAttribute)
- script attribute blinding factor (for ScriptAttribute)

It mirrors and extends [NUT-13][13] from two secrets to three and adopts the versioned derivation model from NUT-13 v1/v2. We retain BIP39 mnemonic â†’ seed, but we DO NOT use BIP32 for keyset version v2. Instead, we use an HMAC-SHA256 KDF (see Â§2.2). BIP32 remains only for legacy keyset version v1 (backward compatibility). The goal is to allow wallets to regenerate these values for recovery (e.g., via a future AC restore endpoint akin to [NUT-09][09]).

## 1. Overview

- Wallets derive secrets from a user-held BIP39 mnemonic â†’ BIP32 root.
- Derivations are scoped per keyset to avoid collisions across rotations (keyset-specific counters).
- For each note (i.e., for each Output/UnsignedNote the wallet constructs), the wallet increments a per-keyset counter and derives exactly three values: tag, amount_blind, script_blind.
- The same derivation MUST be used during recovery to reconstruct notes/outputs and request reissuance.

## 2. Versioned Deterministic Derivation

We adopt the versioned secret derivation model (see changes introduced in NUT-13 v1/v2). Wallets MUST first determine the keyset version from the keyset id (per NUT-13 changes):
- v1 (legacy, version 00): BIP32-based derivation (backward compatible)
- v2 (version 01): HMAC-SHA512 KDF; BIP32 MUST NOT be used

Wallets MUST retain BIP39 mnemonic â†’ seed, but MUST choose the derivation algorithm based on the keyset version as below.

### 2.1 v1 (legacy) â€” BIP32 path (extended to 3 components)

- Purpose' = 129372' (UTFâ€‘8 for ðŸ¥œ)
- Coin type' = 1' (reserved for AC/KVAC; base Cashu uses 0')
- Keyset id' = keyset_id_int' (see Â§3)
- Counter'  = counter' (perâ€‘keyset, incrementing)
- Component = c âˆˆ {0,1,2}
  - c=0 â†’ tag
  - c=1 â†’ amount attribute blinding factor
  - c=2 â†’ script attribute blinding factor

Derivation:

```
m / 129372' / 1' / keyset_id_int' / counter' / c
```

The derived private key at this path is interpreted as a 32â€‘byte scalar modulo the Secp256k1 order n.

### 2.2 v2 â€” HMAC-SHA256 KDF (no BIP32)

For version 01 keysets, derive each component with an HMACâ€‘SHA256 keyed by the BIP39 seed. This mirrors the updated NUTâ€‘13 v2 KDF and adds a component byte to obtain three distinct outputs.

Let:
- seed = BIP39 seed (512-bit from mnemonic)
- keyset_id_bytes = raw keyset id bytes (v1: 8 bytes; v2: 33 bytes)
- counter_bytes = 8â€‘byte unsigned bigâ€‘endian counter
- c_bytes = 1â€‘byte component selector where c âˆˆ {0,1,2}
- label = ASCII string "Cashu_KDF_HMAC_SHA256"

Compute for each c:

```
raw = HMAC_SHA256( key=seed,
                   data = label || keyset_id_bytes || counter_bytes || c_bytes )
```

Interpret `raw` as a bigâ€‘endian 256â€‘bit integer and reduce modulo the Secp256k1 order n to obtain a scalar in [1, nâˆ’1]. We keep the whole 32â€‘byte output (no slicing beyond the HMACâ€‘SHA256 digest size):

```
scalar_c = int(raw) mod n
if scalar_c == 0: scalar_c = 1
```

Mapping:
- c=0 â†’ tag scalar â†’ 32â€‘byte hex â†’ UnsignedNote.tag (64â€‘hex)
- c=1 â†’ amount attribute blinding factor (hex)
- c=2 â†’ script attribute blinding factor (hex)

## 3. Keyset ID to Integer (v1 only)

As in [NUT-13][13], convert the 16-hex-character keyset id (8 bytes) to a bigâ€‘endian integer and reduce mod 2^31âˆ’1 to fit a hardened BIP32 child index:

Python:
```python
keyset_id_int = int.from_bytes(bytes.fromhex(keyset_id_hex), "big") % (2**31 - 1)
```
JavaScript:
```javascript
keysetIdInt = BigInt(`0x${keysetIdHex}`) % BigInt(2 ** 31 - 1);
```

Note: This integer mapping applies only to v1 keysets (8â€‘byte IDs). v2 uses the raw 33â€‘byte keyset id in the KDF (see Â§2.2) and does not require integer conversion.
## 4. Counters

- Maintain a perâ€‘keyset counter starting at 0 when the keyset is first used.
- Increment the counter by 1 for each UnsignedNote you generate for that keyset (including decoy zeroâ€‘amount Outputs used to satisfy 2â€‘output policy in ACâ€‘03/04/05).
- Store the latest counter in the wallet database; counters are independent per keyset.

## 5. Deriving Values

For each (keyset_id, counter):
- Derive private key material K_c from the path in Â§2 for each c âˆˆ {0,1,2}.
- Interpret K_c as a 32â€‘byte bigâ€‘endian scalar modulo the Secp256k1 curve order n. BIP32 hardened derivations ensure K_c âˆˆ [1, nâˆ’1].

Mapping to KVAC fields:
- tag := SerializeScalar(K_0) as 32â€‘byte hex (lowercase, no 0x). This becomes UnsignedNote.tag (64â€‘hex).
- amount_blind := SerializeScalar(K_1) as 32â€‘byte hex; pass as the optional blinding factor when constructing AmountAttribute.
- script_blind := SerializeScalar(K_2) as 32â€‘byte hex; pass as the optional blinding factor when constructing ScriptAttribute.

Rust sketch:
```rust
fn derive_scalar_hex(path: &str) -> String { /* BIP32 hardened derivation â†’ 32B â†’ hex */ }
let tag_hex = derive_scalar_hex(&format!("m/129372'/1'/{keyset}'/{counter}'/0"));
let amount_bf_hex = derive_scalar_hex(&format!("m/129372'/1'/{keyset}'/{counter}'/1"));
let script_bf_hex = derive_scalar_hex(&format!("m/129372'/1'/{keyset}'/{counter}'/2"));
```

Constructing attributes (example):
```rust
let amount_attr = cashu_kvac::models::AmountAttribute::new(amount, Some(&amount_bf_hex));
let script_attr = cashu_kvac::models::ScriptAttribute::new(script_bytes, Some(&script_bf_hex));
let tag = tag_hex; // 64-hex
```

## 6. Recovery Behavior

- Given mnemonic and the keyset id, wallets iterate counters in batches (e.g., 100 at a time) to regenerate candidate (tag, amount_blind, script_blind) tuples and corresponding Outputs.
- A future AC restore endpoint (akin to [NUTâ€‘09][09]) can accept these reconstructed Outputs to reissue signatures or to return spent states. Until defined, wallets may use mintâ€‘specific tooling or database dumps.

## 7. Constraints and Interop Rules

- Deterministic derivation is OPTIONAL; when used, it MUST follow this path to remain interoperable across wallets.
- Wallets MUST NOT reuse the same (keyset_id, counter) across multiple Outputs; reuse leads to tag reuse and linkability.
- For multiâ€‘Output requests (ACâ€‘03/04/05 require 2 outputs), allocate two consecutive counters and derive two separate tripleâ€‘sets.
- Decoy zeroâ€‘amount Outputs/Inputs MUST consume counters like normal Outputs.
- All hex encodings are lowercase, no 0x prefix.

## 8. Security Considerations

- Seed compromise endangers privacy of deterministic tags; protect mnemonic with best practices (hardware secure elements where possible).
- Keeping derivations keysetâ€‘scoped avoids crossâ€‘mint/keyset correlation; wallets MUST derive `keyset_id_int` per ACâ€‘01/02.
- Deterministic tags are never sent to third parties except the Mint; however, Mints can observe tag uniqueness. Prefer not to embed sensitive metadata in scripts.

## 9. Test Vectors (TBD)

Add crossâ€‘wallet test vectors once a reference implementation exists.

[09]: ../09.md
[13]: ../13.md
[AC-00]: AC00.md
[AC-01]: AC01.md
[AC-02]: AC02.md
[AC-03]: AC03.md
[AC-06]: AC06.md
