# AC-03: Swap Transaction

`mandatory`

---

This document describes the core process by which a client can present previously signed `Note`s and get Mint signatures on `UnsignedNote`s. That is, if all conditions are upheld.

## Use Cases

### Swap To Send

```
sending user: Alice

receiving user: Carol
```

Alice has a 64 sat `Note`. She wants to send Carol 40 sat, but does not have the necessary `Note`. For that, Alice requests a swap from the Mint and uses her `Note` plus a `Note` worth *zero* (see [AC-??][AC-??]) as `Input`s [0, 64] and asks for new `Output`s worth [40, 24] totalling 64 sat. The `Note`s that Alice sent to the Mint as `Input`s of the swap operation are now invalidated.

[AC-??]: AC??.md

### Swap To Receive

```
sending user: Alice

receiving user: Carol
```

The second use case for the swap operation follows up on the example above, where Alice has swapped her `Note`s ready to be sent to Carol. Carol can receive the `Note` using the same operation: the received `Note` is used as `Input` and  new `Output`s are requested from the Mint.
Remember that `Output`s are just `UnsignedNote`s with less information about them. 
Once Carol has redeemed to new `Output`s, Alice can't double-spend the `Note` anymore and the transaction is settled, all the while the Mint is unaware it happened.

## Process

We describe the swap process following the case of the "Swap To Receive" example. Specifically, we assume the client possesses two `Note`s: one that encodes the current balance `b`; the other is received from another user of the same Mint and encodes an amount `a`. The client needs to "merge" these `Note`s into one to attain a new balance. 

### 1. Client generates `UnsignedNote`s and `Output`s

The client selects an appropriate `keyset_id` amongst the active keysets and generates two `UnsignedNote`s (see [AC-00][AC-00]):
* one with for the amount `b+a`.
* one with the amount `0`.

Then, for each `UnsignedNote`, they derive the corresponding `Output` as shown in [AC-00][AC-00].

### 2. Client derives `Input`s.

For each of the two `Note`s, the client derives `Input`s as shown in [AC-00][AC-00].

### 3. Client generates Zero-Knowledge Proofs

First, create a `cashu_kvac::transcript::CashuTranscript` instance. This will be used throughout the generation of the proofs.
```rust
let transcript = cashu_kvac::transcript::CashuTranscript::new();
``` 

Then, generate the following proofs:
1. For each `Input` generate a `MacProof`. This proves the signature on that input.
```rust
let mac_proof = cashu_kvac::kvac::MacProof::create(&mint_publickey, &note.attributes.0, Some(&note.attributes.1), note.tag, &input.randomized_commitments, &mut transcript);
```
2. Generate one `RangeProof` for *all* `UnsignedNote`s. This proves that each `Output` is in range.
```rust
let amount_attributes: Vec<AmountAttribute> = unsigned_notes.iter().map(|u| u.attributes.0.clone()).collect();
let range_proof = cashu_kvac::kvac::RangeProof::create_bulletproof(&mut transcript, &amount_attributes);
```
3. Generate a `BalanceProof`. This proves that inputs and outputs are balanced.
```rust
let balance_proof = cashu_kvac::kvac::BalanceProof::create(&inputs_amount_attributes, &outputs_amount_attributes, &mut transcript);
```

> [!NOTE]
> The order is important. If client/Mint prove/verify in a different order, the verification won't succeed.


### 4. Client sends a `SwapRequest`

The client then performs a `POST v1/kvac/swap` request with the following `SwapRequest` payload:
```json
{
    "inputs": [<Input>, ...],
    "outputs": [<Output>, ...],
    "balance_proof": <cashu_kvac::models::ZKP>,
    "mac_proofs": [<cashu_kvac::models::ZKP>, ...],
    "range_proof": <cashu_kvac::models::RangeZKP>,
}
```


### 5. Mint receives and verifies `SwapRequest`

Validation of a swap request works this way:

0. Verify all `Input`s and `Output`s are of the same unit.

1. Extract -if any- `script` and `witness` from each `Input`, and verify the spending conditions according to either [NUT-11][11] or [NUT-14][14].

2. Create a `CashuTranscript` instance. This will be used throughout the verification of the proofs:
```rust
let transcript = cashu_kvac::transcript::CashuTranscript::new();
```

3. Verify each (`Input`, `MacProof`) pair: if `input.randomized_commitments.nullifier()` was already presented before, reject the transaction. If not, then use the key from the `input.id` keyset to verify the `MacProof`:
```rust
cashu_kvac::kvac::MacProof::verify(
    &mint_privkeys[input.id],
    &input.randomized_commitments,
    &input.script, // This will be None if the input does not provide a script
    mac_proof,
    &mut transcript,
);
```

4. Verify the `RangeProof` with the amount commitments in each `Output`:
```rust
let amount_commitments: Vec<GroupElement> = outputs.iter().map(|o| o.commitments.0).collect();
cashu_kvac::kvac::RangeProof::verify(&mut transcript, &amount_commitments, range_proof);
```

5. Verify the `BalanceProof`. Use `input.randomized_commitments` from each input, `output.commitments[0]` from each output and the supposed difference between their value, which in this case is $0$.

```rust
cashu_kvac::kvac::BalanceProof::verify(
    &inputs_randomized_commitments,
    &outputs_amount_commitments,
    0 as i64,
    balance_proof,
    &mut transcript
);
```

> [!NOTE]
> If a keyset supports fees, the difference between inputs and outputs should be equal to the fee the Mint enforces on the inputs.

### 6. Mint issues signatures

If all of the previous verifications succeeded, the Mint issues a `mac` for each `output` in `outputs` using the key from the keyset with ID `output.id` (see [AC-00][AC-00]).

The Mint also computes and returns a `IssuanceProof` for each issued `mac`:

```rust
let issuance_proof = cashu_kvac::kvac::IssuanceProof::create(
    &mint_privkeys[output.id],
    output.tag,
    mac,
    output.commitments.0,
    Some(output.commitments.1),
);
```

> [!NOTE]
> The Mint does not use the transcript to compute this proof.

Finally, the response the the swap request `SwapResponse` is as follows:

```json
{
    "outputs": [<Output>, ...],
    "issued_macs": [<hex-pubkey>, ...],
    "issuance_proofs": [<cashu_kvac::models::ZKP>, ...]
}
```

### 7. Client verifies and assembles `Notes`

In the final step, the client receives a `SwapResponse` and verifies each (`UnsignedNote`, `MAC`, `IssuanceProof`) pair:
```rust
    cashu_kvac::kvac::IssuanceProof::verify(
        &mint_pubkey,
        unsigned_note.tag,
        mac,
        &unsigned_note.attributes.0,
        Some(&unsigned_note.attributes.1),
        issuance_proof.clone(),
    )
```

They can then proceed to create a full `Note` by combining `UnsignedNote` and the received `MAC` and `IssuanceProof`.


[AC-00]: AC00.md
[11]: 11.md
[14]: 14.md